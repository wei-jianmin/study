已知目录结构：
 .
    a/
      a1.so
      a2.so
      a3.so
    b/
      b1.so
      b2.so
    c/
      c1.so
      c2.so
  
readelf -d c2.so
可以确定动态库的寻找路径包含了a和b文件夹

问题描述：
  ldd c2.so
  显示能正常找到如下动态库：
    a1.so
    b1.so
    b2.so
    c1.so
    系统相关动态库
  缺失动态库：
    a2.so
    a3.so
  
尝试：
  设置LD_LIBRARY_PATH，使之包含a文件夹，再ldd c2.so，发现可以找到缺失的a2.so，a3.so了
  设置LD_LIBRARY_PATH，取消对a文件夹的包含，再ldd c2.so，仍旧提示缺失a2.so，a3.so动态库

最终发现的问题原因：
  c1.so依赖a2.so,a3.so，但c1.so没有设置动态库查找路径
  但c2.so并不直接依赖上面这两个动态库（所以不会主动根据设置的加载路径，提前加载这两个动态库）
  因为间接依赖的原因，导致ldd会发现缺失这两个动态
  解决办法就是为c1.so设置动态库查找路径
  
总结：
  ldd 查看依赖动态库时，不仅列出了直接依赖库，还会查找间接依赖库
  所以ldd列出的是动态库的“依赖树”
  通过readelf -d 可以查看当前文件记录的、直接依赖的动态库

  

