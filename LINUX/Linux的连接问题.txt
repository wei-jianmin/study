1. 连接时，总是从带main的文件开始找起，其前面的文件被忽略，不会放到“待链接文件列表中”
2. 链接 .o 文件时，其一定会并链接到当前程序中，但链接库文件，无论是静态库，还是动态库，则并不一定会被链接到当前程序中，
   这取决于该库是否包含“未决符号表”中的符号
3. 如果发现静态库中包含未决符号，则直接抽出其中对应的.o子文件
4. 如果动态库中包含未决符号，则链接该动态库
5. 用 nm 观察生成文件的符号表，会发现列出了如下函数：
    ● 当前所有链接的.o文件（包括提取的库中的某个或某些.o文件）中的函数，
    ● 上面这些.o文件，通过符号表，而引入的其它文件中的函数
    ● 这些间接引入的.o文件，也能通过符表，又再次引入其它的文件，如此迭代
    ● 上面.o文件“直接”引用到的动态库中的函数（没有被"直接"引用到的函数不会列出来）
    
    也就是说，如果碰到链接的.o文件（当然源码文件肯定也在此列），其中的函数会一个不少的出现在编译生成的文件中，
    如果碰到链接的.a文件，则只有必要的.o子文件会被链接到生成文件中。
    注意，.o文件中如果函数内部又引用了其它不在本.o文件中定义的函数，则这样的函数会出现在当前.o文件的未决符号表中，
    所以，链接.o文件时，也会引入新的未决符号，从而导致引入链接其它的文件（.a中的.o文件，或.so文件）。
    而如果碰到链接的.so文件，则只有该so文件中的“存在于链接未决符号表”中的函数会出现在 nm 符号表中，
    假设前面的.o文件中调用到了func_x(),而该函数位于动态库中，则只有func_x会出现在nm符号表中，
    而.so文件中的其它函数，不管是与func_x()同一cpp文件中的其它函数，还是func_x()中调用到的任何函数，
    都不会出现在当前编译生成文件的nm符号表中。 
    链接器会总和检查所链接的所有动态库的符号表，确定最终不会存在未决符号，但不会将动态库的符号表整合到当前编译生成程序的符号表中
    而链接器却会将.o文件的符号表整合到当前编译生成程序的符号表中。
    另： 用 nm -D 则只列出依赖的动态库中的函数，过滤掉所有.o（包括源文件）中的函数，
         通过strip命令，可以把编译生成文件的所有静态符号表(.symbol)删掉，
         但不能把动态符号表(.dynsym)删掉，所以有时可能 nm 为空，但 nm -D 不为空。
    另： 程序运行时，如果加载了一个动态库，则该动态库的 nm 符号表会一股脑的被引入进来。
         所以这时候可能就引来这样一个问题：动态库a中的符号，与动态库b中的符号，存在重复
         这时候就会按规则取舍：
         如果是重复的是强符号，则会报错
         如果重复的是弱符号，则不确定那个会被使用（？）
引用动态库 vs 引用静态库
    引用静态库，执行进程只有一张符号表：当前可执行程序的符号表
    引用动态库，执行进程有多张符号表，除了当前可执行程序的符号表，还有动态库的符号表
    引用静态库，只有那些有用的.o文件会被引用到，静态库中无用的.o文件会被忽略，所以被忽略的.o子文件中的符号，不会出现在可执行程序的符号表中
    引用动态库，该动态库中的所有文件，其中的符号总是出现在动态库的符号表中的
         
阅读器界面文字不显示问题猜测：
之前连接的corelib是静态库形式
现在连线的corelib是动态库形式
         