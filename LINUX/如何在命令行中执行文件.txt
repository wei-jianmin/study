在执行一个脚本的时候，我们通常 ./***.sh，然后脚本就执行了，这背后的原理是什么呢？
为什么前面要带./ ? 
如果不带能不能执行 ？
根目录的脚本文件怎么执行 ？

下面将对上面问题进行介绍：
1. 在shell中执行命令时，首先看其是否是 alias 指定的命令
   通过输入 alias ，可以查看当前都 alias 了哪些命令
2. 如果发现不是 alias 指定的命令，则在内置命令中查找
   通过输入 help ，可以查看有哪些内置命令
   或者也可以 type 命令，查看该命令是否是内置命令
3. 如果内置命令中也没有找到，则在 PATH 路径中查找
4. 除了以上方式外，也可以用绝对路径或相对路径定位可执行文件
   上面的 ./***.sh 就是这种用法

上面的1、2、3、4条，前提都是找到的文件具有可执行权限，否则尽管找到了，但会报错：权限不够
如果找到的是文本文件，则默认使用 /bin/bash 执行该脚本文件，
当然也可以在该文本文件中，通过 #! ****  指定使用哪种解释器来执行该文件
如果找到的是二进制文件，则会使用 execl 族函数，创建一个新的进程来执行该文件

到了这里，文件的执行基本就讲完了，为什么说是基本讲完呢？
是因为其实上面漏讲了一点，即：当找到的文本文件，本身没有执行权限时，我们仍然有办法执行该文件
方法为： sh/bash/source/. 脚本文件名（绝对路径或相对路径）   
注： 
    sh和bash是两个稍有不同的脚本解释器，/bin/sh 相当于 /bin/bash --posix
    . 也是个命令，具有与 source 等价的效果，如 . /oes_path.sh 等同于 source /oes_path.sh
    使用 help . ，可以获取 . 命令的帮助介绍
    sh/bash 都是使用解释器执行脚本文件
    而 source/. 是在当前shell中执行文件中的命令
    举例说明：
        如果一个脚本文件中有 ss="abc" 这样一条语句（前面没有export），
        使用sh或bash执行该脚本文件后，再使用 echo $ss ，是没有输出信息的
        而使用 source或. 执行该脚本文件，则 echo $ss ，可以打印出ss的值：abc
在这几种情形下，尽管文本文件没有执行权限，但仍然能正常执行，
这是因为真正执行的命令是 sh/bash/source/. ，文件只是作为命令的传入参数

补充：
根据上面提到的可执行文件的查找顺序，我们可以知道，
对于 linux 的内置命令，我们可以用 alias 将其覆盖， 类似函数重载，
可以在保持原来命令意思的基础上，丰富该命令的功能，如实现自定义的cd命令