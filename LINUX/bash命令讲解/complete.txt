complete命令指定如何对各个名称进行补全
complete [-abcdefgjksuv] 
         [-pr] [-DEI] 
         [-o 选项] 
         [-A 动作] 
         [-C 命令] 
         [-F 函数] 
         [-G 全局模式]
         [-P 前缀] 
         [-S 后缀] 
         [-W 词语列表]  
         [-X 过滤模式] 
         [名称 ...]

选项“-r”用以删除指定名称的补全方法，不指定名称时删除所有的名称的补全方法。
选项“-D”的意思是其后的选项和动作将应用到默认命令补全，也就是说之前未定义的补全命令也可以补全。
-p  : 以可重用的格式打印现有的补全规则
-r  ：对每一个<名称>删除补全规约，或者如果没有提个<名称>，则删除所有的补全规约
-D  ：设定默认非补全和动作，给没有定义补全规约的命令使用
-E  ：对于empty的命令设定补全动作 -- 对于空行的补全
-I  ：将补全和动作应用在首个单词（通常是所给命令）上
尝试补全时，按照上述大写字母的顺序进行动作，如果给出了多个选项，则 -D > -E > -I

“-A alias”      ：别名，同选项“-a”。
“-A builtin”    ：shell内建命令名，同选项“-b”。
“-A command”    ：命令名，同选项“-c”。
“-A directory”  ：目录名，同选项“-d”。
“-A export”     ：导出的shell变量名，同选项“-e”。
“-A file”       ：文件名，同选项“-f”。
“-A group”      ：组名，同选项“-g”。
“-A job”        ：作业名，同选项“-j”。
“-A keyword”    ：shell保留字，同选项“-k”。
“-A service”    ：服务名，同选项“-s”。
“-A user”       ：用户名，同选项“-u”。
“-A variable”   ：所有的shell变量名，同选项“-v”。

“-A arrayvar”   ：数组变量名。
“-A binding”    ：“readline”键绑定名。
“-A disabled”   ：不可用的shell内建命令名。
“-A enabled”    ：可用的shell内建命令名。
“-A function”   ：shell函数名。
“-A helptopic”  ：内建命令help支持的帮助主题。
“-A hostname”   ：主机名，从shell环境变量HOSTFILE中获取。
“-A running”    ：正在运行的作业名。
“-A setopt”     ：内建命令set的选项“-o”可用的参数。
“-A shopt”      ：内建命令shopt可接受的选项名。
“-A signal”     ：信号名。
“-A stopped”    ：暂停的作业名。

“-o bashdefault”：如果没有生成补全条目，就使用bash默认的其它补全。
“-o default”    ：如果没有生成补全条目，就使用“readline”默认的文件名补全。
“-o dirnames”   ：如果没有生成补全条目，就进行目录名补全。
“-o filenames”  ：告诉“readline”生成文件名，以便进行与文件名相关的处理，
                  例如在目录名后面加上斜杠，引用特殊字符，去掉行尾的空格，目的是用于shell函数。
“-o noquote”    ：告诉“readline”不引用文件名，默认会进行引用。
“-o nospace”    ：告诉“readline”在补全的名称后不添加空格，默认添加空格。
“-o plusdirs”   ：生成补全条目之后，还会进行目录名补全并把结果添加到其它动作得到的结果中。

“-C command”    ：在子shell中执行命令，并把其结果作为补全条目。
“-F function”   ：在当前的shell环境中执行函数function，执行时，
                  参数“$1”  表示那个参数正在进行补全的命令名，
                  参数“$2”表示补全的名称，参数“$3”表示补全的名称前面的单词，
                  表示结束执行时，从数组变量COMPREPLY中获取补全条目
                  （函数返回内容只有一行时，直接自动补全，有多行时，展示候选列表）
“-G globpat”    ：使用文件名扩展模式globpat进行扩展以生成可能的补全条目。
“-P prefix”     ：在所有的选项应用到补全结果后，在结果前添加前缀prefix。
“-S suffix”     ：在所有的选项应用到补全结果后，在结果后添加后缀suffix。
“-W wordlist”   ：使用特殊变量IFS中的字符拆分单词列表wordlist，并扩展拆分后的每个单词，
                  结果中与待补全单词匹配的条目就是补全条目。
“-X filterpat”  ：filterpat是进行文件名扩展时使用的模式，
                  它作用于通过前面的选项和参数生成的补全列表，
                  并把每个与过滤模式匹配的条目删除，模式中前导的叹号表示否定，
                  这时会删除与过滤模式不匹配的条目。

====================================================================================================================

使用补全相关的 Shell 变量
COMP_CWORD
    ${COMP_WORDS} 的索引，指向当前光标位置所在的词。这个变量只有在被可编程补全功能调用的 shell 函数中才可用
COMP_LINE
    当前命令行。这个变量只有在被命令补全功能调用的 shell 函数和外部命令中才可用。
COMP_POINT
    相对于当前命令起始处的当前光标位置。如果当前光标位置是当前命令的末端， 它的值就和 ${#COMP_LINE} 相等。 
    这个变量只有在被命令补全功能调用的 shell 函数和外部命令中才可用。
COMP_WORDS
    一个数组变量 (参见下面的 Arrays(数组)一节)，由当前命令行的各个单词构成。 
    这个变量只有在被命令补全功能调用的 shell 函数中才可用。
COMPREPLY
    一个数组变量，bash 从中读取可能的命令补全。 它是由命令补全功能调用的 shell 函数产生的。 
FIGNORE
    一个冒号分隔的后缀名列表，在进行文件名补全时被忽略 (参见下面的 READLINE 章节)。
    一个后缀满足其中之一的文件名被排除在匹配的文件名之外。可以是这样： ".o:~".
GLOBIGNORE
    一个冒号分隔的模式列表，定义了路径名扩展时要忽略的文件名集合。 
    如果一个文件名与路径扩展模式匹配，同时匹配 GLOBIGNORE 中的一个模式时，它被从匹配列表中删除。    

====================================================================================================================

bash的补全规则

补全规则的查找顺序：
1. 首先，命令名被确认。
2. 如果针对这个命令有补全规则的定义，而命令词是一个路径全名，将首先搜索针对这个路径全名的规则。
3. 如果针对这个路径全名没有找到规则，将尝试查找针对最后一个斜杠后面的部分的规则。
一旦找到了一个规则，它将用作产生匹配的词。如果没有找到，将进行上面 Completing 中描述的 bash 默认的补全。

执行补全规则时：
1. 首先，将执行规则指定的动作。
2. 当在文件或目录名补全中使用 -f 或 -d 选项时，shell 变量 FIGNORE 将用于对匹配进行过滤。
3. 接下来，将产生所有由-G 选项给出的文件名扩展模式指定的补全。 模式产生的词不必匹配要补全的词。
   shell 变量 GLOBIGNORE 不会用于过滤匹配结果，但是变量 FIGNORE 会被使用。
4. 接下来，将考虑 -W 选项的参数指定的字符串。这个字符串首先被划分：用特殊变量 IFS 中的字符作为分隔符。
   然后每个词被扩展：使用上面 EXPANSION 中描述的 brace expansion, tilde expansion, parameter 和 
   variable expansion, command substitution, arithmetic expansion, 以及 pathname expansion 规则处理。
   对于结果，再使用上面 Word Splitting 中描述的规则划分成词。
   扩展的结果与要补全的词进行前部一致的比较，匹配的词成为可能的补全。
5. 在这些匹配被产生后，任何由 -F 和 -C 选项指定的 shell 函数和命令将被执行。
   当命令或函数被执行时，变量 COMP_LINE 和 COMP_POINT 被赋值，使用上面 Shell Variables 中的规则。 
   如果要执行 shell 函数，还将设置变量 COMP_WORDS 和 COMP_CWORD 。
   当函数或命令被执行时，第一个参数是等待参数被补全的命令的名称，
   第二个参数是要补全的词，第三个参数是当前命令行中，要补全的词前面的词。
   对要补全的词产生的补全不会进行任何过滤；函数或命令在产生匹配时有完全的自由。
   任何 -F 指定的函数将被首先执行。函数可以使用任何 shell 功能， 包含内建命令 compgen，来产生匹配。
   它必须将可能的补全放到数组变量 COMPREPLY 中。
   例如：COMPREPLY=($(compgen -W "${fix_list}" -- "${cur}"))
6. 接下来，任何 -C 选项指定的命令将被执行，其执行环境与命令替换 的环境相同。
   它应当向标准输出打印一个补全的列表，每行一个。 反斜杠可以用来转义一个新行符，如果需要的话。
7. 所有可能的补全都产生之后，将对列表进行 -X 选项指定的任何过滤。
   过滤器是一个模式，和路径名扩展中的一样；模式中的 & 替换为要补全的词。
   字面上的 & 可以用反斜杠转义；反斜杠在进行匹配时被删除。任何匹配这个模式的补全将从列表中删除。
   前导的!将使模式含义相反； 这种情况下，任何不匹配这个模式的补全将被删除。
8. 最后，-P 和 -S 指定的任何前缀和后缀被添加到补全列表的每个成员后面，
   结果返回给 readline 补全代码，作为可能的补全列表。 
9. 如果先前执行的动作没有产生任何匹配，并且在定义 compspec 规则时，
   为 complete 命令提供了 -o dirname 选项，将尝试目录名补全。
默认情况下，如果找到了一个规则，它产生的任何东西都被返回给补全代码， 作为可能的补全的全集。
不再尝试默认的 bash 补全，readline 默认的文件名补全也会禁止。
如果定义规则时，为 complete 命令提供了 -o default 选项，在规则没有产生匹配时将进行 readline 默认的补全处理。
当一个规则指出期望目录名补全时，可编程补全函数强制 readline 在补全的名称后面添加一个斜杠，如果它是一个到目录的符号连接。
然后还要经过 readline 变量 mark-directories 的值处理，不管 readline 变量 mark-symlinked-directories 的值是什么。  
 
====================================================================================================================

举例：
1. 
    使用 complete -p ，可打印出所有使用complete指定过自动补全的命令
2.
    echo "abc" > a.sh
    chmod a+x a.sh
    complete -C ./a.sh mc
    输入命令 mc ，空格，tab，会自动在后面补上 abc