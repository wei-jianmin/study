http://c.biancheng.net/view/4028.html

此命令执行数据的顺序如下：
    每次仅读取一行内容；
    根据提供的规则命令匹配并修改数据。注意，sed 默认不会直接修改源文件数据，而是会将数据复制到缓冲区中，修改也仅限于缓冲区中的数据；
    将执行结果输出。
    当一行数据匹配完成后，它会继续读取下一行数据，并重复这个过程，直到将文件中所有数据处理完毕。
    
sed [选项] '脚本命令' 文件名

选项	含义
-e      脚本命令	该选项会将其后跟的脚本命令添加到已有的命令中。
-f      脚本命令文件	该选项会将其后文件中的脚本命令添加到已有的命令中。
-n	    默认情况下，sed 会在所有的脚本指定执行完毕后，会自动输出处理后的内容，而该选项会屏蔽启动输出，需使用 print 命令来完成输出。
-i	    此选项会直接修改源文件，要慎用。

sed脚本命令
    基本语法 sed [选项] '[address]命令字[及命令参数]'
            如果不指定address，则匹配所有行
            address有两种表示方法：
            1. 数字形式 ： 开始行号[,结束行号]    第一行行号为1，结束行可以用$表示
            2. 正则表达式过滤 ： /正则表达式/ 或 \■regexp■   ■可以是任何字符  符合正则表达式的行被过滤
    命令字（部分）：
        s查找替换、y字符替换、c行替换、
        a/i插入行、r插入文件、d删除行、
        p打印、w写文件、
        q退出
        多个语句可以通过;进行分隔，也可以使用多个-e选项，带多个命令脚本，
        如 sed -n -e '/build/p' -e '/build/='  /etc/cli.cfg
    s  替换
        语法： [address]s/pattern/replacement/[flags]
        pattern ： 用正则表达式定位当前行中要被replacement替换的位置
        /       :  s和pattern和replacement之间和replacement之后的/，也可以是其它字符
        flags 标记	功能
            n	1~512 之间的数字，表示指定要替换的字符串出现第几次时才进行替换，
                例如，一行中有 3 个 A，但用户只想替换第二个 A，这是就用到这个标记；
            g	对数据中所有匹配到的内容进行替换，
                如果没有 g，则只会在第一次匹配成功时做替换操作。
                例如，一行数据中有 3 个 A，则只会替换第一个 A；
            p	会打印与替换命令中指定的模式匹配的行。此标记通常与 -n 选项一起使用。
            w file	将缓冲区中的内容写到指定的 file 文件中；
            &	用正则表达式匹配的内容进行替换；
            \n	匹配第 n 个子串，该子串之前在 pattern 中用 \(\) 指定。
            \	转义（转义替换部分包含：&、\ 等）。
        特殊符号的使用
            ”^”表示行首
            ”$”符号如果在引号中表示行尾，但是在引号外却表示末行(最后一行)
            “&”符号出现在引号中，表匹配到的当前行
            例：
            sed 's/$/&添加的尾部/g' 　　　　 #在所有行末添加
            sed '2s/原字符串/替换字符串/g'　 #替换第2行
            sed '$s/原字符串/替换字符串/g'   #替换最后一行
            sed '2,5s/原字符串/替换字符串/g' #替换2到5行
            sed '2,$s/原字符串/替换字符串/g' #替换2到最后一行
    y  单字符一一替换
        [address]y/inchars/outchars/
        转换命令会对 inchars 和 outchars 值进行一对一的映射，
        即 inchars 中的第一个字符会被转换为 outchars 中的第一个字符，
        第二个字符会被转换成 outchars 中的第二个字符...
        这个映射过程会一直持续到处理完指定字符
        如果 inchars 和 outchars 的长度不同，则 sed 会产生一条错误消息。
        sed 'y/123/789/' data8.txt  把(当前读到的行)所有的1替换为7，2替换为8，3替换为9
    c  替换
        将指定行的内容，替换成该选项后面的字符串
        语法： [address]c\用于替换的新文本
    a  和 i  插入
        命令表示在指定行的后面附加一行，i 命令表示在指定行的前面插入一行
        语法： [address]a\新文本内容    [address]i\新文本内容
     r  将一个指定文件的数据，插入到当前数据流的指定行之后
        语法： [address]r filename
    d  删除
        语法： [address]d
     p  打印指定行
        语法 ： [address]p
     w  写文件
        将指定行的内容写入文件中
        语法 ： [address]w filename
     q  退出sed
        语法 ： [address]q
     =  输出行号
        语法 ： =
        
sed高级用法
    N，n
        参：https://www.cnblogs.com/fhefh/archive/2011/11/14/2248942.html
        N ： 一次性读取两行到缓冲区，输出时也是输出这两行的内容
        n ： 一次性读取两行到缓冲区，输出时，只输出第二行的内容
        例子：sed -n "1,2=;1,2p" test | sed 'N;s/\n/:/'
        使用 sed = 文件名，可打印出行号及该行的内容，
        语法分析：等同于 sed "=" 文件名
        但这种方法有个问题：行号和该行内容不在同一行
        解决办法：
        用sed的N命令，一次读取两行（行号，内容）到缓冲区
        然后把回车符号替换成空格或：
        
    保持空间和模式空间
        模式空间
            即为处理文件中一行内容的一个临时缓冲区
            处理完一行之后就会把模式空间中的内容打印到标准输出，然后自动清空缓存。
        保持空间
            是sed中的另外一个缓冲区，此缓冲区正如其名，不会自动清空，
            但也不会主动把此缓冲区中的内容打印到标准输出中。   
        可用如下sed命令，处理这两个空间中的内容：     
            d        删除模式空间的内容，开始下一个循环.
            h        模式空间   ===覆盖==>  保持空间
            H        模式空间   ===追加==>  保持空间
            g        保持空间   ===覆盖==>  模式空间
            G        保持空间   ===追加==>  模式空间
            x        模式空间   <==交换==>  保持空间
        下面以一个例子来说明上面命令的用法，
        例如有一个文件，我们可以用tac命令按行反序打印出文件的内容，
        其实用sed的话也可以实现  :  
        sed '1!G;h;$!d' file        //
        命令说明：
            1!G表明第一行不执行G命令，亦即不把第一行的内容从保持空间追加到模式空间
            h 表每一行都会把模式空间的内容覆盖拷贝到保持缓冲区
            $!d表最后一行不删除，其它行都删除（模式空间的内容）
        上面命令的处理流程：
            假设文件有3行 : aaa\nbbb\nccc
            读第一行：
                模式空间读到第一行aaa\n后，
                因为是第1行，所以1!G不会保持空间的内容覆盖模式空间的内容
                （因为这时保持空间中的内容是空的，覆盖将导致模式空间中读到的内容丢失）
                然后h命令把模式空间中的内容（第一行内容）覆盖拷贝到保持空间中
                于是保持空间中有了第一行的内容aaa\n
                然后因为这不是最后一行，所以$!d命令会把模式空间中的内容清空
                因为此时模式空间中的内容空了，所以这行处理完后，不会在屏幕上有输出
            读第二行：
                模式空间读到bbb后，
                1!G命令先把保持空间中的内容aaa追加到模式空间
                这时模式空间中的内容是bbb\naaa\n
                然后h命令把该模式空间中的内容覆盖拷贝到保持空间
                于是，保持空间中的内容变为了bbb\naaa\n
                然后$!d命令把模式空间清空
                因为此时模式空间中的内容空了，所以这行处理完后，不会在屏幕上有输出
            读第三行：
                模式空间读到ccc\n后，
                1!G命令先把保持空间中的内容bbb\naaa\n追加拷贝到模式空间
                所以这时模式空间中的内容变为ccc\nbbb\naaa\n
                然后h命令把这三行的内容覆盖拷贝到保持空间
                因为这是最后一行了，所以$!d命令不会清空模式空间的内容
                当这行处理完后，sed会先把模式空间中的内容输出的屏幕后再自动清空模式空间
                所以打印出来的是：ccc\nbbb\naaa\n
                
                
