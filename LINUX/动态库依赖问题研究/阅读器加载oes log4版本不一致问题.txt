相关测试文件参test2

方式1： 阅读器链接log1的静态库，oes链接log2的静态库，阅读器显式调用oes
表现：  oes和阅读器分别成功调用到自己预期的log函数

---------------------------------------------

方式3： 阅读器链接log1静态库，oes隐式调用log2共享库，阅读器显式调用oes共享库
表现：  oes和阅读器分别成功调用到自己预期的log函数

=============================================

方式2： 阅读器隐式调用log1共享库，oes隐式调用log2共享库，阅读器显式调用oes共享库
表现：  oes调用的是阅读器加载的log1共享库，
        nm liboes.so ：U _Z3verv、U _Z6setveri  

---------------------------------------------

方式4： 阅读器隐式调用log1共享库，oes链接log2静态库，阅读器显式调用oes共享库
表现：  oes调用的是阅读器加载的log1共享库，
        nm liboes.so ：T _Z3verv、T _Z6setveri  

---------------------------------------------

总结：  当阅读器链接的时log1的静态库，则oes不管是链接静态库log2，还是隐式链接共享库log2，最终都是各自调用各自的日志函数
        当阅读器隐式链接了log1共享库，则oes不管是链接静态库log2，还是隐式链接共享库log2，最终都是调用log1的日志函数

分析：
	经测试发现，只要带-shared选项，则oes不管是链接静态的log2库，还是隐式链接log2共享库，甚至直接链接log2.cpp源文件，
	使用readelf -r工具发现，未决符号表中始终有log2中的符号，
	这表明，如果编译选项带-shared，则不对符号表进行分析处理(这也解释了生成共享库时，允许存在未决符号的原因),
	这与生成可执行时(不带-shared)，是不同的，生成可执行程序会分析处理符号表，确保不存在未决符号
	正是因为如上的原因，所以当阅读器链接log1静态库时，log1中的符号，不会出现在未决符号表中，
	而是在链接阶段，经过对符号表的综合分析后，对log1中所有符号(包括函数和变量)都替换成了真实地址，
	所以oes使用的未决符号表中关于log库的符号，是自带的log2中的符号。
	而当阅读器隐式链接log1共享库时，log1的符号会出现在未决符号表中，
	所以在阅读器运行时，先加载log1，将未决符号表中log相关的符号，替换成log1库中相关符号的地址，
	oes后被加载，它使用的log2的未决符号，但因为log1与log2存在同样的符号，
	所以当log符号替换成log1库中符号的地址后，就不会再替换为log2库中的符号地址了，所以最终调用到了log1中的函数
延伸：
	如果阅读器因为某种原因，无法链接静态库log1，而只能链接log1共享库，如没有log1的源码，
	这种情况下，如果做到仍然和阅读器和oes各调各的log库呢？
    方法一：用显式加载动态库的方法
        dlopen("./libA.so", RTLD_LAZY | RTLD_DEEPBIND))
        RTLD_DEEPBIND选项可以设定dlopen载入的库首先从自己和它的依赖库中查找符号，然后再去全局符号中去查找。
        同时，加载的动态库的变量，如果与宿主程序中存在同名的变量，则会创建该变量的副本，并使用该变量副本。
        经实测，这种方法可以达到期望的目的。
    方法二：__attribute__((visibility("hidden")))
        变量和函数前面都可以带此修饰符，函数只需在声明处添加此修饰符即可，无需在定义处添加
        如上面的oes.cpp在引用log2的时候，在声明log2中的函数时，加上__attribute__((visibility("hidden")))
        "并且链接log2的静态库（使用上面的方式4，无法像方式2一样隐式链接log2的共享库，会报错找不到符号）"
        即可确保oes调用的时log2中的函数：就如同log2函数写在oes.cpp本文件中一样，
        对符号的引用会被直接替换成真实地址，不会出现在oes的未决符号表中。
        使用 nm -D liboes.so ，可以看到只有 runoes, 没有 ver、setver
        但这种方式有一定的局限性，即需要有log2的静态库才行。
    方法三： -fvisibility=hidden
        gcc 使用这个选项时，相当于所有的符号都标记为这个，除非在代码中被覆盖
        但这仅限于当前被编译的代码，即如上例中build4.sh，编译oes时，加上 -fvisibility=hidden 选项，
        则只有 oes.cpp 中的函数默认带有 hidden 特性，而其链接的 log2.a 静态库中的函数默认仍是可见的，
        此时，nm -D liboes.so，发现 runoes 方法没有了：默认不可见，要可先，需带__attribute__((visibility("default")))
        而 ver、setver符号仍存在：说明 -fvisibility=hidden 对链接的静态库不起作用
        进一步测试发现 gcc -c log2.cpp 时，-fvisibility=hidden 选项对生成的 .o 库有影响(.o文件二进制比较结果不同)，
        证明了 -fvisibility=hidden 这个是个编译控制项，而不是链接控制项，
        这解释了 -fvisibility=hidden 对链接的静态库不起作用的原因。
        所以这种方式不可行
        
    
    
    
