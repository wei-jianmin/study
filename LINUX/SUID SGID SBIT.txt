通常看到的文件属性是类似这样的： -rwsr-xr-x
但如果查看/bin/su、/bin/passwd这样的文件，看到的是这样的： -rwsr-xr-x
这里的s表示这个文件同时设置了 SUID， 并且该文件（对其拥有者）是可执行的。
这里的s开可能是大小的S，表示虽设置了SUID，但该文件（对其拥有者）是不可执行的。
s不光可能出现了文件拥有者的x位置，还可能出现在组的x位置，同样有大小写s之分，
不过对应的是文件的SGID位被设置

其实在unix中 ，文件权限是用12个二进制位（0~11）来记录的：
12   11   10   9   8   7   6   5   4   3   2   1   0
T    S    G    B   r   w   x   r   w   x   r   w   x
     4    2    1 | 4   2   1 | 4   2   1 | 4   2   1
     -----------   ---------   ---------   ---------
chmod    [7]           7           7           7      

chmod u+s filename # 设置SUID位
chmod u-s filename # 去掉SUID设置
chmod g+s filename # 设置SGID位
chmod g-s filename # 去掉SGID设置
chmod a+s filename # 设置SUID和SGID位

如果用16bit来表示文件的类型+文件的权限，则权限标记占了12位，
还有4位来表示文件的类型，工可表示16种文件类型，
而我们常见的文件类型只有7种：
普通文件、目录、块设备、字符设备、套接字、管道、链接

一版情况下，用户执行一个可执行文件时，该用户的有效ID会传给可执行程序，
当可执行程序访问文件时，也是以传入的用户有效ID的身份去访问，
但通过给可执行文件设置SUID和SGID，则可以让可执行程序以当前程序拥有者的UID和GID去访问文件
举例:
    一个拥有者和所属组均为root的可执行文件a.bin，
    该执行文件的功能是访问当前目录下的root.txt文件，
    设置root.txt的权限为600，意味着只有root身份才能读写该文件，
    此时用user身份执行a.bin， 提示打开文件失败，
    这是因为user没有对root.txt的读写权限，
    所以他执行a.bin时，此时a.bin也相应的没有对root.txt的读写权限，
    现在切到root，并 chmod a+s a.bin， 再切回user，
    此时执行a.bin， 可以发现可以对root.txt进行读写了，
    这是因为此时的a.bin，是以a.bin的拥有者（root）的身份去访问的。
对一个文件的移动(mv)不会修改其SUID和SGID，但对一个文件的复制(cp)，不会复制其SUID和SGID，
这在一定程度上限制了为程序设置的SUID和SGID，只会在本机上有效（即使其副本在本机上也无效）。
这是出于安全原因考虑的，假设我在A电脑上写了个修改/etc/passwd的程序，使其拥有者为root，
并设置了SUID，假设我能以普通用户的身份将该程序拷贝到B电脑，且有SUID，
就意味着我能在不知道管理员密码的情况下，修改/etc/passwd文件，显然这是非常危险的漏洞。
注意，对脚本文件设置SUID是无意义的，因为脚本文件的本质是个文件文件，
真正的可执行文件是那个脚本解释程序，如/bin/bash

当用户访问文件时，系统根据当前用户的“有效id”（EUID、EGID，可用whoami或id命令查看），
判断当前用户对该文件来说，是拥有者，还是在所属组中，还是属于其他用户。
然后再以此判断该用户对当前文件的访问权限。

查看文件属性时，除了s标志位，还可能出现t标志位，如 ls -l / | grep tmp
看到tmp文件夹的属性为  drwxrwxrwt , 注意，最后一个是t，而不是常见的x，也不是s
t其实就是对文件夹的SBIT位（sticky bit）的表现，它出现在其他用户权限的执行位上，
它只有修饰一个目录时才有意义。当某一个目录拥有SBIT权限时，则任何一个能够在这个目录下建立文件的用户，
该用户在这个目录下所建立的文件，只有该用户自己和root可以删除，其他用户均不可以。