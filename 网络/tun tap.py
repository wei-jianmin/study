https://zhuanlan.zhihu.com/p/388742230
https://segmentfault.com/a/1190000009249039
    相关资料：file://Linux下数据包的收发过程.py
        linux中网卡驱动实现数据链路层，内核实现网络层、传输层
        所以网卡驱动也是Linux网络协议栈里的一层
    物理网卡收发数据的流程
        物理网卡，它的一端是内核空间的网络协议栈，
        另一端是外界网络，物理网卡就是连接这两者    
        物理网卡需要通过网卡驱动在内核中注册后才能工作
        它在'内核网络协议栈和外界网络之间'传递数据
    为内核添加虚拟设备
        参：https://blog.csdn.net/m0_52391919/article/details/121347212
        如参考页面中给出的例子，可以为添加的设备指定设备名称
        可以设置让设备可以产生哪些事件等
        创建完设备后，我们还要编写驱动，并与我们添加的设备绑定
        设备所能产生的事件、所绑定的驱动程序所完成的功能，决定了该设备的功能
    虚拟网卡设备
        内核也可以直接创建虚拟的网卡，只要为虚拟网卡提供网卡驱动程序，
        使其在内核中可以注册成为网卡设备，它就可以工作
        相比于物理网卡负责内核网络协议栈和外界网络之间的数据传输，
        虚拟网卡的两端则是内核网络协议栈和用户空间
        它负责在内核网络协议栈和用户空间的程序之间传递数据
        发送到虚拟网卡的数据来自于用户空间，然后被内核读取到网络协议栈中；
        内核写入虚拟网卡，准备通过该网卡发送的数据，目的地是用户空间
        图：file://imgs/虚拟网卡与物理网卡的位置.jpg
    虚拟网卡和物理网卡的对比
        物理网卡和虚拟网卡唯一的不同点在于，
        物理网卡本身的硬件功能：物理网卡以比特流的方式传输数据
        也就是说，内核会公平对待物理网卡和虚拟网卡，物理网卡能做的配置，虚拟网卡也能做。
        比如可以为虚拟网卡接口配置IP地址、设置子网掩码，可以将虚拟网卡接入网桥等等
        虽然虚拟网卡无法将数据传输到外界网络，
        但却可以将数据传输到本机的另一个网卡(虚拟网卡或物理网卡)
        或其它虚拟设备(如虚拟交换机)上；
        可以在用户空间运行一个可读写虚拟网卡的程序，
        该程序可将流经虚拟网卡的数据包进行处理，比如OpenVPN 程序
        tcp/ip stack --> tun --> OpenVPN --> tcp/ip stack --> Phyical NIC
        对于一个虚拟网络设备，首先它也归内核的网络设备管理子系统管理，
        对于Linux内核网络设备管理模块来说，虚拟设备和物理设备没有区别，
        都是网络设备，都能配置IP，从网络设备来的数据，都会转发给协议栈，
        协议栈过来的数据，也会交由网络设备发送出去，
        至于是怎么发送出去的，发到哪里去，那是设备驱动的事情，跟Linux内核就没关系了，
        所以说虚拟网络设备的一端也是协议栈，而另一端是什么取决于虚拟网络设备的驱动实现
        +----------------------------------------------------------------+
        |                                                                |
        |  +--------------------+      +--------------------+            |
        |  | User Application A |      | User Application B |<-----+     |
        |  +--------------------+      +--------------------+      |     |
        |               | 1                    | 5                 |     |
        |...............|......................|...................|.....|
        |               ↓                      ↓                   |     |
        |         +----------+           +----------+              |     |
        |         | socket A |           | socket B |              |     |
        |         +----------+           +----------+              |     |
        |                 | 2               | 6                    |     |
        |.................|.................|......................|.....|
        |                 ↓                 ↓                      |     |
        |             +------------------------+                 4 |     |
        |             | Newwork Protocol Stack |                   |     |
        |             +------------------------+                   |     |
        |                | 7                 | 3                   |     |
        |................|...................|.....................|.....|
        |                ↓                   ↓                     |     |
        |        +----------------+    +----------------+          |     |
        |        |      eth0      |    |      tun0      |          |     |
        |        +----------------+    +----------------+          |     |
        |    10.32.0.11  |                   |   192.168.3.11      |     |
        |                | 8                 +---------------------+     |
        |                |                                               |
        +----------------|-----------------------------------------------+
                         ↓
                 Physical Network
        tun0是一个Tun/Tap虚拟设备，从上图中可以看出它和物理设备eth0的差别，
        它们的一端虽然都连着协议栈，但另一端不一样，
        eth0的另一端是物理网络，这个物理网络可能就是一个交换机，
        而tun0的另一端是一个用户层的程序，
        协议栈发给tun0的数据包能被这个应用程序读取到，
        并且应用程序能直接向tun0写数据。
    TUN与TAP的区别
        tun是OpenVPN创建的一个三层虚拟网卡，tun设备在用户空间和内核空间之间传递数据
        图：file://imgs/tun tap对比.jpg
        用户层程序通过tun设备只能读写IP数据包，而通过tap设备能读写链路层数据包
        file://tun tap.cpp
        上面cpp文件中的关键代码为：
            int fd = open(clonedev, O_RDWR);
            struct ifreq ifr;
            memset(&ifr, 0, sizeof(ifr));
            ifr.ifr_flags = IFF_TUN | IFF_NO_PI;
            ioctl(fd, TUNSETIFF, (void *) &ifr);
            while (1) int nread = read(tun_fd, buffer, sizeof(buffer));
        将这个文件编译成.out文件执行
        会在终端输出：Open tun/tap device: tun0 for reading...
        再新终端执行该.out文件，终端会输出：Open tun/tap device: tun1 for reading...
        用ipconfig -a 查看（如果不加-a，只会显示已打开的网络设备）
        可以看到有tun0、tun1设备，但这时的设备还是未配置ip的
        通过命令 sudo ip addr add 192.168.3.11/24 dev tun0 ，可为tun0配置ip
        使用命令 sudo ip link set tun0 up ，将设备启动起来
        然后 ping 192.168.3.23 （只要是3网段的都行，本机ip为4网段），
        tun0的.out终端会输出： Read 84 bytes from tun/tap device
        因为我们的代码中收到ping的数据包后没有回复（只是显示了下数据长度后就丢弃了）
        所以 ping 是不通的
        另外，这里创建出来的 tun0、tun1设备，都是临时创建的，
        如果终止 .out 程序，则对应的 tun0/tun1 用 ipconfig -a 命令就看不到了
        如果要创建永久的（重启后是否还存在？），可用如下命令：
            ip tuntap add dev tap0 mod tap # 创建 tap 
            ip tuntap add dev tun0 mod tun # 创建 tun
            ip tuntap del dev tap0 mod tap # 删除 tap 
            ip tuntap del dev tun0 mod tun # 删除 tun
    TUN 典型使用场景
        典型使用场景为 IP 隧道
        举个例子，应用程序发送的数据，路由到 tun0，OpenVPN TUN 从接口 tun0 接收，
        先进行加密处理，再发给物理网卡 eth0 发出去。
        对端的 OpenVPN 客户端从物理网卡 eth0 收到加密数据，
        通过 OpenVPN 进行解密处理之后，再经由 tun0 将数据转发到应用程序。
        图：file://imgs/tun被openvpn使用的方式.jpg
    TAP 典型使用场景
        TAP 接口的典型应用场景是在虚拟化网络中
        例如，我们通过KVM创建的多个 VM（虚拟机）,以 LinuxBridge（桥接模式）互通；
        实际上即是通过像 vnet0（tap设备）这样的 TAP 接口来接入 LinuxBridge 的。
        vnet0 设备被分配给虚拟机系统，作为网卡设备。
        在这种场景下，KVM程序 就是向 TAP 接口读写数据的用户空间程序
        当 VM0 向本机的 eth0 接口发送数据，
        KVM 会将数据发送到 TAP 接口 vnet0 ，
        再通过 LinuxBridge 将数据转发到 vnet1 上。
        然后，KVM 将数据发送到 VM1 的 eth0 口。
        
https://www.jianshu.com/p/09f9375b7fa7
TAP 设备与 TUN 设备工作方式完全相同，区别在于：
    TUN 设备是一个三层设备，它只模拟到了 IP 层，即网络层 
    我们可以通过 /dev/tunX 文件收发 IP 层数据包，它无法与物理网卡做 bridge，
    但是可以通过三层交换（如 ip_forward）与物理网卡连通。
    可以使用ifconfig之类的命令给该设备设定 IP 地址。
    TAP 设备是一个二层设备，它比 TUN 更加深入，
    通过 /dev/tapX 文件可以收发 MAC 层数据包，即数据链路层，
    拥有 MAC 层功能，可以与物理网卡做 bridge，支持 MAC 层广播。
    同样的，我们也可以通过ifconfig之类的命令给该设备设定 IP 地址，
    你如果愿意，我们可以给它设定 MAC 地址。
