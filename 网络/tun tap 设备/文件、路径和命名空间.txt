https://learn.microsoft.com/en-us/windows/win32/fileio/naming-a-file

文件和文件夹名
    所有的系统遵循相同的“一般文件名转换”：一个基本名和一个可选的扩展名
    然而，像如NTFS，FAT、exFAT、FAT32等，也可能有不同的文件名规则，
    注意，一个路径，仅仅是个一个带有特定属性的文件，表明其是个文件夹
    
命名约定
    以下基本规则使应用程序能够创建和处理文件和目录的有效名称，而不考虑文件系统：
    ● 用.将文件名和扩展名分隔
    ● 用\分隔路径的不同部分
    ● 根据需要使用反斜杠作为卷名的一部分，
      例如"C:\path\file"中的"C:\"，或"\\server\share\path\file"中的"\\server\share" 
    ● 不假定区分大小写
    ● 卷标不区分大小写，如 D:\ 等同于 d:\
    ● 名字中不能出现以下特殊字符： <,>,:,",/,\,|,?,*
    ● . 表当前目录
    ● .. 表上级目录
    ● 不要使用以下保留名称：
      CON、PRN、AUX、NUL、COM0~COM9、LPT0~LPT9
    ● 不要用空格或句点结束文件或目录名称，
      尽管基础文件系统可能支持此类名称，但 Windows shell 和用户界面不支持。
      但是，可以接受指定句点作为名称的第一个字符。 例如“.temp”。

绝对路径与相对路径
    对于操作文件的 Windows API 函数，文件名通常可以相对于当前目录，尽管某些 API 需要完全限定的路径。 
    如果文件名不以下列项之一开头，则文件名是相对于当前目录的：
    ● UNC名字，以两个反斜杠开始，如上面的 "\\server\share\path\file"
    ● 盘符+反斜杠，如 "C:\" 或 "d:\"
    ● 单个的反斜杠，如 "\directory" 或 "\file.txt"，这也是一个绝对路径
    如果文件名只以盘符名开始，后面不加反斜杠，则它代表一个在指定盘上的相对路径
    （注：每个磁盘维护一个相对路径，在命令行中切换盘符时，会注意到这种情况）

命名空间
    在系统api中，主要使用两种命名空间转换规则：NT命名空间和win32命名空间
    NT命名空间被设计为最底层的命名空间，其它子系统和命名空间都是基于它的，
    包括Win32子系统和win32命名空间、POSIX子系统和POSIX命名空间等
    早期版本的Windows还为某些特殊设备(如通信(串行和并行)端口和默认显示控制台)
    定义了几个预定义的或保留的名称，作为现在称为NT设备名称空间的一部分，
    并且在当前版本的Windows中仍然支持向后兼容
    
win32命名空间   
    win32文件命名空间
        请注意，这些示例旨在与 Windows API 函数一起使用，
        并不一定都适用于 Windows shell 应用程序，例如 Windows 资源管理器。
        对于文件 I/O，路径字符串的“\\?\”前缀会告知 Windows API 禁用所有字符串分析，
        并将其后面的字符串直接发送到文件系统
        例如，如果文件系统支持大型路径和文件名，
        则可以强制以超过 Windows API MAX_PATH 限制的方式执行
        应该注意到，不是所有的api都支持"\\?\"方式的路径
    win32设备命名空间
        “\.\”前缀将直接访问 Win32 设备命名空间，而不是win32文件命名空间（如果 API 支持这种类型的访问）
        您可以通过这种方式访问磁盘以外的许多设备（例如使用 CreateFile 和 DefineDosDevice 方法）
        例如，如果要打开系统的串行通信端口 1，可以在 调用 CreateFile 函数时使用“COM1”
        这样做是因为 COM1-COM9 是 NT 命名空间中保留名称的一部分，
        尽管使用“\\.\”前缀也适用于这些设备名称
        如果安装了 100 端口串行扩展板，并且想要打开 COM56，
        则无法使用“COM56”打开它，因为 COM56 没有预定义的 NT 命名空间。 
        需要使用“\\.\COM56”打开它，因为“\\.\”直接转到设备命名空间，而无需尝试查找预定义
        另一个使用win32设备命名空间的例子是使用"\\.\PhysicalDriveX" 或 "\\.\CdRomX"
        （ 给CreateFile使用，X代表一个数字），这样，你可以绕过文件系统直接访问这些设备
        这之所以有效，是因为这些设备名称是由系统在枚举这些设备时创建的，
        并且某些驱动程序还会在系统中创建其他别名，
        例如，实现别名“C：\”的设备驱动程序有自己的命名空间，恰好也是文件系统。
        大多数 API 不支持“\\.\”;只有那些设计为使用设备命名空间的api才能识别它
NT 命名空间
    也有一些API允许使用NT命名空间约定，但Windows Object Manager使得这一点在多数情形下变得不必要
    可以使用 winobj 工具浏览 windows 命名空间 ， 当你打开这个工具，你会看到 NT 命名空间（以root或\开始）
    "Global??"子文件对应win32命名空间， "Device"子文件夹对应命名的设备对象
    在"Device"子文件夹下
        还可以找到 Serial0 和 Serial1，这些设备对象表示系统存在的前两个 COM 端口。 
        表示卷的设备对象类似于“HarddiskVolume1”，尽管数字后缀可能会有所不同。   
        子目录“Harddisk0”下的名称“DR0”是表示磁盘设备对象的一个示例。
    为了是这些设备对象可以被windows应用可访问，这些设备驱动在"Global??"（win32命名空间）下创建符号链接
    例如，"Global??"下的COM0和COM1指向Serial0和Serial1（"Device"子文件夹下）
    "C:" 是个指向HarddiskVolume1的符号链接， "Physicaldrive0"是个指向DR0的符号链接，等等
    如果不用符号链接，使用win32命名空间转换的api将不可用
    然而，可以使用支持NT命名空间的api（使用绝对路径格式 "\Device\xxx"）打开设备。
    随着通过终端服务和虚拟机添加多用户支持，在Win32命名空间中虚拟化系统范围的根设备变得更加必要
    这是通过将名为“GLOBALROOT”的符号链接添加到Win32命名空间来实现的，
    您可以在前面讨论的WinObj浏览器工具的“Global？？”子目录中看到该名称空间，
    并可以通过路径“\\?\GLOBALROOT.”访问该名称空间。
    此前缀确保其后面的路径看起来是系统对象管理器的真正根路径，而不是依赖于会话的路径。
    
    