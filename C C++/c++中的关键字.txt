static register const volatile explicit restrict mutable

static:
静态全局变量不能被其它文件所用, 其它文件中可以定义相同名字的变量，不会发生冲突；
在函数的返回类型前加上static关键字,函数即被定义为静态函数。静态函数与普通函数不同，它只能在声明它的文件当中可见，不能被其它文件使用。
静态数据成员主要用在各个对象都有相同的某项属性的时候。
静态函数成员：只需在函数声明处添加，不在实现出添加（在实现处添加相当于只在本文件内可见）

register：
告诉编译器，最好把该关键字修饰的变量放在寄存器内
被register修饰的变量必须是CPU能够接受的类型，因为有的机器识别不了浮点型，所以register变量的长度应该小于等于整形，但现在有的机器是可以使用浮点型的register变量的。
在C语言中，一旦声明为寄存器变量，由于可能会保存到寄存器中，编译器是不允许对其取地址（&）的。
只有局部自动变量和形参可以是寄存器变量，比如在C语言中，全局变量是不能用register修饰的，并且局部静态变量也不能用register修饰
register变量的个数是有限的，因为一个CPU只有那么多个寄存器，并且类型也会受到CPU的限制，并且某些寄存器只能接受特定的类型，如指针类型
是否真正的存储的寄存器由编译器自己决定
c++中，register 关键字在局部作用域中声明时，可以用 & 操作符取地址，一旦使用了取地址操作符，被定义的变量会强制存放在内存中

const：
const int *p ， 指常针，*p不能变
int * const p , 常指针，p的指向不能变
const 修饰自定义类型，作为函数返回值，此时返回的值不能作为左值使用，既不能被赋值，也不能被修改。
const 修饰类成员函数，加在函数声明的后面，定义处不加，其目的是防止成员函数修改被调用对象的值，所以const 关键字不能与 static 关键字同时使用，因为 static 关键字修饰静态成员函数，静态成员函数不含有 this 指针，即不能实例化，const 成员函数必须具体到某一实例。如果某个成员变量被mutable关键字修改，则其在const函数中可以被修改。

explicited：
explicit 关键字作用于单个参数的构造函数。explicit关键字用来修饰类的构造函数，被修饰的构造函数的类，不能发生相应的隐式类型转换，只能以显示的方式进行类型转换。
如果单参的构造函数有explicited修饰符，而又没重载=运算符，则不能用一个对象给另一个对象赋值
 
restrict：
所有修改该指针所指向内存中内容的操作都必须通过该指针来修改,而不能通过其它途径(其它变量或指针)来修改
这样做的好处是,能帮助编译器进行更好的优化代码,生成更有效率的汇编代码.如 int *restrict ptr, ptr 指向的内存单元只能被 ptr 访问到，任何同样指向这个内存单元的其他指针都是未定义的，直白点就是无效指针 
这个关键字只能在C99标准的C程序里使用，C++程序不支持

mutable:
mutable 是用来修饰一个 const 示例的部分可变的数据成员的
一个对象被修饰为const，或使用const成员函数时，仍可修改mutable修饰的成员变量。

