c++基础
    运算符重载方面
    构造和析构函数为私有？虚函数？
    new的几种形式
    寄存器变量类型 
    volatile
        每次访问时都必须从内存中取出值
        没有被 volatile 修饰的变量，可能由于编译器的优化，从 CPU 寄存器中取值
    extern "C" 的作用
        让 C++ 编译器将 extern "C" 声明的代码当作 C 语言代码处理，
        可以避免 C++ 因符号修饰导致代码不能和C语言库中的符号进行链接的问题。
    大小端存储
    delete this 合法吗？
        Is it legal (and moral) for a member function to say delete this?
        合法，但：
        必须保证 this 对象是通过 new（不是 new[]、不是 placement new、不是栈上、不是全局、不是其他对象成员）分配的
        必须保证调用 delete this 的成员函数是最后一个调用 this 的成员函数
        必须保证成员函数的 delete this 后面没有调用 this 了
        必须保证 delete this 后没有人使用了
    如何定义一个只能在堆上（栈上）生成对象的类？
        只能在堆上
            方法：将析构函数设置为私有
            原因：C++ 是静态绑定语言，编译器管理栈上对象的生命周期，
            编译器在为类对象分配栈空间时，会先检查类的析构函数的访问性。
            若析构函数不可访问，则不能在栈上创建对象。
        只能在栈上
            方法：将 new 和 delete 重载为私有
            原因：在堆上生成对象，使用 new 关键词操作，其过程分为两阶段：
            第一阶段，使用 new 在堆上寻找可用内存，分配给对象；
            第二阶段，调用构造函数生成对象。
            将 new 操作设置为私有，那么第一阶段就无法完成，就不能够在堆上生成对象

linux知识
    界面与内核的关系
    常用指令
    磁盘格式结构
        
        
