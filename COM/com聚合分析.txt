假设A中实现了IA1，IA2，IA3，Ix四个自定义接口
B中实现了IB1，IB2，IB3，Ix四个自定义接口
现在，B要聚合使用A，并打算将A的IA1和IA2接口暴漏出来

考虑A的实现
A在构造函数中添加外部IUnknown接口参数，通过此参数判断是否被聚合使用
如果被聚合使用，则保存下外部传来的IUnknown接口指针
QueryInterface： 
法1：
当请求IUnknown接口时，如果外部IUnknown接口不为空，返回外部IUnknown的接口
否则，返回自己的IUnknown接口
如果找遍了A中的各个接口，都没有找到，
如果外部容器接口指针不为空
调用外部IUnknown接口的QueryInterface方法
？当从IA1请求Ix接口时，获取的是A中的Ix接口
当从IB1请求Ix接口时，获取的是B中的Ix接口，这种情况怎么避免？

法2：
所有的QueryInterface方法都交由B进行处理
即使调用IA1的QueryInterface方法，也最终转交B进行处理
而B则需要能获取到A的所有接口，并有选择的暴漏出必要的接口
这要求A中的IA1、IA2、IA3、Ix接口都继承自该IUnknown接口，
根据这种集成关系也可知，该接口是正宗的IUnknown接口。
所以，还需考虑在A不被聚合使用时的情况，
所以，在上面的基础上进行更改：
如果是A被聚合，则按上面的处理，如果是A被独立使用，没被聚合使用，
则像普通IUnknown接口一样工作。
这样，从IA1请求B中接口的问题就解决了。
？从IB1请求A中接口？
这需要B能访问A中的所有接口，但上面A中的IUnknown接口无法做到了，
所以需要在A中建立另一个IUnknown接口，方法名为了普遍适用性，
所以要与标准IUnknown接口方法名一致。
新建的IUnknown接口，要求一定能请求到A中的所有接口，而不受A被聚合的影响
该接口只是为B能访问A中所有接口而提供的，所以B肯定要获得该接口的指针，
而上面A中的标准IUnknown接口，对B而言，反而没什么用处。
该新建的IUnknown接口，只是被B使用，所以可以称其为聚合用IUnknown接口
（IUnknownForAggregation，简称IUnknown4A）

通过上面的讨论，可见方法2对于接口请求是行得通的，
下面再来探讨下这种方法对于对象的生存期管理的问题。
所谓的生存期管理，说白了，就是通过AddRef和Release方法，管理对象中的引用计数
B聚合使用了A对象，但对于使用B对象的客户来说，当他调用IA1->Release方法时，
其真正的意图只是想增加B对象的引用计数，他甚至不知道有A对象的存在，
A对象的生存期管理只能有B进行控制，
按上面的做法，IA1的Release方法，实际是其标准IUnknown接口中的Release方法，
而该方法内部判断是聚合情况，所以调用的是容器对象B的Release方法，
AddRef方法同样如此，所以，在这种方式下，用户控制的是B对象引用计数，
这是我们需要的
B只需在创建A的时候增加对A的引用计数，B对象释放的时候，减少对A的引用计数，
这可以通过B拥有的A的IUnknown4A接口来实现这一目的
