● 名字对象有什么用？
        名字对象为组件对象提供了符号化的表示方法，同时它也对组件对象进行了全面的封装，客户程序只需创建相应的名字对象，然后利用名字对象的绑定功能得到组件对象。
        名字对象能够自动使组件对象从被动状态进入运行状态，所以名字对象也称为永久智能名字。
        名字对象封装了组件对象的所有状态处理过程，因此客户程序可以按照统一的方法处理名字对象，即使要引用新的组件对象，客户代码也不必作任何改动。

● 名字对象的绑定过程
       名字对象实现了标准的COM接口IMoniker，客户程序通过IMoniker接口获得（与名字对象关联的）组件对象。
       客户程序通过名字对象访问组件对象可以分成两步：第一，获得名字对象；第二，执行名字对象的绑定操作（使用IMoniker接口的函数BindToObject），绑定过程的结果就是组件对象的接口指针。
       客户程序获得名字对象的途径有两条：第一，调用COM API函数，如MkParseDisplayName和CreateFileMoniker；第二，其他对象的接口成员函数传递过来，或者通过其他的数据传输机制得到，比如通过剪贴板或拖－放操作等。

● IMoniker接口方法
（1）       名字管理函数：IsEqual、Hash、IsRunning、GetTimeOfLastChange。
（2）       绑定函数：BindToObject、BindToStorage。
（3）       复合名字对象管理函数：Reduce、ComposeWith、Enum、Inverse、CommonPrefixWith、RelativePathTo、IsSystemMoniker。
（4）       名字解析函数：GetDisplayName、MkParseDisplayName。

● ROT表与绑定环境对象
        COM使用运行对象表（ROT，running object table）表管理当前系统中正在运行的、已经被注册的名字对象，客户程序可调用COM API函数GetRunningObjectTable得到ROT表的IRunningObjectTable接口指针。
        IMoniker接口的大多数成员函数以及其他一些API函数都包含一个被称为绑定环境的对象，在这些函数中，以IBindCtx接口指针的形式出现。绑定环境对象主要用于名字对象的整个绑定过程，所以它包含了绑定过程所需要的一些信息。由于绑定环境对象是COM实现的系统对象，所以COM提供了一个API函数创建它：CreateBindCtx。绑定过程比较耗时，所以绑定环境对象提供了最终时间限制参数。
        绑定环境对象在复合名字对象的绑定过程中有很重要的意义，一方面，通过它，绑定过程中可以取得ROT表；另一方面，通过对绑定参数的设置可以控制绑定过程的一些行为；而且利用绑定环境对象内部的对象参数可以传递对象信息。

● COM名字对象分类
       文件名字对象、复合名字对象、单项名字对象、反-名字对象、指针名字对象、类名字对象、URL名字对象。
       名字对象细分为不同的类型，是因为不同名字对象所关联组件的创建方式存在不同。如文件名字对象需要设计路径的解析，而其它名字对象则不需要。因此，创建不同类型的名字对象，除了所有的API不同外，函数的参数也各不相同。
       文件名字对象和复合名字对象以及单项名字对象是最常被使用的名字对象，它们联合起来几乎可以实现绝大多数应用的对象命名和绑定过程。而反-名字对象和指针名字对象主要用于COM系统内部。

○ COM名字对象分类DD文件名字对象（file moniker）
       文件名字对象可以用来指定任何存储在独立文件中的对象，可以把它与文件系统中赋予文件的路径名字结合起来，文件名字对象实现了从文件路径名到代表文件的文档对象的联系过程。

○ COM名字对象分类DD单项名字对象（item moniker）
       单项名字对象用来标识一个被包含在其他对象中的对象，包含它的那个对象被称为容器对象，对象所使用的名字空间由容器对象决定。
       单项名字对象单独存在并没有实际意义，只有当它与其他的名字对象组合之后才真正有用。最经常的用法是，在创建了单项名字对象之后，把它与一个文件名字对象组合起来形成复合名字对象，此复合名字对象给出了对象的全路径名。它与文件名字对象的结合可以描述文件内部的所有对象。
       由于文件名字对象使用了公用的名字空间，所以所有的应用程序都可以理解文件名；而单项名字对象则使用了私有的名字空间，只有容器对象才能理解单项名字对象，一个容器对象不能理解属于另一个容器对象的名字对象。因此，单项名字对象所指对象的容器对象必须实现IOleItemContainer接口，文件名字对象对应的组件对象还必须实现IPersistFile接口，这是文件名字对象的IMoniker::BindToObject接口成员函数所要求的。IOleItemContainer接口把容器对象与下属的对象联系起来，把单项名字对象绑定到实际的对象。
       单项名字对象可以用COM提供的API函数CreateItemMoniker创建。

○ COM名字对象分类DD复合名字对象（composite moniker）
       复合名字对象充分体现了COM命名和绑定机制的优势，它使多个名字对象可以连接或组合在一起形成新的名字对象。由于不同类型的名字对象有可能被组合到一起，因此复合名字对象提供了连接不同名字对象空间的能力。操作系统为文件系统提供了一个公用的名字空间作为文件命名空间，因此所有的应用都按同样的方式理解文件名。类似地，每一个容器对象为它的所属对象都定义了其私有的名字空间。
       COM把名字对象的组合方式分为通用和特定两种。
        复合名字对象由一组其他的名字对象组成，也可以包括其他的复合名字对象，复合名字对象提供了一种创建任意复杂名字的机制。      COM提供了一个标准的复合名字对象实现，称为“通用复合名字对象（generic composite moniker）”，并提供了标准API函数创建此类名字对象：CreateGenericComposite。
         IMoniker接口从IPersistStream派生而来，所以名字对象也是一个永久对象，它可以有自己的永久状态。复合名字对象的永久状态是一个流，它顺序保存了每个组成名字对象的永久状态。
       通用复合名字对象按统一的方式处理它的各个成员名字对象，无论是绑定过程还是其他一些操作，如名字解析、名字简化等。      
       
○ COM名字对象分类DD反-名字对象（anti-moniker）
       通常我们在创建自定义名字对象时会用到反-名字对象，我们也可以把反-名字对象用作复合名字对象中的逆名字对象，它可以抵消掉原名字对象的作用，有如“..”在文件系统命令中所起的作用一样。
       反-名字对象可以用COM提供的API函数CreateAntiMoniker创建。
       反-名字对象通常用作简单名字对象的逆名字对象。

○ COM名字对象分类DD指针名字对象（pointer moniker）
       指针名字对象是一个特殊的名字对象，它所指的对象只有运行状态，没有被动状态。指针名字对象只是封装了对象的接口指针。
       指针名字对象内部只管理接口指针，它没有永久状态。
       指针名字对象可以通过调用COM提供的API函数CreatePointerMoniker创建。
 
○ COM名字对象分类DD类名字对象（class moniker）
       类名字对象标识了一个对象类，它内部封装了对象类的标识符CLSID。虽然我们可以通过CoCreateInstance和CoGetClassObject创建对象，但使用类名字对象不仅可以创建对象，而且它与其他的名字对象组合之后可以形成更为灵活的对象创建或绑定机制。
       类名字对象可以用COM提供的API函数CreateClassMoniker创建。

○ COM名字对象分类DDURL名字对象
       COM给出了异步名字对象的实现模型，它允许客户程序按异步方式执行绑定过程。在绑定进行过程中，客户程序可以得到绑定进度信息，也允许用户取消绑定操作。异步名字对象保持了与同步名字对象的兼容，它也允许绑定过程按同步方式进行。以前介绍的各种名字对象属于同步名字对象，URL名字对象属于异步名字对象。
       异步名字对象与同步名字对象的区别在于，异步名字对象不仅实现了IMoniker接口，它还实现了接口IAsyncMoniker，IAsyncMoniker只继承了IUnknown接口，没有增加新的成员函数，它只作为异步名字对象的标志。COM提供了API函数IsAsyncMoniker，用于判断一个名字对象是否为异步名字对象。
       URL（Uniform Resource Locator，统一资源位置）名字对象，封装了几个标准的Internet协议，包括“http:”、“https:”、“ftp:”和“gopher:”。它的显示名为URL路径名，可以是全路径名，也可以是部分路径名。
       URL名字对象可以利用函数CreateURLMoniker创建。

○ 自定义名字对象
       从结构上讲，自定义名字对象只是一个支持IMoniker接口的进程内COM对象。

● COM名字对象的应用
       作为名字对象的典型应用，OLE复合文档中的链接对象采用了名字对象技术，OLE复合文档应用程序为名字对象客户程序，链接对象为服务程序。
       MFC对OLE的支持很全面，用名字对象实现复合文档与链接对象之间的连接只是很小的一部分。 