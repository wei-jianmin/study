● 记录错误路由：
思路：
要么自身出错返回，要么调用函数出错返回，因此
可以定义一个全局的unsigned long变量routing_error
限定：
每个函数最多能记录15个错误码，0表成功
最多能记录最近16级函数调用
操作：
在函数进入时，首先将routing_error置0
函数出错返回时，如果字符出错，记录自身错误位置码即可，
如果是因调用函数出错，则将被调函数记录的错误码左移4位，
然后再加上自身的错误位置码；
优点：
根据错误位置码，再参照源码，可以以最短的信息长度记录错误路径，
精确定位函数出错位置。
几乎不用记录出错日志，只需在根调用层记录一下routing_error，
就能知道代码出错的路径。
缺点：
1.每个函数最多记录15个出错为位置，限定了函数不能太长
2.因为这种错误码具有自由组合性，因此不能方便的把错误码转为文字可描述信息
3.最低4bit的错误码需要有方法让自己知道是出自哪个函数的
4.如果有中间某个函数出错返回时，没有记录routing_error，将导致线索中断，
  则该条错误值将失去意义。
扩展：
可以用string或Stack<string>代替unsigned long，记录错误路由

---------------------------------------------------------------------
● 记录最后出错信息
有个所有函数都可访问的全局变量last_error，记录/获得出错信息
如果是被调函数返回的错误，则由被调函数给出出错原因，主调函数不修改
如果是自身出错，则自身记录出错位置
*用于向外（用户或库调用者）给出错误信息
函数只在错误返回时，修改/记录last_error，(非根)函数进入时，不能重置last_error=0;
函数成功返回时,推荐将last_error置0，但不做强制性要求
缺陷：
父函数和子函数出错返回时，如果使用了相同的错误码（如参数错误）,则错误描述不清楚，
不知道是在哪里导致的错误，如果使用不同的错误码，则会出现重复描述描述同一类型的错误的问题，
如参数错误；折衷一点的方案是按文件或类进行分级，如参数错误，可以知道是在哪个类或那个文件
中出现的，但这也无法从根本上解决这一问题――可以配置routing_error使用