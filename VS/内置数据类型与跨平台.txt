项目属性-配置属性-c/c++-语言-将wchar_t是为内置类型（默认为是）
该选项影响wchar_t的占用字节数
wchar_t不作为内置类型”编译出来，B库头文件中的wchar_t实际上是unsigned short

MSDN:
如果 /Zc:wchar_t 处于打开状态，wchar_t 将映射到 Microsoft 专用本机类型 __wchar_t。 
如果指定了 /Zc:wchar_t-（带有一个减号），wchar_t 将映射到 unsigned short 的 typedef。 
（在 Visual C++ 6.0 和更早版本中，wchar_t 未作为内置类型实现，
但在 wchar.h 中声明为 unsigned short 的 typedef。
不建议使用 /Zc:wchar_t-，因为 C++ 标准要求 wchar_t 是内置类型。 
使用 typedef 版本可能导致可移植性问题。
如果你从 Visual C++ 的早期版本升级并遇到编译器错误 C2664（因为代码尝试将 wchar_t 隐式转换为 unsigned short），
则建议更改代码来修正错误，而不是设置 /Zc:wchar_t-。
Microsoft 将 wchar_t 作为两位无符号值实现。 有关 wchar_t 的详细信息，请参阅 数据类型范围 和 基本类型。
如果你编写了一个新代码，该代码必须与仍使用 typedef 版本的 wchar_t 的旧代码互操作，则可为 wchar_t 的 unsigned short 和 __wchar_t 变体提供重载，以便让新代码与使用/未使用 /Zc:wchar_t 编译的代码链接。否则，你必须提供两个不同版本的库（一个启用了 /Zc:wchar_t，另一个未启用）。 即使在这种情况下，仍建议你使用用来编译新代码的同一编译器来生成旧代码。 不要将使用不同编译器编译的二进制文件混合。
当指定 /Zc:wchar_t 时，将定义 _WCHAR_T_DEFINED 和 _NATIVE_WCHAR_T_DEFINED 符号。
编译 C 代码时不支持 wchar_t 类型。
在 Visual Studio 开发环境中设置此编译器选项
打开项目的“属性页”对话框。 有关详细信息，请参见使用项目属性。
在左窗格中，展开“配置属性”、“C/C++”，然后选择“语言”。
修改“将 wchar_t 视为内置类型”属性。

wchar_t类型在Windows和Linux平台下的大小是不一样的，
Windows下采用的是2字节编码一个字符，基于utf-16，
Linux下采用的是4个字节编码一个字符，基于utf-32
在这里，我们首先应该明确一点，wchar_t类型在Windows和Linux平台下字节大小的不同，对我们程序本身的跨平台性没有任何影响，你Windows下是怎么处理wchar_t的，那么在Linux下就怎么处理，相应的接口和操作都不用改变。不会对数据的读取产生错误。但是有一点，这些是基于这样一个事实的，就是你没有在两个平台之间对不同平台下产生的文件进行读取。如我目前所做的项目中，在代码实现上，需要把wchar_t类型的一些数据输出到文件保存，然后在后续的代码中进行读写。在不同平台下产生的这个文件，wchar_t字符的编码方式肯定是不一样的，所以不能把Windows下生成的文件，直接拿到Linux下面来进行读写，如果这样做，那么读写错误是肯定会发生的。还有一点，不能贸然的添加gcc 编译项 -fshort-wchar，强制将Linux平台下的wchar_t指定成两个字节，因为这样做，只会改变你在代码中自己实现的部分，而内部库或者是第三方库中用到的接口和函数都是没有变的，仍然采用的是4字节编码。如，std::wstring, QT中的QString等。

-----------------------------------------------------------------

标准类型是标准规范规定的类型，其名字与占用字节数都是确定的
内置类型（或称基本类型）是编译器提供的，不需要包含任何的头文件即可使用，但不同的编译器对内置类型可能有不同的实现
如：string类型是c++标准库定义的，需要包含相应的头文件才能使用
而int、short、wchar_t、bool等数据类型，不需要包含任意头文件即可使用，而这样的内置类型在c++标准中只给出了名字的定义（即不管什么编译器，都得有这个名字的变量类型），但对于占用空间上，c++规范只规定了这些内置类型的最小占用字节数：
类型     	最小尺寸
bool ： 	未定义； （真或者假）
char ： 	8位
wchar_t ： 	16位
char16_t：	16位
char32_t ：	32位
short：		16位
int：		16位
long：		32位
long long：	64位
float：		6位有效数字
double ：	10位有效数字
long double：10位有效数字

除了字符和布尔类型之外哦，其他整型是用来表示不同尺寸的整数的。
C++语言规定：
一个int至少和一个short一样大，一个long至少和一个int一样大，一个long long至少和一个long一样大，其中 longlong是属于C++11中新定义的。
关于浮点数：
浮点数可以表示单精度，双精度和扩展精度值。

C++标准规定：
一个浮点数的有效位数的最小值，但是大多数的编译器都实现了更高的精度。
通常：float以1个字（32比特）来表示，double以2个字（64比特）来表示，
long double用以3或者4个字（96或者128比特）来表示
一般来说float类型和double类型分别有7 和16位有效数字。
long double常常用于有特殊浮点要求的硬件。它的具体实现不同，精度也各不相同。
