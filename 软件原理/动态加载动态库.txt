对于任意一个elf格式文件，不管是可执行文件，还是动态库文件，甚至是目标文件，
都有一个重定位表，记录当前模块未决符号的地址
还有一个导出符号表，记录当前模块导出符号的地址

这里我们关注共享动态库的情况
动态库需要做到位置无关，也就是无论在动态库放到内存的哪个位置，他都可以被正常使用
但动态库中的导出符号表，一旦动态库生成后，就不能随意改变，所以导出符号表中不应该记录函数的绝对地址，因为动态库不能预知加载到哪块内存上
导出符号表中记录的是各个导出符号的相对偏移地址

不同的可执行文件，如a.bin和b.bin，都加载这个动态库时，
这两个可执行文件分别有个全局偏移表（GOT），
加载动态库时，根据动态库的导出符号表，结合动态库的装在位置，对应填充到GOT表中
于是GOT表中就有了动态库中各个导出符号的绝对地址
可执行文件通过查找该GOT表，继而定位到动态库中各个符号的地址

而对于动态库的数据段来说，可以认为每个进程各拥有一个该进程数据段的拷贝
（主要指的是全局变量和静态变量，因为这些符号也是记录在全局偏移表中的，
  所以进程是可以将这些动态库中的全部变量映射到自己的数据区的，
  事实上，这些动态库中的全局变量是在发生修改时，才将存放这个全局变的的内存页进行拷贝）
  可见这是不同于动态库的代码段的共享的特点的，动态库中的变量对于每个进程来说，都可认为是各自拥有的

linux下，
可执行程序可以用extern int a；这样的方式，使用动态库中的int a；全局变量，这是默认的，当然也可以通过编译选项禁止这种行为
同理，动态库也可以用extern int b；这样的方式，使用可执行程序中定义的全局变量，但这不是默认的，而是需要通过编译选项开启这种行为。

