编译单元：
根据C++标准，每一个CPP文件就是一个编译单元。每个编译单元之间是相互独立并且互相不可知。

目标文件：
由编译所生成的文件(.obj)，以机器码的形式包含了编译单元里所有的代码和数据。
还有一些其他信息，如未解决符号表，导出符号表和地址重定向表等。
目标文件是以二进制的形式存在的。

在预编译的时候，.h头文件会被复制、扩展到包含它的.cpp文件里，然后编译器编译该.cpp文件为一个.obj文件，该.cpp文件作为一个编译单元独立编译。
当编译器将一个工程里的所有.cpp文件以分离的方式编译完毕后，再由链接器进行链接成为一个可执行文件。

目标文件至少要提供三个表：未解决符号表，导出符号表和地址重定向表。
未解决符号表：列出了本单元里有引用但是不在本单元定义的符号及其出现的地址。
导出符号表：提供了本编译单元具有定义，并且可以提供给其他编译单元使用的符号及其在本单元中的地址。
地址重定向表：提供了本编译单元所有对自身地址的引用记录。

链接器的工作顺序：
当链接器进行链接的时候，首先决定各个目标文件在最终可执行文件里的位置。然后访问所有目标文件的地址重定义表，对其中记录的地址进行重定向（加上一个偏移量，即该编译单元在可执行文件上的起始地址）。然后遍历所有目标文件的未解决符号表，并且在所有的导出符号表里查找匹配的符号，并在未解决符号表中所记录的位置上填写实现地址。最后把所有的目标文件的内容写在各自的位置上，再作一些其他工作，就生成一个可执行文件。

经典连接错误：
unresolved external link..
这个很显然，是链接器发现一个未解决符号，但是在导出符号表里没有找到对应的项。
解决方案就是在某个编译单元里提供这个符号的定义。（注意，这个符号可以是一个变量，也可以是一个函数），也可以看看是不是有什么该链接的文件没有链接。
duplicated external simbols...
这个则是导出符号表里出现了重复项，因此链接器无法确定应该使用哪一个。这可能是使用了重复的名称，也可能有别的原因。

C/C++针对这些而提供的特性：
extern：告诉编译器，这个符号在别的编译单元里定义，也就是要把这个符号放到未解决符号表里去。（外部链接）
static：如果该关键字位于全局函数或者变量的声明的前面，表明该编译单元不导出这个函数／变量的符号。因此无法在别的编译单元里使用。（内部链接）。如果是static局部变量，则该变量的存储方式和全局变量一样，但是仍然不导出符号。

静态库(.lib)和目标文件的关系(.obj)
静态库是一个或者多个obj文件的打包，所以有人干脆把从obj文件生成lib的过程称为Archive，即合并到一起。比如你链接一个静态库，如果其中有错，它会准确的找到是哪个obj有错，即静态lib只是壳子。
