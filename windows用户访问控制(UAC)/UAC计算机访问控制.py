UAC原理：
    参考：https://blog.csdn.net/superchickenchicken/article/details/102571822
    在Windows Vista操作系统中。
    用户账户主要有两种：标准用户(stand user) 和 管理员用户 (administrator)
    因为当一个标准用户登录到计算机时，Vista将创建一个新的登录会话，
    并通过一个操作系统创建的、与刚刚创建的这个登录会话相关联的shell程序（例如Windows Explorer）作为访问令牌颁发给用户
    -MARK : 上面这句不理解
    而当一个管理员登录到计算机时，Windows Vista的处理方式却与先前版本的Windows有所不同。
    虽然系统创建了一个新的登录会话，但却为该登录会话创建了两个不同的访问令牌，而不是先前版本中的一个。
    第一个访问令牌提供了管理员所有的许可和权限（可暂称为超级令牌），
    而第二个就是所谓的“受限访问令牌”，有时候也叫做“过滤访问令牌（filtered token）"，
    该令牌提供了少得多的许可和权限。
    实际上，受限访问令牌所提供的访问权限和标准用户的令牌没什么区别。
    然后系统将使用该受限访间令牌创建 shell应用程序。
    这也就意味着即使用户是以管理员身份登录的，其默认的运行程序许可和权限仍为标准用户。
    若是该管理员需要执行某些需要额外许可和权限的、并不在受限访间令牌提供权限之内的操作，
    那么他/她可以选择使用非限制访问令牌所提供的安全上下文来运行该应用程序。
    在由受限访问令牌“提升到非限制访间令牌的过程中，
    Windows Vista将通过给管理员提示的方式确认该操作，以其确保计算机系统的安全。
    恶意代码不可能绕过该安全提示并在用户不知不觉中得到对计算机的完整控制。
    ● UAC提权
    进程完整性级别，系统的每个进程有相应的完整性级别标志，与资源的完整性级别相互验证，以提供额外的安全保护。
    用户态进程可以设置如下四种完整性级别： Low / Medium / High / System
    管理员的标准用户模式下（未提升）是(Medium)完整性级别，经过提升后拥有高(High)完整性级别。
    运行于Local System之下的账户拥有(System)完整性级别
    -NOTE：对这段话的理解为，进程有访问角色级别，资源有保护级别，或者说上面的完整性级别应理解为安全级别。
    提权简单流程:
        获取需要查询的进程的访问令牌
        根据令牌获取指定类型信息，得到表示完整性级别的SID
        根据该进程的SID,决定是否需要用户确认，然后进行提权。
        -NOTE : SID应该是SessioniD的意思，几个进程组可以合并成一个会话组，会话组中所有进程都有相同的SID
        当用户允许一次UAC提权时，AIS服务(AppInfo Service)调用的CreateProcessAsUser() 函数创建进程
        并且赋予恰当的管理员权限，在理论上说AIS服务(所在的进程)是提权后那个进程的父进程。
        然而，当我们用一些进程查看管理工具 进行查看时，会发现已经被提权的进程，它的父进程是创建它的进程，
        而不是AIS服务(所在的进程)。这是因为AIS利用了CreateProcessAsUser() API中的一个新的功能，
        这里的新功能就是将要被提权的进程的父进程设置成创建该进程的进程，
        如果我们利用一下该API，就可以把一个进程的父进程设置为任意进程。
    ● 通过msconfig/工具，可以关闭UAC访问控制, 即程序需要超级令牌时，无需弹窗确认即可直接获得。
webisngserver 自启动 UAC 权限提升问题 
    -TODO
用户模式 vs 内核模式
    内核空间存放的是操作系统内核代码和数据，是被所有程序共享的
    在程序中修改内核空间中的数据不仅会影响操作系统本身的稳定性，
    还会影响其他程序，这是非常危险的行为，所以操作系统禁止用户程序直接访问内核空间
    要想访问内核空间，必须借助操作系统提供的 API 函数，执行内核提供的代码，让内核自己来访问，
    这样才能保证内核空间的数据不会被随意修改，才能保证操作系统本身和其他程序的稳定性。
    用户程序调用系统 API 函数称为系统调用（System Call）；
    发生系统调用时会暂停用户程序，转而执行内核代码（内核也是程序），访问内核空间，这称为内核模式（Kernel Mode）。
    用户空间保存的是应用程序的代码和数据，是程序私有的，其他程序一般无法访问。
    当执行应用程序自己的代码时，称为用户模式（User Mode）。
    当运行在用户模式的应用程序需要输入输出、申请内存等比较底层的操作时，
    就必须调用操作系统提供的 API 函数，从而进入内核模式；
    操作完成后，继续执行应用程序的代码，就又回到了用户模式。
    从 Intel 80386 开始，出于安全性和稳定性的考虑，
    CPU 可以运行在 ring0 ~ ring3 四个不同的权限级别，也对数据提供相应的四个保护级别。
    不过 Linux 和 Windows 只利用了其中的两个运行级别：
    ・一个是内核模式，对应 ring0 级，操作系统的核心部分和设备驱动都运行在该模式下。
    ・另一个是用户模式，对应 ring3 级，操作系统的用户接口部分（例如 Windows API）以及所有的用户程序都运行在该级别。
    ● 为什么内核和用户程序要共用地址空间
    既然内核也是一个应用程序，为何不让它拥有独立的4GB地址空间，而是要和用户程序共享、占用有限的内存呢？
    让内核拥有完全独立的地址空间，就是让内核处于一个独立的进程中，这样每次进行系统调用都需要切换进程。
    切换进程的消耗是巨大的，不仅需要寄存器进栈出栈，还会使CPU中的数据缓存失效、MMU中的页表缓存失效，
    这将导致内存的访问在一段时间内相当低效。
    32位x86系统，每个进程的空间是4GB，即地址0x00000000到0xFFFFFFFF。
    为了高效调用，Windows会把操作系统的内核数据和代码映射的系统中所有进程的进程空间中。
    因此4GB空间被划分为两个区域：用户空间和系统空间，默认大小为各2GB。
    ● 模式切换的两种方式：软中断、快速系统调用指令。
    参： https://blog.csdn.net/love514425/article/details/8529148
    1.INT 2E切换到内核模式
    CPU在把执行权交给KiSystemService函数前，需要做一些准备工作：
    (1)权限检查，即检查源和目标位置所在的代码段权限；
    (2)准备内核态使用的栈。所有线程在内核态执行时必须使用内核栈；
    KiSystemService的流程
    (1)根据服务ID从SSDT中查找要调用的服务函数地址和参数；
    (2)将参数从用户态栈复制到该线程的内核栈中；
    (3)KiSystemService调用内核中正在的NtReadFile();
    (4)KiSystemService将操作结果复制回线程用户态栈；
    (5)通过IRET指令将执行权交回给NtDll.dll中的NtReadFile();
    2.快速系统调用
    从WindoXp和Windows Service 2003开始，
    系统在启动过程中会通过CPUID指令检测CPU是否支持快速系统调用指令。
    如果支持这些指令，Windows会决定用新的方式进行系统调用，并做好如下准备工作：
    (1)在GDT中建立4个段描述符，分别用来描述供SYSENTER/SYSEXIT使用的CS和SS；
    (2)设置MSR寄存器，填充SYSENTER/SYSEXIT要跳转的地址等；
    (3)将一小段名为SystemCallStub的代码复制到ShareUserData内存区。该代码调用SYSENTER或SYSCALL进入内核态;
