<catalog s0>
说明：本文（rfc5996）描述了ikev2协议，取代了之前的rfc4306/rfc4718    

参考：
    https://rfc2cn.com/rfc5996.html
    https://blog.csdn.net/PiPiQ_Blog/article/details/121869391
    https://blog.csdn.net/PiPiQ_Blog/article/details/123646843
    
相关知识链接：
    Diffie-Hellman 组解释 ： https://blog.csdn.net/ever_peng/article/details/89205051
        Diffie-Hellman (DH) 组确定了在密钥交换进程中使用的密钥的强度。 --公开的p,q值？
        组的编号越大安全性就越高，但是也就需要更多的时间来计算密钥。
        VPN 交换中的两个对等方必须使用同一 DH 组，该组在 IPSec 协商进程的第 1 阶段协商。
        DH 组 1： 768 位组
        DH 组 2： 1024 位组
        DH 组 5： 1536 位组
        DH 组和 Perfect Forward Secrecy (PFS)
            除了第 1 阶段之外，您还可以在 IPSec 连接的第 2 阶段指定 Diffie-Hellman 组。 
            第 2 阶段配置包括安全性关联 (SA) 设置，也就是数据包在两个端点之间传递时，如何对其加以保护。 
            只有当您选择了 Perfect Forward Secrecy (PFS) 时，您才可以在第 2 阶段指定 Diffie-Hellman 组。
            PFS 会增强密钥的安全性，因为此方法不根据之前的密钥创建新密钥。 
            如果某个密钥泄露，新会话密钥仍是安全的。 
            当您在第 2 阶段指定 PFS 后，每次协商新 SA 时都会出现 Diffie-Hellman 交换。
            您为第 2 阶段选择的 DH 组不一定要与您为第 1 阶段选择的组匹配。
        如何选择 Diffie-Hellman 组
            第 1 阶段和第 2 阶段的默认 DH 组都是 Diffie-Hellman 组 1。 
            该组能够提供基本的安全保护和良好的性能。 
            如果隧道初始化和重新生成密钥的速度不重要，可使用组 2 和组 5。 
            初始化和重新生成密钥的真实速度取决于很多因素。 
            您可以尝试 DH 组 2 或 5 并确定较慢的性能时间是否会对您的网络造成问题。
            如果您不能接受该性能，请改为使用编号较小的 DH 组。
        性能分析
            下表显示了一款生成了 2000 个 Diffie-Hellman 值的软件应用程序的输出。 这些数字适用于 1.7GHz Intel Pentium 4 CPU。
            DH 组	密钥对数量	需要的时间	每个密钥对需要的时间
            组 1	2000	    43 秒	    21 毫秒
            组 2	2000	    84 秒	    42 毫秒
            组 5	2000	    246 秒	    123 毫秒
    file://../密码学/DH算法原理及ssl实现过程.txt
        
1. 介绍
    IP安全（IPsec）为IP数据报提供：机密性、数据完整性、访问控制和数据源身份验证。
    这些服务是通过维护IP数据报的源和接收器之间的'共享状态'来提供的。
    除其他外，该'状态'定义'提供给数据报的特定服务、将使用哪些加密算法提供服务以及用作加密算法输入的密钥'
    以手动方式建立此共享状态无法很好地扩展。因此，需要一个协议来动态地建立这种状态。
    本文档描述了这样一种协议――Internet密钥交换（IKE）
    
    ike完成互验（在对端之间）并确立ike sa （包含共享秘钥信息（用以有效的确立SAs for ESP 或 AH）
    和一组密码算法（被SAs使用））以保护其运载的数据
    
    在本文档中，术语“套件”或“加密套件”指用于保护SA的一整套算法。
    发起者通过列出支持的算法来提出一个或多个套件，这些算法可以以混合匹配的方式组合成套件。
    
    ESP或AH的SAs通过IKE SA设置，我们称之为“child SAs”
    
    所有IKE通信都由成对的消息组成：一个请求和一个响应。该对称为“交换”，有时称为“请求/响应对”。
    建立IKE SA的第一次消息交换称为IKE_SA_INIT和IKE_AUTH交换；
    随后的IKE交换称为创建子交换或信息交换
    在常见情况下，有一个IKE_SA_INIT交换和一个IKE_AUTH交换（总共四条消息）来建立IKE SA和第一个子SA。
    完成后，可以按任意顺序进行任意数量的CREATE_CHILD_SA和INFORMATIONAL交换
    
    IKE会话的第一次交换IKE_SA_INIT协商IKE SA的安全参数，发送nonce，并发送Diffie-Hellman值
    第二次交换，IKE_AUTH，传输身份，证明与两个身份对应的机密知识，
    并为第一个（通常仅）AH或ESP子SA设置SA
    后续交换的类型包括创建子SA（创建子SA）和信息交换（删除SA、报告错误情况或执行其他内务管理）。
    
    1.1 使用场景
        IKE用于在许多不同的场景中协商ESP或AH SA，每个场景都有自己的特殊要求
        
        1.1.1. 隧道模式下的安全网关到安全网关
                         +-+-+-+-+-+            +-+-+-+-+-+
                         |         |   IPsec    |         |
            Protected    |Tunnel   |   tunnel   |Tunnel   |     Protected
            Subnet   <-->|Endpoint |<---------->|Endpoint |<--> Subnet
                         |         |            |         |
                         +-+-+-+-+-+            +-+-+-+-+-+
            每一个端点都会宣布它后面的一组地址，数据包将以隧道模式发送，
            其中内部IP报头将包含实际端点的IP地址
            
        1.1.2. 端点到端点传输模式
            +-+-+-+-+-+                                        +-+-+-+-+-+
            |         |                                        |         |
            |Protected|   IPsec transport  or tunnel mode SA   |Protected|
            |Endpoint |<-------------------------------------->|Endpoint |
            |         |                                        |         |
            +-+-+-+-+-+                                        +-+-+-+-+-+    
            在此场景中，IP连接的两个端点都按照[IPSECARCH]中主机的要求实现IPsec
            注：[IPSECARCH] “互联网协议的安全架构”，RFC 4301 2005年12月
            传输模式通常在没有内部IP报头的情况下使用。将为此SA保护的数据包协商一对地址。
            
            在这种情况下，一个或两个受保护的端点可能位于网络地址转换（NAT）节点后面，
            在这种情况下，隧道数据包必须采用UDP封装，
            以便UDP报头中的端口号可用于标识在NAT后面的各个端点（见第2.23节）
            
        1.1.3. 隧道模式下的端点到安全网关
            +-+-+-+-+-+                          +-+-+-+-+-+
            |         |         IPsec            |         |     Protected
            |Protected|         tunnel           |Tunnel   |     Subnet
            |Endpoint |<------------------------>|Endpoint |<--- and/or
            |         |                          |         |     Internet
            +-+-+-+-+-+                          +-+-+-+-+-+            
            在此场景中，受保护的端点通过受IPsec保护的隧道连接回其公司网络。
            在任何一种情况下，受保护的端点都需要一个与安全网关关联的IP地址，
            以便（公司电脑）返回给它的数据包将进入安全网关并通过隧道返回。
            该IP地址可以是静态的，也可以由安全网关动态分配。
            为了支持后一种情况，IKEv2包括一种机制（即配置有效负载），
            用于启动器请求安全网关拥有的IP地址，以便在其SA期间使用。
            在这种情况下，数据包将使用隧道模式。
            在来自受保护端点的每个数据包上，
            外部IP报头将包含与其当前位置关联的源IP地址
            而内部IP报头将包含由安全网关分配的源IP地址
            外部目的地地址将始终是安全网关的地址，
            而内部目的地地址将是数据包的最终目的地。
            在这种情况下，受保护的端点可能位于NAT后面。
            在这种情况下，安全网关看到的IP地址将与受保护网关发送的IP地址不同
            所以端点和数据包必须进行UDP封装才能正确路由。
    
    1.2 初始交换
        使用IKE的通信总是从IKE_SA_INIT和IKE_AUTH交换开始
        这些初始交换通常由四条消息组成，但在某些情况下，这一数字可能会增加
        第一对消息（IKE_SA_INIT）协商加密算法，交换nonce，并执行Diffie-Hellman交换[DH]
        第二对消息（IKE_AUTH）对以前的消息进行身份验证，交换身份和证书，并建立第一个子SA。
        这些消息的一部分通过IKE_SA_INIT交换建立的密钥进行加密和完整性保护，因此身份对窃听者隐藏
        有关如何生成加密密钥的信息，请参见第2.14节
        
        初始交换之后的所有消息都使用IKE_SA_INIT交换中协商的加密算法和密钥进行加密保护。
        这些后续消息使用第3.14节中描述的加密有效负载的语法，使用第2.14节中描述的派生密钥进行加密。
        
        每个IKE消息都包含一个消息ID作为其固定头的一部分。
        此消息ID用于匹配请求和响应，并标识消息的重新传输。
        
        HDR, SAi1, KEi, Ni  -->
            HDR包含各种安全参数索引（SPI）、版本号和标志。
            SAi1有效负载说明了启动器支持的IKE SA加密算法。
            KE有效负载发送启动器的Diffie-Hellman值。
            Ni是发起者的nonce。
            
        <--HDR、SAr1、KEr、Nr、[CERTREQ]
            响应者从发起者提供的选项中选择一个加密套件，并在SAr1负载中表示该选项，
            完成与KEr负载的Diffie-Hellman交换，
            并在Nr负载中发送其nonce。
            
        在协商的这一点上，每一方都可以生成SKeySeed，从中派生出该IKE SA的所有密钥。
        除了消息头之外，后面的消息都是加密的，并且完整性受到保护。
        用于加密和完整性保护的密钥来自SKeySeed，称为sku_e（加密）和SK_a（认证，也称为完整性保护）；
        有关密钥派生的详细信息，请参见第2.13节和第2.14节。
        为每个方向计算单独的SK_e和SK_a。
        除了从Diffie-Hellman值导出的密钥SK_e和SK_a用于保护IKE SA之外，
        还导出了另一个量SK_d，并用于派生用于child SA的密钥材料。
        
        HDR，SK{IDi，[CERT，][CERTREQ，][IDr，]AUTH，SAi2，TSi，TSr}-->
            SK{…} indicates that这些负载是被进行加密和完整性保护的(使用该方向的SK_e和SK_a)
            发起人用IDi有效载荷证明其身份，证明知道与IDi相对应的秘密，
            并使用AUTH有效载荷（见第2.15节）对第一个消息的内容进行完整性保护。
            它还可能在CERT有效载荷中发送其证书，在CERTREQ有效载荷中发送其信任锚列表。
            如果包括任何 CERT 有效载荷，提供的第一个证书必须包含用于验证 AUTH 字段的公钥。
            
            可选的有效负载IDr使发起方能够指定它要与响应方的哪个身份通信。
            当响应程序运行的计算机在同一IP地址上承载多个标识时，这非常有用。
            如果发起方建议的IDr不被响应方接受，响应方可能会使用其他IDr来完成交换。
            如果发起方随后不接受响应方使用的IDr与请求的IDr不同的事实，
            则发起方可以在注意到该事实后关闭SA。
            
            发起方开始使用SAi2有效负载协商子SA。
            从SAi2开始后面的几个字段（负载）在CREATE_CHILD_SA exchange中进行了描述。
            
            第2.9节讨论了流量选择器（TSi和TSr）
        
        <--HDR，SK{IDr，[CERT，]AUTH，SAr2，TSi，TSr}
            响应者用IDr有效载荷声明其身份，
            选择性地发送一个或多个证书同样，证书包含用于验证首先列出的身份验证的公钥），
            用身份验证有效载荷验证其身份并保护第二条消息的完整性，
            并在CREATE_Child_SA交换中使用下面描述的其他字段完成子SA的协商。
            
            IKE_AUTH 交换的双方必须验证所有签名和
            消息身份验证码(MACs,Message Authentication Codes)是正确的。
            如果任何一方使用了共享密钥进行身份验证，
            则ID有效负载中的名称必须与用于生成 AUTH 有效负载的密钥相对应。
         
        #在如下情况下，将进行多于两组的IKEv2交换
        由于发起程序在IKE_SA_INIT中发送其Diffie Hellman值，
        因此它必须猜测响应程序将从其支持的组列表中选择的Diffie Hellman组。
        如果发起者猜错了，响应者将使用INVALID_KEU_payload类型的Notify有效负载进行响应，
        指示所选组。在这种情况下，启动器必须使用更正的Diffie-Hellman组重试IKE_SA_INIT。
        发起方必须再次提出其可接受的全套加密套件，因为拒绝消息未经验证，
        否则主动攻击者可能会诱使端点协商一个较弱的套件，而不是双方都喜欢的较强的套件。
        
        如果在进行IEK_AUTH交换时，创建Child SA失败，IKE SA将仍会照常创建，
        在IKE_AUTH交换时，如下消息类型是不会阻止IKE SA的创建的：
        NO_PROPOSAL_CHOSEN, TS_UNACCEPTABLE, SINGLE_PAIR_REQUIRED, 
        INTERNAL_ADDRESS_FAILURE, 和 FAILED_CP_REQUIRED. （只会阻止Child SA的创建）
        而如果故障与创建IKE SA有关（例如，返回身份验证失败通知错误消息），则不会创建IKE SA
        
        请注意，尽管IKE_AUTH消息已加密且完整性受到保护，
        但如果接收此Notify错误消息的对等方尚未对另一端进行身份验证
        （或者如果对等方由于某种原因未能对另一端进行身份验证），则需要谨慎处理该信息。
        更准确地说，错误通知消息的发送者已知是IKE_SA_INIT交换的响应者，但无法确定发送者的身份。
        
        请注意，IKE_AUTH消息不包含KEi/KEr或Ni/Nr有效负载。
        因此，IKE_AUTH交换中的SA有效负载不能包含转换类型4（Diffie Hellman组），
        其值不能为NONE。实现应该省略整个转换子结构，而不是发送值NONE。
        
    1.3 CREATE_CHILD_SA交换
        CREATE_CHILD_SA用于创建新的 Child SAs 和重新设置IKE SAs和Child SAs的秘钥
        它可在完成初始交换后，由IKE SA的任意一端发起
        通过创建新SA，然后删除旧SA，可以重新设置SA的密钥
        本节介绍了密钥更新的第一部分，即新SA的创建；
        第2.8节介绍了密钥更新机制，包括将流量从旧SA移动到新SA以及删除旧SA。
        这两个部分必须一起阅读，以了解重新键入的整个过程。
        
        任何一个端点都可以启动CREATE_CHILD_SA交换，
        因此在本节中，术语initiator指启动此交换的端点。
        实现者可以拒绝IKE SA中的所有CREATE_CHILD_SA请求
        
        CREATE_CHILD_SA请求可以选择性地包含一个KE载荷，用于额外Diffie-Hellman交换，
        以便为CHILD SA提供更有力的前向保密性保证。
        
        Child SA 的秘钥材料包括：IKE SA期间建立的SK_d的一个函数、
        CREATE_CHILD_SA交换期间的nonces交换、
        和DH值（如果CREATE_CHILD_SA交换期间包含KE负载）
        
        如果CREATE_CHILD_SA交换包含KEi有效负载，
        则至少在一个SA提议/提案中必须包含KEi的Diffie Hellman组
        KEi的Diffie-Hellman组必须是发起方希望响应方接受的组的一个元素
        （可以提出其他Diffie-Hellman组）
        如果响应者使用不同的Diffie-Hellman组（无组除外）选择提案，
        则响应者必须拒绝请求，并在 INVALID_KE_PAYLOAD Notify 负载中
        指明其preferred DH组。
        
        响应者发送一个NO_ADDITIONAL_SAS通知，
        指出创建子SA请求不可接受，因为响应者不愿意在此IKE SA上接受更多子SA。
        此通知还可用于拒绝IKE SA密钥。
        一些最小实现可能只接受初始IKE交换上下文中的单个子SA设置，
        并拒绝任何后续添加更多的尝试。
        
        1.3.1. 使用CREATE_Child_SA交换创建新的子SA
            HDR, SK {SA, Ni, [KEi], TSi, TSr}  -->
                发起方在SA载荷中发送SA提案、在Ni载荷中发送nonce（随机数）、
                在KEi载荷中发送Diffie-Hellman值（可选），
                以及在TSi和TSr有效载荷中发送子SA的建议流量选择器。
            
            <-- HDR, SK {SA, Nr, [KEr], TSi, TSr}
                响应者在SA载荷中回复所接受的提案（使用相同的message id）、
                如果请求中包含KEi，且选择的加密套件包含该组？
                则还要在KEr负载中回复黎赫值
                将在该SA上发送的流量的流量选择器在响应中的TS有效负载中指定，
                其可以是子SA的发起方提议的子集。
                
            USE_TRANSPORT_MODE通知可以包含在请求消息中，该消息还包括请求子 SA 的 SA 有效负载。
            它请求子 SA 为创建的 SA 使用传输模式而不是隧道模式。
            如果请求被接受，响应还必须包括 USE_TRANSPORT_MODE 类型的通知。
            如果响应方拒绝该请求，则以隧道模式建立子 SA。如果发起者不能接受，发起者必须删除 SA。
            注意：除了使用此选项协商传输模式时，所有子 SA 都将使用隧道模式。
            
            ESP_TFC_PADDING_NOT_SUPPORTED 通知，。。。略
            
            NON_FIRST_FRAGMENTS_ALSO 通知。。。略
            
            2.22 节中介绍的 IPCOMP_SUPPORTED 通知也可以包含在交换中
        
        1.3.2 使用 CREATE_CHILD_SA 交换重新加密 IKE SA
            重新设置IKE SA密钥的CREATE_CHILD_SA请求为：  HDR, SK {SA, Ni, KEi} -->
                发起方在 SA 有效载荷中发送 SA 提议，在 Ni 有效载荷中发送一个随机数，
                并在 KEi 有效载荷中发送一个 Diffie-Hellman 值
                KEi 有效载荷必须被包含。
                在 SA 有效载荷的 SPI 字段中提供了一个新的发起方 SPI。
                一旦对等方收到重新加密 IKE SA 的请求或发送重新加密 IKE SA 的请求，
                它不应在'正在重新加密的 IKE SA 上'再启动任何新的 CREATE_CHILD_SA 交换
                
            重新加密 IKE SA 的 CREATE_CHILD_SA 响应是： <--  HDR, SK {SA, Nr, KEr}
                响应者（使用相同的message id）回复：接受的提案 in SA载荷、
                HD值 in KEr 载荷（如果选择的密码套件包含该[DH]组）
                a new responder SPI is supplied 在SA载荷的SPI域中
                
            新的IKE SA将其消息计数器设置为0，而不管它们在早期的IKE SA中是什么。
            来自新IKE SA两侧的第一个IKE请求将具有消息ID 0
            
            第2.18节还详细介绍了IKE SA密钥更新
            
        1.3.3 使用 CREATE_CHILD_SA 交换重新生成子 SA
            用于rekey子SA的CREATE_CHILD_SA请求为： 
            HDR, SK {N(REKEY_SA), SA, Ni, [KEi],TSi, TSr}   -->
                发起方发送SA提案 in SA有效载荷、nonce in Ni有效载荷、
                可选的Diffie-Hellman值 in KEi有效载荷中，
                以及建议的子SA的建议流量选择器 in TSi和TSr有效载荷中。
                
            第1.3.1节中所述的通知也可以通过密钥交换发送。
            通常，这些通知与原始交换中使用的通知相同；
            例如，当重新加密传输模式 SA 时，将使用 USE_TRANSPORT_MODE 通知。
                
            如果交换的目的是替换现有的 ESP 或 AH SA，
            则 REKEY_SA 通知必须包含在 CREATE_CHILD_SA 交换中
            重新加密的 SA 由 Notify 有效载荷中的 SPI 字段标识；
            是交换发起方在入站 ESP 或 AH 数据包中期望的 SPI。
            
            CREATE_CHILD_SA 对 rekey 一个 Child SA 的响应格式为：
            <-- HDR, SK {SA, Nr, [KEr], TSi, TSr}
            响应者（use same msg id）在SA载荷中回复接受的提案，
            在KEr载荷中回复黎赫值和所选的该组的密码套件（如果请求中包含KEi载荷）
            
            要在该子SA上发送的流量的流量选择器在响应中的TS有效载荷中指定，
            该有效载荷可以是子SA发起方提议的子集。
            
    1.4 INFORMATIONAL 交换
        在IKE SA的操作期间的不同时刻，对等方可能希望彼此传递关于错误或某些事件的通知的控制消息。
        为了实现这一点，IKE定义了一个 INFORMATIONAL 交换。 
        INFORMATIONAL 交换必须在初始交换之后进行，并使用协商密钥进行加密保护。 
        请注意，某些信息性消息（而不是交换）可以在IKE SA的上下文之外发送。
        
        与IKE SA相关的控制消息必须在该IKE SA下发送。
        与子SA相关的控制消息必须在生成它们的IKE SA的保护下发送
        （或其继承者---如果该 IKE SA 被 rekey 了）
        
        信息交换中的消息包含零个或多个通知、删除和配置负载
        信息交换请求的收件人必须发送一些响应；
        否则，发送方将假定消息在网络中丢失，并将重新传输它。
        该响应可能是一条空消息。
        信息交换中的请求消息也可能不包含有效负载。
        这是端点要求另一个端点验证其是否处于活动状态的所期望的方式。
        
        INFORMATIONAL 交换格式为：
        HDR, SK {[N,] [D,] [CP,] ...}  -->
        <--  HDR, SK {[N,] [D,] [CP], ...} 
    
        1.4.1 删除SA
            ESP和AH SA始终成对存在（区别于IKE SA），每个方向有一个SA。
            当SA关闭时，该对的两个成员都必须关闭（即删除）。
            每个端点必须关闭其传入SA，并允许另一个端点关闭每对中的另一个SA。
            为了删除一个SA，需一个 INFORMATIONAL 交换，
            该交换携带一个或过个 Delete 负载（列出了要删除的SA的SPI）
            收件人必须关闭指定的SA。
            注意，不能在单个消息中为 SA 的两端发送 Delete 有效载荷,
            ''' one never sends Delete payloads 
            for the two sides of an SA in a single message'''
            如果同时要删除多个SA, 双方各方在 INFORMATIONAL 中携带 Delete 载荷
            删除入站的那一半的SA
            
            通常响应的 INFORMATIONAL 将会包含 Delete 负载 ，指明删除了哪些入站SA
            for the paired SAs going in the other direction
            有一个例外。如果碰巧，一组SA的两端独立决定关闭它们，
            则每个SA都可能发送一个Delete 负载，并且两个请求可能在网络中交叉。
            如果一端收到了一个删除SA的负载，而该SA正是本端要删除的，
            而且也已经发出去了Delete载荷，则他必须在处理该resuest时删除出站的SA，
            而在处理response时删除入站的SA，
            但这种情况下，响应中就不应该再包含已删除的SA的Delete载荷了，
            因为这将导致重复删除，并且理论上可能删除错误的SA。
            
            与ESP和AH SA类似，IKE SA也通过发送信息交换来删除
            删除IKE SA会隐式关闭在其下协商的所有剩余子SA。
            对删除IKE SA的请求的响应是空的 INFORMATIONAL 响应。
            
            半封闭的ESP或AH连接是不正常的，
            如果它们持续存在，具有审计能力的节点应该审计它们的存在
            请注意，此规范没有指定时间段，因此由各个端点决定等待多长时间
            节点可以拒绝接受半关闭连接上的传入数据，但不能单方面关闭它们并重用SPI
            
    1.5 IKE SA外部的 Informational 消息
        在某些情况下，节点接收到无法处理的数据包，但可能希望将此情况通知发送方。
        o 如果ESP或AH数据包带有无法识别的SPI。
          这可能是由于接收节点最近崩溃并失去状态，或者是由于某些其他系统故障或攻击。
        o 如果加密的IKE请求数据包到达端口500或4500时带有无法识别的IKE SPI。
          这可能是由于接收节点最近崩溃并失去状态，或者是由于某些其他系统故障或攻击。
        o 如果IKE请求数据包到达时的主版本号高于实现支持的版本号
        
        在第一种情况下，如果接收节点具有到数据包来自的IP地址的活动IKE SA
        则它可以在INFORMATIONAL交换中通过该IKE SA发送一个INVALID_SPI通知的任意数据包
        通知数据包含无效数据包的SPI。通知的接收者无法判断SPI是针对AH还是ESP，
        但这并不重要，因为期望的SPI与这两者都不同
        如果不存在合适的IKE SA，则节点可以向源IP地址发送无加密保护的 informational 消息，
        如果数据包是UDP（UDP封装的ESP或AH），则使用源UDP端口作为目标端口
        在这种情况下，收件人只应将其用作提示可能存在错误（因为它很容易被伪造）
        此消息不是信息交换的一部分，接收节点不得响应此消息，因为这样做可能导致消息循环。
        消息的构造如下：
        不存在对此类通知的接收者有意义的IKE SPI值；使用零值或随机值都是可以接受的
        （这是第3.1节中禁止zero IKE Initiator SPI规则的例外）
        启动器标志设置为1，响应标志设置为0，版本标志以正常方式设置；第3.1节描述了这些标志。
        
        在第二和第三种情况下，消息总是在没有加密保护的情况下发送（在IKE SA之外）
        并且包含 either an INVALID_IKE_SPI or an INVALID_MAJOR_VERSION notification
        该消息是一个响应消息,所以 ip 和端口得自于他要回复的消息，并使用与之相同的 IKE SPI
        和 消息ID，交换类型也是拷贝自请求消息。Response flag被置1，版本标志以正常方式设置。
        
    16. 术语
        本文档中基本术语（如安全关联或SA）的定义可在[IPSECARCH]中找到
        本文件中的关键词  "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", 
        "SHOULD NOT", "RECOMMENDED", "MAY", and "OPTIONAL" 应按照 [MUSTSHOULD] 解释
        
    1.7 RFC 4306与本文件之间的重大差异
        本文件删除了嵌套AH和ESP的讨论，这是RFC 4306中的一个错误，
        是由于RFC 4306和RFC 4301之间的延迟造成的，基本上，IKEv2基于RFC 4301
        虽然单个数据包可以多次通过IPsec处理，但每个过程都使用单独的SA
        在IKEv2中，必须使用单独的CREATE_CHILD_SA交换创建每个SA。
        
        本文档删除了对 INTERNAL_ADDRESS_EXPIRY 配置属性的讨论，因为它的实现非常有问题
        
        该文档不再允许拒绝载荷顺序不正确的消息
        
        本文档对何时发送和不发送加密通知进行了说明，具体取决于当时的协商状态。
        
        本文将详细讨论如何协商组合模式密码。
        
        在第1.3.2节中，“应包括KEi有效载荷”更改为“必须包括KEi有效载荷”。
        这也导致了第2.18节的变更
        
        在第2.1节中介绍了发起者的 SPI 和/或 IP 应该如何被使用，以区分它是一个 
        "half-open" IKE SA ，还是一个新的请求
        
        本文件在第2.5节中澄清了如何使用 critical flag
        
        新增的第2.8.2节涵盖了同步IKE SA rekey
        
        新增的第2.9.2节 covers Traffic Selectors in rekeying
        
        本文件在第2.13节中增加了限制，即与IKEv2一起使用的所有伪随机函数（PRF）
        必须采用可变大小的密钥。
        不会影响任何现有的实现，因为本来就没有标准的PRF其秘钥是固定的
        
        第2.18节要求在 rekey IKE_SA时进行Diffie-Hellman交换
        (理论上，RFC4306允许一种策略，其中Diffie-Hellman交换是可选的，
        但在为IKE_SA重新设置密钥时，这是没有用的或不合适的）。
        
        第2.21节已大大扩展，以涵盖需要错误响应的不同情况以及相应的响应。
        
        第2.23节阐明了在nat穿越中，接受段应该能理解UDP封装的IPsec数据包
        和非UDP封装的IPsec数据包。
        
        增加了第2.23.1节，以描述请求传输模式时的NAT穿越。
        
        增加了第2.25节，以解释在删除和/或rekey SAs时出现计时冲突时如何采取行动，
        并定义了两个新的错误通知 (TEMPORARY_FAILURE and CHILD_SA_NOT_FOUND) 
        
2. IKE协议的细节和变化
    IKE通常在UDP端口500上侦听和发送，
    但IKE消息也可能在UDP端口4500上以稍微不同的格式接收（参见第2.23节）
    由于UDP是一种数据报（不可靠）协议，
    IKE在其定义中涵盖了从传输错误中恢复，包括数据包丢失、数据包重放和数据包伪造。
    
    尽管IKEv2消息旨在简短，但它们包含的结构在大小上没有硬上限（特别是数字证书），
    并且IKEv2本身没有用于分割大消息的机制
    
    所有IKEv2实现必须能够发送、接收和处理长达1280个八位字节的IKE消息，
    并且应该能够发送、接收和处理长达3000个八位字节的消息。
    IKEv2实现需要知道所支持的最大UDP消息大小，
    并且可能会通过省略一些证书或加密套件建议来缩短消息，如果这样会使消息低于最大值。
    使用“哈希和URL”格式，而不是尽可能在交换中包含证书，可以避免大多数问题。
    
    在端口4500上发送的包含IKE消息的所有数据包的UDP有效负载必须以四个零的前缀开头；
    否则，接收者将不知道如何处理它们
    
    2.1. 重传定时器的使用
        对于每对IKE消息，发起方负责在超时情况下重新传输。
        响应者不得重新传输响应，除非它收到请求的重新传输。
        发起者必须记住每个请求，直到收到相应的响应。
        响应者必须记住每个响应，直到它收到一个序列号大于或等于
        响应中的序列号加上其窗口大小的请求（见第2.3节）
        为了节省内存，允许响应者在超时几分钟后忘记响应。
        如果响应者接收到已忘记响应的重传请求，则必须忽略该请求（例如，不要尝试构造新响应）。
        
        IKE是一种可靠的协议：发起者必须重新传输请求，直到收到相应的响应或认为IKE SA失败为止
        在后一种情况下，发起者丢弃与IKE SA关联的所有状态以及使用该IKE SA协商的任何子SA。
        
        IKE_SA_INIT请求的重新传输需要一些特殊处理。当响应者接收到IKE_SA_INIT请求时，
        它必须确定该分组是属于现有“半开放”IKE SA的重传（在这种情况下，响应者重传相同的响应）
        还是新请求（在这种情况下，响应者创建新的IKE SA并发送新的响应）
        或者它属于已经收到IKE_AUTH请求的现有IKE SA（在这种情况下，响应者会忽略它）。
        仅使用发起者的SPI和/或IP地址来区分这三种情况是不够的，
        因为单个NAT后面的两个不同对等方可以选择相同的发起者SPI
        健壮的响应程序将进行IKE SA查找 using the whole packet, its hash, or the Ni payload.
        
        单向消息的重传策略与常规消息的重传策略有些不同。
        因为从未发送过确认，所以没有理由无偿重新传输单向消息
    
    2.2. 对消息ID使用序列号
        每个IKE消息都包含一个消息ID作为其固定头的一部分。
        此消息ID用于匹配请求和响应，并标识消息的重新传输。
        消息的重新传输必须使用与原始消息相同的消息ID。
        
        消息ID是一个32位的数量，对于IKE_SA_INIT消息
        （包括对COOKIE和 INVALID_KE_PAYLOAD等负载响应的重试消息），
        它为零，并且对于每个后续的交换该值递增。
        因此，第一对IKE_AUTH消息的ID为1，第二对（使用EAP时）的ID为2，依此类推。
        注：EAP :  Extensible Authentication Protocol (EAP) Payload
        在IKE SA重新设置密钥后，新IKE SA中的消息ID重置为零。
        
        IKE安全关联中的每个端点维护两个“当前”消息ID：
        下一个用于它发起的请求，下一个用于它期望在另一端的请求中看到的。
        这些计数器随着请求的生成和接收而增加。
        响应始终包含与相应请求相同的消息ID。
        如果两端发出的请求数量非常不同，则两个方向上的消息ID可能会非常不同。
        
        在本文件中, “发起人”指发起所述交易的一方。
        “原始发起人”始终指发起导致当前IKE SA的交换的一方。
        换句话说，如果“原始响应者” rekey the IKE SA,
        则该方成为新IKE SA的“原始发起人”。
        
        请注意，消息ID受到加密保护，并提供防止消息重播的保护。
        如果消息ID变得太大而无法容纳32位，则必须关闭或重新设置IKE SA密钥。
        
    2.3 重叠请求的窗口大小
        SET_WINDOW_SIZE通知声明发送端点能够保持多个未完成交换的状态，
        允许接收方在获得对第一个交换的响应之前发送多个请求。
        SET_WINDOW_SIZE通知关联的数据必须为4个八位字节长，
        并且包含发送方承诺保留的消息数量(big endian)。
        在初始交换完成之前，窗口大小始终为1
        
        IKE端点在发送后续消息之前必须等待对其每条消息的响应，
        除非它已从其对等方接收到一条SET_WINDOW_SIZE Notify消息，
        通知其对等方已准备好维护多条未完成消息的状态，以便允许更大的吞吐量。
        
        在设置IKE SA之后，为了最大限度地提高IKE吞吐量，
        IKE端点可以在获得对其中任何一个请求的响应之前发出多个请求，
        直到其对达到等方的SET_WINDOW_SIZE设置的限制
        IKE端点必须保留（或能够准确地重新生成）先前响应数量的副本，
        该数量等于其声明的窗口大小，以防其响应丢失，
        并且发起者通过重新传输请求来请求其重新传输。
        
        支持大于1的窗口大小的IKE端点应该能够处理无序的传入请求，
        以便在发生网络故障或数据包重新排序时最大限度地提高性能。
        
        窗口大小通常是特定实现的一个属性（可能是可配置的），
        与拥塞控制无关（例如，与TCP中的窗口大小不同）。
        特别是，未定义响应程序在收到包含小于当前有效值的SET_WINDOW_SIZE通知时
        应执行的操作。因此，目前没有办法减小现有IKE SA的窗口大小；你只能增加它。
        在为IKE SA重新设置密钥时，新的IKE SA从窗口大小1开始，
        直到通过发送新的SET_WINDOW_SIZE通知而显式增大为止。
        
        接收到支持窗口外的IKE消息ID时（消息id大于当前消息id+窗口大小）
        将发送 INVALID_MESSAGE_ID 通知
        此通知消息不得在响应中发送；而是发起一个 INFORMATIONAL 交换
        （通知数据包含该无效id）来告知对方。
        发送此通知是可选的，并且此类型的通知必须是速率受限的。
        
    2.4 状态同步和连接超时
        允许IKE端点随时忘记与IKE SA关联的所有状态以及相应子SA的集合
        这是端点崩溃和重新启动时的预期行为。
        当一个端点出现故障或重新初始化其状态时，另一个端点必须检测到这些情况，
        并且不要在废弃的SA上发送数据包，这会使其落入黑洞而继续浪费网络带宽
        
        INITIAL_CONTACT 通知断言该 IKE SA 是已身份互认双方的唯一活动 IKE SA
        它可以在崩溃后建立IKE SA时发送，
        并且接收者可以使用此信息删除其具有相同身份验证的任何其他IKE SA，而无需等待超时
        此通知不得由可复制的实体发送（例如一个漫游的用户凭据 where 使用者允许连接到
        公共防火墙 from 两个远程系统 at the same time）
        该 INITIAL_CONTACT 如果要分发送，则必须在第一个 IKE_AUTH 请求或响应，
        如果是在其它消息中，则接收方可以忽略它。
        
        由于IKE被设计为即使来自网络的DoS攻击也能运行，
        因此端点不得基于任何路由信息（例如ICMP消息）或到达时没有加密保护的IKE消息
        （例如，通知消息提示未知SPI）断定另一个端点发生故障。
        dos攻击 ： dos在攻击用户时，会对用户发出申请，并且是大量的发送
        一个端点只有在重复尝试联系另一个端点的超时时间内无人应答时，
        或收到一个加密保护的INITIAL_CONTACT通知 on a different IKE SA 
        to the same authenticated identity.
        一个终端应该基于路由信息，怀疑对端failed，并发送一个请求看对方是否还活着
        方法是：IKE指定一条空的信息性消息，该消息（与所有IKE请求一样）需要确认
        （注意，在IKE SA的上下文中，“空”消息由IKE头和不包含有效负载的加密有效负载组成）
        如果最近已从另一方接收到加密保护（新的，即未重新传输）消息，
        则可能会忽略未保护的通知消息。
        
        重试次数和超时长度不在本规范中，因为它们不影响互操作性
        建议在放弃SA之前，在至少几分钟的时间内至少重新传输十几次消息，
        但不同的环境可能需要不同的规则。
        如果与IKE SA关联的所有SA上只有传出流量，
        则必须确认另一个端点的存活性以避免黑洞。
        如果IKE SA或其任何子SA最近未收到任何受加密保护的消息，
        则系统需要执行活动性检查，以防止向死对等方发送消息。
        
        于SA设置的前两条消息没有加密保护，攻击者可能会在真正的响应者之前响应发起者的消息
        并破坏建立连接的尝试。 为了阻止此，发起方可能愿意接受对其第一条消息的多个响应，
        将每个响应视为可能合法的，对其进行响应，
        然后在接收到对其任何一个请求的有效加密保护响应时丢弃所有无效的半开连接。
        一旦接收到加密有效的响应，则应忽略所有后续响应，无论它们是否加密有效
        
        请注意，根据这些规则，没有理由就SA生命周期进行协商和达成一致
        如果重复缺失对IKE消息的响应，则假定伙伴已死亡，
        then，删除IKE SA和通过该IKE SA设置的所有子SA。
        
        IKE端点可以随时删除非活动子SA，以恢复用于保持其状态的资源。
        如果IKE端点选择删除子SA，它必须向另一端发送删除有效负载，通知其删除。
        闭IKE SA将隐式关闭所有关联的子SA。在这种情况下，除非另一个端点不再响应，
        否则IKE端点应发送一个删除有效负载，指示它已关闭IKE SA。
        
    2.5 版本号和向前兼容性
        本文档描述了IKE的2.0版，即主版本号为2，次版本号为0
        只有当数据包格式或所需操作发生了巨大变化，以至于旧版本节点无法与新版本节点进行互操作时
        主版本号才应增加。
        如果端点接收到具有更高主版本号的消息，则必须删除该消息，
        并应发送类型为 INVALID_MAJOR_VERSION  的未经验证的通知消息
        其中包含其支持的最高（最接近）版本号
        
        请注意，IKEv1不遵循这些规则，因为在v1中无法注意到您能够说出更高的版本号。
        
    2.6. IKE SA SPIs和 Cookies
        报头中最初的两个八位字节字段（称为“IKE SPI”）用作IKE数据包开头的连接标识符。
        每个端点选择两个SPI中的一个，并且必须选择它们，以便成为IKE SA的唯一标识符。
        SPI值为零是特殊的：它表示发送方尚未知道远程SPI值。
        传入的IKE数据包仅使用数据包的SPI映射到IKE SA，而不使用（例如）数据包的源IP地址
        与ESP和AH不同，在ESP和AH中，只有收件人的SPI出现在消息头中，
        在IKE中，发件人的SPI也会在每条消息中发送。
        由于IKE SA的原始发起者选择的SPI始终首先发送，
        因此，如果要使用分配的SPI查找适当的IKE SA，
        则打开多个IKE SA的端点必须查看头中的发起者标志，
        以确定其分配的是第一个八位字节还是第二个八位字节。
        
        在初始IKE交换的第一条消息中，发起方将不知道响应方的SPI值，因此将该字段设置为零。
        当IKE_SA_INIT交换由于INVALID_KE_PAYLOAD, NO_PROPOSAL_CHOSEN,
        or COOKIE (see Section 2.6) 而未导致IKE SA的创建时，
        响应者的SPI在响应消息中也将为零。
        但是，如果响应程序发送非零响应程序SPI，则发起程序不应仅出于该原因拒绝响应。
        
        针对IKE的两种可预期的攻击是状态攻击和CPU耗尽攻击。
        
        当响应程序检测到大量半开放IKE SA时，
        它应该使用包含COOKIE通知的响应来响应IKE_SA_INIT请求。
        与此通知关联的数据长度必须在1到64个八位字节之间（包括1到64个八位字节），
        其生成将在本节后面介绍
        如果IKE_SA_INIT响应包含COOKIE通知，则发起者必须重试IKE_SA_INIT请求
        并将包含接收数据的COOKIE通知作为第一个有效负载
        所有其他有效负载保持不变。初始交换将如下所示：
        Initiator                         Responder
        -------------------------------------------------------------------
        HDR(A,0), SAi1, KEi, Ni  -->
                                    <--  HDR(A,0), N(COOKIE)
        HDR(A,0), N(COOKIE), SAi1,
           KEi, Ni  -->
                                    <--  HDR(A,B), SAr1, KEr,
                                             Nr, [CERTREQ]
        HDR(A,B), SK {IDi, [CERT,]
           [CERTREQ,] [IDr,] AUTH,
           SAi2, TSi, TSr}  -->
                                    <--  HDR(A,B), SK {IDr, [CERT,]
                                             AUTH, SAr2, TSi, TSr}
        前两条消息不影响任何发起方或响应方的状态，但与cookie通信除外。
        特别是，前四条消息中的消息序列号将全部为零，最后两条消息中的消息序列号将为1。
        “A”是发起者分配的SPI，“B”是响应者分配的SPI
        
        略
        
    2.7 密码算法协商
        SA载荷由一个或多个方案组成。每个提案包含一个协议，每个协议包含一个或多个变换
        每个变换指定了一种加密算法，每个变换包括一个或多个属性
        （仅当变换ID未完全指定加密算法时才需要属性）
        响应者必须选择单个套件，可以是SA提案的任何子集
        每项提案包含一项协议。如果提案被接受，SA响应必须包含相同的协议。
        响应者必须接受单个提议或拒绝所有提议并返回错误。
        错误出现在类型为NO_PROPOSAL_SELECTED的通知中。
        
        每个IPsec协议提案都包含一个或多个转换，每个变换都包含一个变换类型。
        接受的加密套件必须仅包含提案中包含的每种类型的一个转换。
        例如：如果ESP方案包括转换ENCR_3DES、ENCR_AES w/keysize 128、
        ENCR_AES w/keysize 256、AUTH_HMAC_MD5和AUTH_HMAC_SHA，
        则接受的套件必须包含一个ENCR_转换和一个AUTH_转换
        
        如果发起者提出了具有完整性保护的普通密码，又提出了一个组合算法，
        则需要两种方案：其中一个方案包括具有完整性算法的普通密码，
        另一个方案包括不具有完整性算法的所有组合模式密码
        （因为组合模式密码不允许具有除“none”之外的任何完整性算法）。
        
    2.8 rekey
        IKE、ESP和AH安全关联使用的密钥应仅在有限的时间内使用，并保护有限的数据量。
        这限制了整个安全关联的生存期。
        当安全关联的生存期到期时，不得使用该安全关联。
        如果有需求，可以建立新的SA，重新建立SA以取代过期的SA称为“rekey”。
        为了实现最小的IPsec实现，可以选择在不重新启动整个IKE SA的情况下为SA rekey
        一种实现为：可以拒绝IKE SA中的所有CREATE_CHILD_SA请求
        如果SA已过期或即将过期，并且使用此处描述的机制重新rekey失败，
        则实现必须关闭IKE SA和任何关联的子SA，然后可以启动新的子SA
        实现可能希望支持SAs的 in-place rekeying，
        因为这样做可以提供更好的性能，并可能减少转换过程中丢失的数据包数量。
        
        要在现有IKE SA中为子SA重新设置密钥（rekey），
        请创建一个新的等效SA（见下文第2.17节），并在建立新SA后删除旧SA
        请注意，在重新设置密钥时，新的子SA不应具有与旧SA不同的流量选择器和算法
        
        要 rekey 一个IKE SA，在现有的 IKE SA 下，
        使用 CREATE_CHILD_SA 创建一个新的等效的IKE SA（参2.18节）
        这样创建的IKE SA继承了原始IKE SA的所有子SA
        新IKE SA用于维护这些子SA所需的所有控制消息。
        创建新的等效IKE SA后，发起者将删除旧IKE SA
        并且要删除自身的Delete载荷必须是通过旧IKE SA发送的最后一个请求
        
        应主动更新SA，即新SA应在旧SA到期且无法使用之前建立。
        在建立新SA和旧SA变得不可用之间应经过足够的时间，以便将流量切换到新SA。
        
        IKEv1和IKEv2之间的区别在于，在IKEv1中，SA的寿命是协商的。
        在IKEv2中，SA的每一端都负责在SA上实施自己的生存期策略，
        并在必要时重新设置SA的密钥。
        如果两端具有不同的生存期策略，则生存期较短的一端将始终是请求密钥更新的一端。
        如果SA长时间处于非活动状态，并且如果在没有流量的情况下，端点不会启动 SA
        则端点可以选择关闭SA，而不是在SA的生存期到期时重新设置其密钥。
        如果自上次重新设置SA密钥以来没有流量，它也可以这样做。
        
        请注意，IKEv2故意允许在公共端点之间使用相同流量选择器的并行SA
        其目的之一是支持SA之间的业务服务质量（QoS）差异
        （参见[DIFFSERVFIELD]、[DIFFSERVARCH]和[DIFFTUNNEL]第4.1节）
        因此，与IKEv1不同，端点和流量选择器的组合可能不会唯一地标识那些端点之间的SA
        
        CREATE_CHILD_SA 的响应者必须先准备好接受 SA 上的消息，
        然后再发送其对创建请求的响应。
        发起者在接收并处理发给他的 CREATE_CHILD_SA 请求的响应之前，
        不能在新创建的SA上进行接收。
        那么，响应者如何知道何时可以在新创建的 SA 上进行发送？
        从技术正确性和互操作性的角度来看，
        只要响应者发送了对 CREATE_CHILD_SA 请求的响应，就可以开始在 SA 上发送
        然而，在某些情况下，这可能会导致不必要地丢弃数据包
        因此（响应者）在实现时，可能会推迟发送
        
        如果在 SA 对的另一半上接收到加密有效的消息，
        或者新 SA 对现有 SA 重新加密并且接收到关闭替换 SA 的 IKE 请求 （rekey)，
        则可以确保响应者准备在 SA 上接收消息
        在为 SA 重新设置密钥时，
        响应者继续在旧 SA 上发送通信量，直到发生其中一个事件。
        建立新 SA 时，响应者可能会延迟在新 SA 上发送消息，直到收到消息或超时为止。
        如果发起者在 SA 上接收到一条消息，但尚未收到对其 CREATE_CHILD_SA 请求的响应，
        则会将其解释为可能的数据包丢失，并重新传输 CREATE_CHILD_SA 请求。
        如果新创建的 ESP SA 上没有消息排队，则发起者可以发送虚拟ESP 消息，
        以确保响应者启动器已准备好接收消息。
        
        2.8.1. 同时子 SA 密钥更新
            如果两端具有相同的生存期策略，则两者可能同时启动密钥更新（这将导致冗余 SA）。
            为了降低发生这种情况的概率，应该抖动重新键入请求的时间
            （在注意到需要rekey后，延迟随机时间）
            
            这种形式的密钥更新可能会暂时导致同一对节点之间出现多个类似的 SA。
            当有两个 SA 有资格接收数据包时，节点必须通过任一 SA 接收传入数据包。
            如果通过这种冲突创建了冗余 SA，则创建该 SA 的端点应关闭使用两个交换中使用的
            四个 nonce 中最低的 nonce 创建的 SA。
            “最低”是指一个八位字节一个八位字节的比较
            （而不是，例如，将 nonce 作为大整数进行比较）
            换句话说，从比较第一个八位组开始；如果它们相等，则移动到下一个八位组，依此类推。
            幸存的rekeyd SA的发起者应该在新的建立起来后，删除要被替换的SA
            
            下面解释了这对实现的影响。假设主机 A 和主机 B 具有一个具有 SPI（SPIa1、SPIb1）
            的现有子SA 对，并且两者同时开始对其重新设置密钥：
            
            Host A                              Host B
            -------------------------------------------------------------------
            send req1: N(REKEY_SA,SPIa1),
                 SA(..,SPIa2,..),Ni1,.. -->
                                                <-- send req2: N(REKEY_SA,SPIb1),
                                                    SA(..,SPIb2,..),Ni2
            recv req2 <--
                        
            在这一点上，A 知道有一个同步的密钥更新正在发生。
            然而，它还不知道哪哪个交换的nonce最低，
            因此它只会注意到这种情况，并像往常一样做出反应。
            
            send resp2: SA(..,SPIa3,..),Nr1,.. -->
                --> recv req1
                                
            现在 B 也知道同步rekey正在进行。它的反应和往常一样：
            
                    <-- send resp1: SA(..,SPIb3,..),Nr2,..
            recv resp1 <--
                                --> recv resp2
                                                    
            此时，A 和 B 之间有三个子 SA 对（旧的和两个新的）。
            A 和 B 现在可以比较 nonce。
            假设消息resp2 中的最低 nonce 为 Nr1；
            这种情况下，B（req2 的发送方）删除冗余的新 SA
            A（幸存的发起密钥更新 SA 的节点）删除旧 SA。
            
            send req3: D(SPIa1) -->
                        <-- send req4: D(SPIb2)
                        --> recv req3
                        <-- send resp3: D(SPIb1)
            recv req4 <--
            send resp4: D(SPIa3) -->
                        
            这样rekey就完成了
            
            但是，如果某些数据包在网络中丢失，导致重新传输，
            则可能会发生第二个可能的事件序列。
            密钥更新照常开始，但 A 的第一个数据包（req1）丢失。
            
            Host A                          Host B
            -------------------------------------------------------------------
            send req1: N(REKEY_SA,SPIa1),
                    SA(..,SPIa2,..),
                    Ni1,.. --> (lost)
                                            <-- send req2: N(REKEY_SA,SPIb1),
                                                SA(..,SPIb2,..),Ni2
            recv req2 <--
            send resp2: SA(..,SPIa3,..),
                Nr1,.. -->
                                            --> recv resp2
                                            <-- send req3: D(SPIb1)
            recv req3 <--
            send resp3: D(SPIa1) -->
                                            --> recv resp3
                                                        
            从 B 的角度来看，rekey现在已经完成，
            由于它还没有收到 A 的 req1，它甚至不知道（两端）同时进行了rekey
            但是，A 将继续重新传输消息，最终它将到达 B。
            
            resend req1 -->
                            --> recv req1
            
            对 B 来说，看起来 A 试图重新输入一个不再存在的 SA；
            因此，B 用一些非致命的错误来响应请求，例如 CHILD_SA_NOT_FOUND
            
                                <-- send resp1: N(CHILD_SA_NOT_FOUND)
            recv resp1 <--
            
            当 A 收到此错误时，它已经知道同时进行了密钥更新，因此可以忽略错误消息。
            
        2.8.2. 同步 IKE SA 密钥更新
            最复杂的情况可能发生在两个对等方同时尝试为 IKE_SA 重新设置密钥时。
            基本上，第 2.8 节中的文本也适用于本案例；
            但是，必须确保子 SA 由正确的 IKE_SA 继承
            
            两个端点都注意到同时重设密钥的情况与子 SA 的工作方式相同。
            在 CREATE_CHILD_SA 交换之后，A 和 B 之间存在三个 IKE SA：
            旧的 IKE SA 和两个新的 IKE SA。
            包含最低 nonce 的新 IKESA 应由创建它的节点删除，
            而另一个幸存的新 IKE SA 必须继承所有子 SA
            
            除了正常的同步密钥更新情况外，还有一种特殊情况，
            即一个对等方注意到另一个对等方正在进行密钥更新，
            然而在这之前他已经完成了其密钥更新。
            如果只有一个对等方检测到同时重设密钥，则不会创建冗余SA。
            在这种情况下，当未注意到同步rekey的peer获得rekey IKE SA 的请求，
            而该 IKE SA 它已经成功的rekey了，则它应返回TEMPORARY_FAILURE，
            因为这是一个它刚才正试图关闭的 IKE SA（无论它是否已发送 SA 的删除通知）。
            
            如果注意到同时rekey的那个对等体收到另一个对等体对旧的IKE SA的删除请求。
            则他知道另一个对等体没有检测到同步rekey，
            那么第一个对等体就可以忘记自己的rekey尝试。
            
            Host A                              Host B
            -------------------------------------------------------------------
            send req1:
                SA(..,SPIa1,..),Ni1,.. -->
                                                <-- send req2: SA(..,SPIb1,..),Ni2,..
                                                --> recv req1
                                                <-- send resp1: SA(..,SPIb2,..),Nr2,..
            recv resp1 <--
            send req3: D() -->
                                                --> recv req3
                                                
            此时，主机 B 看到关闭 IKE_SA 的请求。就像正常一样回复就行。
            但是，此时主机 B 应停止重新传输 req2，因为一旦主机 A 接收到 resp3，
            它将删除与旧 IKE_SA 关联的所有状态，并且将无法回复该状态。
            
            RFC 4306 中未包含TEMPORARY_FAILURE通知，也未协商对TEMPORARY_FAILURE通知的支持。
            因此，实现了 RFC 4306 而非本文档的较老的peer可能会收到这些通知。
            在这种情况下，他们会将其视为任何其他未知错误通知，并停止交换。
            因为另一个对等方已经为交换重新设置了密钥，所以这样做不会产生任何不良影响。
        
        2.8.3 rekey IKE SA vs. Reauthentication(重新验证)
            在 IKEv2 中，为 IKE SA 重新键入密钥和重新验证是不同的概念。
            为 IKE SA 重新设置密钥为 IKE SA 建立新密钥并重置消息 ID 计数器，
            但不会再次对各方进行身份验证（不涉及身份验证或 EAP 有效负载）
            尽管在某些环境中，为 IKE SA 重新键入密钥可能很重要，
            但重新验证（验证各方仍然可以访问长期凭据）通常更为重要。
            
            IKEv2 对重新验证没有任何特殊支持。
            通过从头创建新的 IKE SA（使用IKE_SA_INIT/IKE_AUTH 交换，
            不使用任何 REKEY_SA Notify 有效载荷），
            在新 IKE SA 内创建新的子 SA（不使用 REKEY_SA Notify 有效载荷），
            最后删除旧的 IKE SA（这也会删除旧的子 SA），可以完成重新身份验证。
            
            这意味着重新验证还将为 IKE SA 和子 SA 建立新密钥。
            因此，尽管密钥更新会比重新认证更频繁地执行，
            但是 "authentication lifetime" 比 "key lifetime" 短的情况没有意义。
            
            虽然新 IKE SA 的创建可以由任何一方（原始 IKE SA 中的发起方或响应方）发起，
            但 EAP 及 Confguration payloads 的使用实际上意味着重新验证必须由
            与原始 IKE SA 相同的一方发起。
            在这种情况下，IKEv2 当前不允许响应者请求重新验证；
            但是，有些扩展添加了此功能，如[REAUTH]。
    
    2.9. 流量选择器协商
        当符合 RFC4301 的 IPsec 子系统接收到与其安全策略数据库（SPD）中的"保护"选择器
        匹配的IP 数据包时，该子系统使用 IPsec 保护该数据包。
        当尚不存在 SA 时，IKE 的任务是创建 SA。
        系统 SPD 的维护不在 IKE 的范围内，
        尽管一些实现可能会在 IKE 运行时更新其 SPD（有关示例场景，请参阅第 1.1.3 节）
        
        流量选择器（TS）有效负载允许端点将一些信息从其 SPD 传输到其对等方。
        这些信息必须从 SPD 传送到 IKE（例如，PF_Key API[PFKEY]使用 SADB_QCQUIRE消息）。
        TS 有效负载指定将通过新设置的 SA 转发的数据包的选择标准。
        在某些情况下，这可以作为一致性检查，以确保 SPD 的一致性。
        在其他情况下，它指导 SPD 的动态更新。
        
        两个 TS 有效负载出现在创建子 SA 对的 exchange 中的每条消息中。
        每个 TS 有效负载包含一个或多个流量选择器。
        每个流量选择器由地址范围（IPv4 或 IPv6）、端口范围和 IP 协议 ID 组成。

        两个 TS 有效负载中的第一个称为 TSi（流量选择器发起者）。
        第二种称为 TSr（流量选择器响应者）。
        file://imgs/TSi和TSr.jpg     

        IKEv2 允许响应者选择发起者提议的流量的子集。
        当两个端点的配置正在更新，但只有一端接收到新信息时，可能会发生这种情况。
        由于两个端点可能由不同的人配置，因此即使在没有错误的情况下，
        不兼容性也可能持续很长一段时间。
        它还允许有意不同的配置，例如一端配置为隧道所有地址，并依赖另一端来拥有最新的列表
        
        当响应者选择发起者建议的流量子集时，
        它会将流量选择器缩小到发起者建议的某个子集（前提是该集合不会变为空集合）。
        如果建议的流量选择器类型未知，响应者将忽略该流量选择器，
        以便在缩小的集合中不返回未知类型。
        
        在这种情况下，为了使响应者能够选择适当的范围，
        如果发起方由于一个 data packet 而请求 SA，
        则发起方 should 在每个 TSi 和 TSr 中包括一个非常特定的流量选择器作为第一个流量选择器，
        该流量选择器包含触发请求的数据包中的地址
        
        在该示例中，启动器将在 TSi 中包括两个流量选择器：
        第一个包含地址范围（198.51.100.43-198.51.100.43）和来自数据包的源端口和 IP 协议，
        第二个包含所有端口和 IP 协议（198.51.100.0-198.51.100.255）。
        发起方将类似地在 TSr 中包括两个流量选择器。
                
        file://imgs/发起者的TSi和TSr.jpg
        响应者按如下方式执行变窄：
            o 如果响应者的策略不允许其接受提议的流量选择器的任何部分，
              则响应者将发送一条TS_UNACCEPTABLE Notify 消息。
            o 如果响应者的策略允许 TSi 和 TSr 覆盖的整个流量集，则无需缩小，
              响应者可以返回相同的TSi 和 TSr 值。
            o 如果响应者的策略允许其接受 TSi 和 TSr 的第一个选择器，
              则响应者必须将流量选择器缩小到包含启动器的第一个选择的子集。
              在上面的这个示例中，响应程序可能会使用TSi（198.51.100.43-198.51.100.43）
              的所有端口和 IP 协议进行响应 
            o 如果响应者的策略不允许其接受 TSi 和 TSr 的第一个选择器，
              则响应者将缩小到 TSi 和 TSr 的可接受子集
        
        当缩小范围时，可能有几个子集是可接受的，但它们的联合是不可接受的。
        在这种情况下，响应者任意选择其中一个，
        并且可以在响应中包括 ADDITIONAL_TS_POSSIBLE 通知。
        ADDITIONAL_TS_POSSIBLE 通知 asserts 响应者缩小了提议的流量选择器，
        但也可以接受其他流量选择器，尽管仅在单独的 SA 中。
        没有与此通知类型关联的数据。
        只有当启动器和响应程序的配置不同时，才会发生这种情况。
        如果发起者和响应者在隧道的粒度上达成一致，
        发起者将永远不会请求比响应者所能接受的更宽的隧道。
        
        响应者的策略可能包含多个较小的范围，所有范围都由发起者的流量选择器包含，
        同时响应者的policy为：这些范围中的每一个都应通过不同的 SA发送。
        继续上面的示例，响应者可能具有愿意将这些地址隧道到发起方和从发起方接收的策略，
        但可能要求每个地址对位于单独协商的子 SA上。
        如果发起者没有根据数据包生成请求，而是（例如）在启动时，
        那么将不会有非常特定的第一个流量选择器帮助响应者选择正确的范围。
        响应程序将无法确定此隧道中应包含哪对地址，
        它必须猜测或使用一条SINGLE_PAIR_REQUIRED 的消息拒绝请求。
        
        SINGLE_PAIR_REQUIRED 错误表示 CREATE_CHILD_SA 请求不可接受，
        因为他的发送者只愿意接受指定一对地址的流量选择器。
        请求者被期望的响应是，发起一个请求SA，使用特定的traffic it`s trying to forward。
        
        很少有实现具有要求每个地址对使用单独 SA 的策略。
        因此，如果只有发起者提出的 TSi 和 TSr的某些部分可被响应者接受，
        则响应者应将选择器缩小到可接受的子集，而不是使用SINGLE_PAIR_REQUIRED。
        
        2.9.1. 违反自己策略的流量选择器
            创建新 SA 时，启动器需要避免提出违反其自身策略的流量选择器。
            如果不遵守此规则，则可能会丢弃有效的通信量。
            如果使用[IPSECARCH]中的解相关策略，则不会发生此类策略冲突。
            
            一个例子最好地说明了这一点。假设主机 A 有一个策略，
            其效果是到 198.51.100.66 的流量通过使用 AES 加密的主机 B 发送，
            到 198.51.100.0/24 中所有其他主机的流量也通过 B 发送，
            但必须使用 3DES。还假设主机 B 接受 AES 和 3DE 的任意组合。

            如果主机 A 现在建议使用 3DES 的 SA，
            并且包含 TSr（198.51.100.0-198.51.100.255），这将被主机 B 接受。
            现在，主机 B 也可以使用此 SA 从 198.51.100.66 发送流量，
            但这些数据包将被 A 丢弃，因为它需要对该流量使用 AES。
            即使主机 A 仅为 198.51.100.66 创建使用 AES 的新 SA，
            主机 B 也可以自由地继续为流量使用第一个 SA。在这种情况下,
            在提议 SA 时，主机 A 应遵循其自己的政策，并包含一份 TSr，其中包含
            （（198.51.100.0-198.51.100.65），（198.51.100.67-198.51.100.255））
            
            通常，如果（1）发起者提出“针对流量 X（TSi/TSr），do SA”的建议，
            （2）对于 X 的某些子集 X`，发起者实际上不接受 SA 的流量 X`，并且
            （3）发起者愿意接受流量 X`使用带有某些 SA`（！=SA），则，
            由于响应者可以将 SA 或 SA` 应用于流量 X`，有效流量可能会被不必要地丢弃。
    
    2.10 临时随机数(Nonces)
        IKE_SA_INIT 消息每个都包含一个 nonce。
        这些 nonce 用作加密函数的输入。
        CREATE_CHILD_SA 请求和 CREATE_CHILD_SA 响应也包含 nonce。
        这些 nonce 用于为用于获取子 SA 密钥的密钥派生技术添加时效性，
        并确保从 Dife-Hellman 密钥创建强伪随机位。
        IKEv2 中使用的 nonce 必须随机选择，大小必须至少为 128 位，
        并且必须至少为协商伪随机函数（PRF）密钥大小的一半。
        但是，发起者在知道协商结果之前选择 nonce。
        因此，nonce 必须足够长，以满足所有提议的 PRF。
        如果密钥和 nonce 使用相同的随机数源，
        则必须注意确保后者的使用不会损害前者的安全
        
    2.11. 地址和端口灵活性
        IKE 在 UDP 端口 500 和 4500 上运行，
        并默认地在其运行的 IP 地址上建立 ESP 和 AH 关联。
        然而，外部报头中的 IP 地址和端口本身并没有加密保护
        IKE 设计为即使通过网络地址转换（NAT）盒也能工作
        即使源端口不是 500 或 4500，实现也必须接受传入请求，
        并且必须响应接收请求的地址和端口。
        它必须指定接收请求的地址和端口作为响应中的源地址和端口。
        IKE 在IPv4 或 IPv6 上的功能相同
        
    2.12 Diffie-Hellman 指数的重用
        IKE 使用短暂的 Dife-Hellman 交换生成密钥材料，以获得 完美前向保密 的特性
        这意味着，一旦一个连接被关闭，其对应的密钥被遗忘，
        即使是记录了该连接的所有数据，并可以访问该连接的所有长期密钥的人
        也无法重建用于保护会话的密钥而无需对会话密钥空间进行暴力搜索。
        
        要实现完美的前向保密性，需要在连接关闭时，
        每个端点不仅必须忘记连接使用的密钥，
        还必须忘记可用于重新计算这些密钥的任何信息。
        
        由于计算 Dife-Hellman 指数在计算上非常昂贵，
        端点可能会发现将这些指数用于多个连接设置是有利的。
        有几种合理的策略可以做到这一点。
        
        端点只能周期性地选择一个新的指数，
        但如果某些连接持续时间少于指数的生命周期，
        则这可能会导致不完美的前向保密性。
        
        或者，它可以跟踪每个连接使用的是哪个指数，
        并且只有在某些对应的连接关闭时才删除与指数相关的信息。
        这将允许在不丢失完美的前向保密性的情况下重用指数，而代价是维护更多的状态。
        
        是否以及何时重用 Dife-Hellman 指数是私人决定，因为它们不会影响互操作性。
        一种重用指数的实现形式可以是选择记住其他端点在过去交换中使用的指数，
        2.13 生成秘钥材料
        在 IKE SA 的上下文中，协商了四种加密算法：加密算法、完整性保护算法、
        Dife-Hellman 组和伪随机函数（PRF）。
        PRF 用于为 IKE SA 和子 SA 中使用的所有加密算法构造密钥材料。
        
        我们假设每个加密算法和完整性保护算法都使用固定大小的密钥，
        并且任意随机选择的固定大小的值都可以作为适当的密钥。
        对于接受可变长度密钥的算法，必须将固定密钥大小指定为协商的加密转换的一部分
        （有关密钥长度转换属性的定义，请参见第 3.3.5 节）。
        对于并非所有值都是有效密钥的算法（如具有密钥奇偶性的 DES 或 3DES），
        密码转换必须指定从任意值派生密钥的算法。
        
        对于基于哈希消息身份验证码（HMAC）的完整性保护函数，
        固定密钥大小是基础哈希函数输出的大小。
        
        假定 PRF 接受任意长度的密钥，但具有首选密钥大小。
        首选密钥大小必须用作 SK_d、SK_pi 和 SK_pr 的长度（见第 2.14 节）。
        对于基于 HMAC 构造的 PRF，首选密钥大小等于基础哈希函数输出的长度。
        其他类型的 PRF 必须指定其首选密钥大小。
            
        秘钥材料将总是作为协商的prf算法的输出被传送，
        由于所需的秘钥材料的量，可能比prf输出的size大，所以重复使用prf
        术语"prf+"描述了一种函数，该函数基于"称为“prf”的"伪随机函数的输入
        输出伪随机流
        在下文中，|表示串联。prf+定义为：
        prf+ (K,S) = T1 | T2 | T3 | T4 | ...
        式中：
        T1=prf（K，S | 0x01）
        T2=prf（K，T1 | S | 0x02）
        T3=prf（K，T2 | S | 0x03）
        T4=prf（K，T3 | S | 0x04）。。。
        这将一直持续到计算所有需要的秘钥所需的材料被从prf+中输出出来。
        秘钥被从输出流中取出而不考虑boundaries，例如
        如果所需密钥是 256 位高级加密标准（AES）密钥和 160 位 HMAC 密钥，
        而prf 函数生成 160 位，则 AES 密钥将来自 T1 和 T2 的开头，
        而 HMAC 密钥将来自 T2 的其余部分和 T3 的开头
        
    2.14 为 IKE SA 生成秘钥材料
        共享密钥的计算如下所示：从IKE_SA_INIT交换期间交换的nonces和
        该交换期间建立的DifeHellman共享秘钥中计算出一个名为SKEYSEED的数。
        SKEYSEED 用于计算其他七个秘钥：
        SK_d 用于为CHILD_SA产生新秘钥（该CHILD_SA随IKE SA建立），
        SK_ai 和 SK_ar 用作完整性保护算法的密钥，用于验证后续交换的消息
        SK_ei 和 SK_er 用于加密（当然还有解密）所有后续交换，
        SK_pi 和 SK_pr 在生成身份验证有效负载时使用。
        SKEYSEED 及其衍生物的计算如下：
        SKEYSEED = prf(Ni | Nr, g^ir)
        {SK_d | SK_ai | SK_ar | SK_ei | SK_er | SK_pi | SK_pr }
        = prf+ (SKEYSEED, Ni | Nr | SPIi | SPIr )
        SK_d、SK_ai、SK_ar、SK_ei、SK_er、SK_pi 和 SK_pr 
        是按顺序从 prf+的生成位获取的
        g^ir 是短暂的 Dife-Hellman 交换的共享秘密。
        g^ir 表示为一个以大端顺序排列的八位字节串，
        如果需要，用零填充，以使其成为模的长度。
        Ni和Nr是去掉了头部的临时随机数
        出于历史向后兼容性的原因，有两个 PRF 在此计算中被特别处理。
        如果协商的 PRF 为 AES-XCBCPRF-128[AESXCBCPRF128]或 
        AES-CMAC-PRF-128[AESCMCAPRF128]
        则在计算SKEYSED 时仅使用 Ni 的前 64 位和 Nr 的前 64 位，
        但所有位都用于 PRF+函数的输入。
        两个方向的流量使用不同的秘钥
        用于保护来自发送者的消息的密钥是 SK_ai 和 SK_ei
        用于保护另一个方向的消息的秘钥时 SK_ar 和 SK_er
    
    2.15 IKE SA 的身份验证
        当不使用可扩展身份验证（参见第 2.16 节）时，
        通过让他们分别签名（或使用填充的共享密钥作为key的 MAC，如本节后面所述）
        一个数据块，来对对等方进行身份验证。
        在这些计算中，IDi`和IDr`是不包括the fixed header的整个 ID 有效载荷。
        对于响应者，要签名的八位字节以第二条消息（IKE_SA_INIT response）报头中
        第一个 SPI 的第一个八位字节开始，并以第二条消息中最后一个
        有效负载的最后一个八位字节结束。
        附加在这之后（为了计算签名的目的）是the initiator的nonce Ni
        （只是值，而不是包含它的有效负载）和值 prf（SK_pr，IDr`）。
        注意，既不传输 nonce Ni 也不传输值 prf(SK_pr,IDr`)。
        类似地，发起者对第一条消息（IKE_SA_INIT request）进行签名，
        从报头中第一个 SPI 的第一个八位组开始，
        以最后一个有效载荷的八位字节的最后一个八位字节结束
        
        发起者的签名八位字节流可以描述为：
        InitiatorSignedOctets = RealMessage1 | NonceRData | MACedIDForI
        GenIKEHDR = [ four octets 0 if using port 4500 ] | RealIKEHDR
        RealIKEHDR = SPIi | SPIr | . . . | Length
        RealMessage1 = RealIKEHDR | RestOfMessage1
        NonceRPayload = PayloadHeader | NonceRData
        InitiatorIDPayload = PayloadHeader | RestOfInitIDPayload
        RestOfInitIDPayload = IDType | RESERVED | InitIDData
        MACedIDForI = prf(SK_pi, RestOfInitIDPayload)
        
        响应者的签名八位字节流可以描述为：
        ResponderSignedOctets = RealMessage2 | NonceIData | MACedIDForR
        GenIKEHDR = [ four octets 0 if using port 4500 ] | RealIKEHDR
        RealIKEHDR = SPIi | SPIr | . . . | Length
        RealMessage2 = RealIKEHDR | RestOfMessage2
        NonceIPayload = PayloadHeader | NonceIData
        ResponderIDPayload = PayloadHeader | RestOfRespIDPayload
        RestOfRespIDPayload = IDType | RESERVED | RespIDData
        MACedIDForR = prf(SK_pr, RestOfRespIDPayload)
        
        ResponderSignedOctets = RealIKEHDR | RestOfMessage2 | NonceIData | MACedIDForR
        GenIKEHDR = [ four octets 0 if using port 4500 ] | SPIi | SPIr | . . . | Length
        RealIKEHDR = SPIi | SPIr | . . . | Length
        // RealMessage2 = RealIKEHDR | RestOfMessage2
        NonceIPayload = PayloadHeader | NonceIData
        ResponderIDPayload = PayloadHeader | RestOfRespIDPayload
        RestOfRespIDPayload = IDType | RESERVED | RespIDData
        MACedIDForR = prf(SK_pr, RestOfRespIDPayload)
        
        请注意，所有有效载荷都包含在签名下，包括本文档中未定义的任何有效载荷类型。
        如果 exchange 的第一条消息被多次发送
        （例如使用响应者 cookie 和/或不同的 Dife Hellman组），
        则签名的是该消息的最新版本
        
        可选地，消息 3 和 4 可以包括证书或证书链，
        
    2.23 NAT穿透
        网络地址转换（NAT）网关是一个有争议的话题。
        本节简要描述了它们是什么以及它们可能如何对 IKE 流量起作用。
        许多人认为 NAT 是邪恶的，我们不应该设计我们的协议来让它们更好地工作。
        IKEv2 确实指定了一些非直观的处理规则，以便 NAT 更容易工作。
        
        AT 的存在主要是因为 IPv4 地址的短缺，尽管还有其他原因。
        NAT“后面”的 IP 节点的 IP 地址不是全局唯一的，
        而是从 NAT 后面的网络中唯一，但可能被其他 NAT 后面的节点重用的
        某个地址段中分配的。
        
        ，NAT 后面的节点可以与同一 NAT 后面的其他节点以及
        具有全局唯一地址的节点通信，但不能与其他 NAT 后面的节点通信。
        这条规则也有例外。
        当这些节点连接到真实Internet 上的节点时，
        NAT 网关将 IP 源地址“转换”为将被路由回的网关的地址。
        从 Internet 发送到网关的消息将其目标地址“转换”为内部地址，
        该地址将数据包路由到正确的端节点
        
        NAT 被设计为对端节点透明 。
        NAT 后面的节点上的软件和 Internet 上的节点都不需要修改才能通过 NAT 进行通信。
        某些协议比其他协议更难实现这种透明度。
        除非 NAT 网关理解协议并修改内部引用以及报头中的引用，
        否则包含数据包有效负载内的endpoints IP 地址的协议将失败。
        这些知识本质上是不可靠的，是违反网络层的，并且常常导致微妙的问题。
        
        通过 NAT 打开 IPsec 连接会带来特殊问题。
        如果连接在传输模式下运行，更改数据包上的 IP 地址将导致校验和失败，
        NAT 无法更正校验和，因为它们受到加密保护。
        即使在隧道模式下，也存在路由问题，
        因为透明地转换 AH 和 ESP 数据包的地址需要 NAT 中的特殊逻辑，
        并且该逻辑本质上是启发式的和不可靠的。
        因此，IKEv2 将使用 IKE 和 ESP 数据包的 UDP 封装。
        这种编码效率稍低，但 NAT 更容易处理。
        此外，防火墙可以配置为通过 UDP 封装的 IPsec 通信，
        但不能通过普通的、未封装的 ESP/AH，反之亦然。
        
        NAT 的常见做法是转换 TCP 和 UDP 端口号以及地址，
        并使用入站数据包的端口号来决定哪个内部节点应获得给定数据包。
        因此，即使 IKE 数据包必须发送到 UDP 端口 500 或 4500
        也必须接受来自任何端口的数据包，并且必须将响应发送到它们来自的端口
        这是因为当数据包通过NAT 时，端口可能会被修改。
        类似地，IKE 端点的 IP 地址通常不包括在 IKE 有效负载中，
        因为有效负载受到加密保护，并且不能被 NAT 透明地修改。
        
        端口 4500 保留给 UDP 封装的 ESP 和 IKE。
        如果 IPsec 端点在其与对应方（如下所述）之间发现NAT，
        则必须从端口 4500 发送所有后续流量，
        而 NAT 不应特别处理这些流量（as they might with port 500）。
        
        发起者可以将端口 4500 用于 IKE 和 ESP，无论是否存在 NAT，
        甚至在 IKE 开始时也是如此。
        当任何一方使用端口 4500 时，不需要发送带有 UDP 封装的 ESP，
        但需要理解接收到的 UDP 封装的 ESP 数据包
        UDP 封装不能在端口 500 上进行。
        
        如果支持网络地址转换遍历（NAT-T）
        （即，如果在 IKE_SA_INIT 期间交换了 NAT_DECTION_*_IP 有效负载），
        则所有设备必须能够随时接收和处理UDP 封装的 ESP 和非 UDP 封装的 ESP 数据包。
        任何一方都可以决定是否对 ESP 使用 UDP 封装，而不考虑另一方的选择。
        但是，如果检测到 NAT，两个设备都必须对 ESP 使用 UDP 封装。
        
        下面列出了支持 NAT 穿越[NATREQ]的具体要求。
        对 NAT 穿透的支持是可选的。
        仅在本节中，列出MUST的要求仅适用于支持 NAT 穿透的实现
        
        o IKE 发起者和响应者都必须在其 IKE_SA_INIT 数据包中包含 
          NAT_DECTION_DESTINATION_IP 和 NAT_DECTION_SOURCE_IP 类型的通知有效负载。
          这些有效负载可用于检测主机之间是否存在 NAT，以及哪一端位于 NAT 后面。
          IKE_SA_INIT 数据包中的有效负载位置正好位于 Ni 和 Nr 有效负载之后
          （在可选CERTREQ 有效负载之前）。
        o 与 NAT_DETECTION_SOURCE_IP 通知相关联的数据是 SPI 的 SHA-1 摘要
         （按照它们在报头中出现的顺序）、IP 地址和发送此数据包的端口。
          如果发送方不知道将使用多个network attachments中的哪一个发送数据包，
          则消息中可能存在多个 NAT_DETECTION_SOURCE_IP 有效负载
        o 与 NAT_DETECTION_DESTINATION_IP  通知相关联的数据是 SPI 的 SHA-1 摘要
         （按照它们在报头中出现的顺序）、IP 地址和该数据包发送到的端口。
        o NAT_DETECTION_SOURCE_IP或NAT_DETECTION_DESTINATION_IP通知
          的接收方可能会将提供的值与SPI、源或接收方IP地址（分别）、地址和端口
          的SHA-1哈希值进行比较，如果它们不匹配，它应该启用NAT穿越。
          在NAT_DETECTION_SOURCE_IP哈希值与收到的所有NAT_DETECTION_SOURCE_IP
          有效载荷不匹配的情况下，如果不支持NAT穿越，接收方可能会拒绝连接尝试。
          在NAT_DETECTION_DESTINATION_IP哈希值不匹配的情况下，
          这意味着接收NAT_DETECTION_DESTINATION_IP有效载荷的系统在NAT后面，
          该系统应该按照[UDPENCAPS]中的定义开始发送keepalive数据包；
          或者，如果不支持NAT穿越，它可能拒绝连接尝试。
        o 如果收到的NAT_DETECTION_SOURCE_IP有效载荷中没有一个与
          从包含有效载荷的数据包的IP头中发现的源IP和端口的预期值相匹配，
          这意味着发送这些有效载荷的系统在NAT后面
          （即，沿途有人改变了原始数据包的源地址以匹配NAT盒的地址）。
          在这种情况下，接收有效载荷的系统应该允许动态更新其他系统的IP地址，如后面所述
        o IKE发起者必须检查NAT_DETECTION_SOURCE_IP或NAT_DETECTION_DESTINATION_IP
          有效载荷（如果存在），如果它们与外部数据包中的地址不匹配，
          则必须将与该IKE SA相关的所有future的IKE和ESP数据包通过UDP 4500端口tunnel。
        o 通过UDP 4500端口对IKE数据包进行隧道传输，IKE头有四个八位数的零预置，
          其结果紧随UDP头。要在UDP 4500端口上隧道传输ESP数据包，ESP头紧随UDP头。
          由于ESP头的前四个八位数包含SPI，而SPI不能有效为零，所以总是可以区分ESP和IKE消息。
        o 即使未检测到 NAT，实现也必须处理接收到的 UDP 封装 ESP 数据包。
        o 传输模式的TCP和UDP数据包校验修复（见[UDPENCAPS]）所需的原始源和目的IP地址
          从与交换相关的流量选择器中获得。
          在传输模式NAT穿越的情况下，流量选择器必须正好包含一个IP地址，
          然后将其作为原始IP地址。这在第2.23.1节中有更详细的介绍。
        o 在有些情况下，NAT box决定删除仍然活着的映射（例如，keepalive间隔时间太长，
          或者NAT box被重新启动）。如果主机收到一个完整性保护验证的数据包，
          但它的端口、地址或两者都与已验证数据包中的 SA 关联端口和/或地址不同，
          这对主机来说是显而易见的。当发现这样的验证包时，
          而主机不支持其他recovery方法，如IKEv2移动性和多重归属（MOBIKE）[MOBIKE]，
          并且主机不在NAT后面，
          主机应将所有数据包（包括重传数据包）发送到有效验证的包中的IP地址和端口，
          并应将其存储为SA的新地址和端口（也就是说，他们应动态更新该地址）。
          如果验证的数据包有不同的端口和/或地址值，
          而在NAT后面的主机不应该做这种类型的动态地址更新，
          因为这可能会带来DoS攻击（例如允许攻击者用一个数据包破坏连接）。
          另外，动态地址更新应该只在响应新的数据包时进行；
          否则，攻击者可以用旧的重放数据包来恢复地址。
          正因为如此，只有在启用重放保护的情况下才能安全地进行动态更新。
          当IKEv2与MOBIKE一起使用时，动态更新上述地址会干扰MOBIKE从相同情况下恢复的方式。
          更多信息见[MOBIKE]的3.8节
        
        2.23.1 传输模式 NAT 穿越
            AT 穿越使用的传输模式需要对 IKEv2 中使用的流量选择器进行特殊处理。
            完整的场景如下所示：
            +------+         +--------+            +-----+         +------+
            |Client|    IP1  | NAT    | IPN1 IPN2  | NAT |   IP2   |Server|
            |node  | <------>| A      |<---------->| B   |<------->|      |
            +------+         +--------+            +-----+         +------+
            
            +------+         +--------+            +-----+         +------+
            |Client|    IP1  | NAT    | IPN1 IPN2  | NAT |   IP2   |Server|
            |node  | <------>| A      |<---------->| B   |<------->|      |
            +------+         +--------+            +-----+         +------+
            （其他场景是此复杂案例的简化，因此本讨论使用完整场景。）
            
            在这个场景中，有两个地址转换 NAT：NAT A 和 NAT B。
            NAT A 是一个动态 NAT，
            它将客户端的源地址 IP1 映射到 IPN1。
            NAT B 是一种静态 NAT，
            配置为使到 IPN2 地址的连接映射到网关的地址 IP2，
            即 IPN2 目标地址映射到 IP2。
            这允许客户端通过连接到 IPN2 连接到服务器。
            NAT B 不一定必须是静态 NAT，但客户机需要知道如何连接到服务器，
            并且只有在它知道 NAT B 的外部地址（即 IPN2 地址）时才能这样做。
            如果 NAT B 是静态 NAT，则其地址可以配置为客户端的配置。
            另一种选择是使用其他协议（如 DNS）查找它， 但这超出了 IKEv2 的范围。
            
            在这种情况下，客户机和服务器都被配置使用传输模式
            将流量从源自客户机节点并发送到服务器。
            
            当客户端开始创建 IKEv2 SA 和子 SA 以向服务器发送流量时，
            它可能有一个源 IP 地址为 IP1、目标 IP 地址为 IPN2 的触发包。
            它的Peer Authorization Database（PAD）和 SPD 需要具有
            与这些地址匹配的配置（或包含这些地址的通配符条目）
            
            因为这是传输模式，所以它使用完全相同的地址作为IKE包的
            流量选择器 和 outer IP 地址。
            对于传输模式，它必须在 TSi 和 TSr 有效负载中使用一个 IP 地址。
            例如，如果它有多个要协商的端口范围，它可以有多个流量选择器，
            但所有 TSi 条目必须使用 IP1-IP1 范围作为 IP 地址，
            并且所有TSr 条目必须将 IPN2-IPN2 范围作为 IP 地址。
            TSi 和 TSr 的第一个流量选择器应该具有非常特定的流量选择器，
            包括协议和端口号，例如来自触发请求的数据包的流量选择器。
            
            然后，NAT A 将 IKE 数据包的源地址从 IP1 替换为 IPN1，
            NAT B 将 IKE 数据包的目标地址从IPN2 替换为 IP2，
            因此当数据包到达服务器时，
            它仍然具有与客户端发送的完全相同的流量选择器，
            但 IKE 数据包的 IP 地址已被 IPN1 和 IP2 替换。
            
            当服务器收到此数据包时，它通常会根据 ID 查找 
            RFC 4301[IPSECARCH]中描述的对等授权数据库（PAD），
            然后根据流量选择器搜索 SPD。
            因为 IP1 对服务器来说并不意味着什么（它是客户端在 NAT 后面的地址），
            所以如果使用传输模式，那么基于它进行查找是没有用的。
            另一方面，服务器在找到匹配的 SPD 条目之前，
            无法知道其策略是否允许传输模式。
            
            在这种情况下，服务器应首先检查发起者是否请求传输模式，
            然后在流量选择器上进行地址替换。
            它需要首先存储旧的流量选择器 IP 地址，
            以便稍后用于增量校验和修复（TSi 中的 IP 地址可以存储为原始源地址，
            TSr 中的 IP 地址可以存储为原始目标地址）。
            之后，如果检测到另一端在 NAT后面，
            则服务器将 TSi 有效负载中的 IP 地址替换为从接收到的 
            IKE 数据包的源地址获得的 IP 地址（即，它将 TSi 中的 IP1 替换为 IPN1）。
            如果检测到服务器端在 NAT 后面，它将用从接收到的
            IKE 数据包的目标地址获得的 IP 地址替换 TSr 有效负载中的 IP 地址
            （即，它将 TSr 中的 IPN2 替换为 IP2）。
            
            在这个地址替换之后，流量选择器和 IKE UDP 源/目标地址看起来都相同，
            服务器根据这些新的流量选择器进行 SPD 查找。
            如果找到一个条目并允许传输模式，则使用该条目。
            如果找到条目但不允许传输模式，则服务器可以撤消地址替换，
            并使用原始流量选择器。如果第二次查找成功，
            服务器将使用另一端发送的真实流量选择器在隧道模式下创建 SA
            
            在传输模式下需要这种地址替换，
            因为使用本地主机将看到的地址查找 SPD。
            这还将确保使用本地操作系统堆栈看到的地址添加用于隧道出口检查和
            返回数据包的安全关联数据库（SAD）条目。
            
            最常见的情况是，服务器的 SPD 将包含与任何地址匹配的通配符条目，
            但这也允许创建不同的SPD 条目，例如，针对不同已知 NAT 的外部地址
            
            SPD 查找后，服务器将根据找到的 SPD 条目进行流量选择器缩小。
            它将再次使用已经替换的流量选择器，
            并因此将发送回具有 IPN1 和 IP2 作为其 IP 地址的流量选择器；
            它仍然可以缩小流量选择器使用的协议号或端口范围。
            为子 SA 创建的 SAD 条目将具有服务器看到的地址，即 IPN1 和 IP2。
            
            当客户端接收到服务器对子 SA 的响应时，它将执行类似的处理。
            如果创建了传输模式 SA，
            客户端可以将原始返回的流量选择器存储为原始源地址和目标地址。
            它将用 IKE 数据包的 IP 头中的 IP
            地址替换流量选择器中的 IP 地址：它将用 IP1 替换 IPN1，
            用 IPN2 替换 IP2。然后，在根据发送的流量选择器验证 SA 时，
            以及在安装 SAD 条目时，它将使用这些流量选择器
            
            传输模式下 NAT 穿越的规则总结如下：
            对于提议运输模式的客户：
            - TSi 条目必须只有一个 IP 地址，并且必须与 IKE SA 的源地址匹配。
            - TSr 条目必须只有一个 IP 地址，并且必须与 IKE SA 的目标地址匹配。
            - 第一个 TSi 和 TSr 流量选择器应该具有非常特定的流量选择器，
              包括协议和端口号，例如来自触发请求的数据包的流量选择器。
            - 可能有多个 TSi 和 TSr 条目。
            - 如果选择了 SA 的传输模式（即，如果服务器在其响应中包含使用传输模式通知）
            - 将原始流量选择器存储为接收的源地址和目标地址。
            - 如果服务器位于 NAT 后面，则用 IKE SA 的远程地址替换 TSr 条目中的 IP 地址
            - 如果客户端位于 NAT 后面，则用 IKE SA 的本地地址替换 TSi 条目中的 IP 地址。
            - 在使用这些流量选择器进行存储原始内容以外的任何操作之前，请先进行地址替换。
              这包括验证另一端是否正确缩小了流量选择器，创建 SAD 条目，等等。
            
            对于响应者，当客户提议传输模式时：
            - 将原始流量选择器 IP 地址存储为接收的源地址和目标地址，以防需要撤销地址替换，
              用作[UDPENCAPS]指定的“ ” 真实源地址和目标地址 ，并用于 TCP/UDP 校验和修复。
            - 如果客户端位于 NAT 后面，则用 IKE SA 的远程地址替换 TSi 条目中的 IP 地址。
            - 如果服务器位于 NAT 后面，则用 IKE SA 的本地地址替换 TSr 条目中的 IP 地址。
            - 使用 ID 和替换的流量选择器查找 PAD 和 SPD。
            - 如果未找到 SPD 条目，或者如果找到的 SPD条目不允许传输模式，
              请撤消交通选择器替换。使用 ID 和原始流量选择器再次执行 
              PAD 和 SPD 查找，但也要搜索隧道模式 SPD 条目
              （即，返回到隧道模式）。
            - 但是，如果找到传输模式 SPD 条目，则根据替换的流量选择器和 SPD 条目进行
              正常流量选择缩小。
              创建 SAD 条目以及将流量选择器发送回客户端时，请使用生成的流量选择器。