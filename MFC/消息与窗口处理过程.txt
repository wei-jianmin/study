1.窗口与窗口处理过程
在SDK中，注册窗口类时，会指定窗口的消息处理函数，这样当窗口创建后，如果当前窗口中产生了消息，则系统能自动将消息正确传给该窗口对应的回调函数，并把当前窗口句柄、消息值、消息附加值等信息通过参数，传给窗口过程函数。

2.消息
结构定义：
        typedef struct tagMSG { 
            HWND hwnd; 	//Handle to the window whose window procedure receives the message
            UINT message; 	//消息标识符，如WM_SIZE、WM_COMMAND、WM_QUIT等等 
            WPARAM wParam; 	//32位消息的特定附加信息 
            LPARAM lParam; 	//32位消息的特定附加信息 
            DWORD time; 	//消息创建时的时间 
            POINT pt; 		//消息创建时的鼠标位置 
        } MSG, *PMSG, NEAR *NPMSG, FAR *LPMSG;
概念：
        消息就是一组数据包（结构体），用于传递信息。
        消息可以在操作系统和一个进程之间传递，也可以在两个不同的进程间传递，也可以在同一个进程的不同线程间传递或同一个进程的不同窗口间传递。 比如，你在QQ聊天窗口中点一下鼠标，打字等，都会产生消息。
       在代码中消息是以消息结构体MSG来保存的，里面的成员包括处理该消息的窗口句柄，消息代码，消息产生的时间和光标的位置等。 
消息分类：
<1>.队列消息和非队列消息：从消息的发送途径上看，消息分两种：队列消息和非队列消息。
       队列消息送到系统消息队列（MQ），然后到线程消息队列；
       非队列消息直接送给目的窗口过程。
       *? GetMessage和PeekMessage只能获取或查询当前线程的消息队列中的消息，没法访问同进程中其它线程的消息队列。
       这里，对消息队列阐述如下：
　　Windows维护一个系统消息队列(System message queue)，每个GUI线程有一个线程消息队列(Thread message queue)。
       鼠标、键盘事件由鼠标或键盘驱动程序转换成输入消息并把消息放进系统消息队列，例如WM_MOUSEMOVE、WM_LBUTTONUP、WM_KEYDOWN、WM_CHAR等等。
       Windows每次从系统消息队列移走一个消息(有系统服务程序自动完成此工作），确定它是送给哪个窗口的和这个窗口是由哪个线程创建的，然后，把它放进窗口创建线程的线程消息队列。
       线程消息队列接收送给该线程所创建窗口的消息。线程从消息队列取出消息，通过Windows把它送给适当的窗口过程来处理。
　　除了键盘、鼠标消息以外，队列消息还有WM_PAINT、WM_TIMER和WM_QUIT。
       这些队列消息以外的绝大多数消息是非队列消息。
<2>.系统消息和应用程序消息： 从消息的来源来看，可以分为：系统定义的消息和应用程序定义的消息。（控件改变时自己也会向系统发送消息，如invalidate）
　　系统消息ID的范围是从0到WM_USER-1，或0X80000到0XBFFFF；
       应用程序消息从WM_USER(0X0400)到0X7FFF，或0XC000到0XFFFF；
       WM_USER到0X7FFF范围的消息由应用程序自己使用；
       0XC000到0XFFFF范围的消息用来和其他应用程序通信，为了ID的唯一性，使用::RegisterWindowMessage来得到该范围的消息ID。
<3>.窗口消息，命令消息，控件通知消息：根据处理过程的不同,可以分为三类：窗口消息，命令消息，控件通知消息。
   (1).窗口消息
    一般以WM_开头，如WM_CREATE, WM_SIZE, WM_MOUSEMOVE等标准的Windows消息, 用于窗口相关的事件通知，窗口消息将由系统分配到该窗口的窗口过程处理。
    (2).命令消息 (WM_COMMAND)
    一种特殊的窗口消息，它从一个窗口发送到另一个窗口以处理来自用户的请求，通常是从子窗口发送到父窗口，例如，点击按钮时，按钮的父窗口会收到WM_COMMAND消息，用以通知父窗口按钮被点击，经测试：子窗口向父窗口发送WM_COMMAND消息，或者称为父窗口会收到WM_COMMAND消息，操作系统并不是通过将WM_COMMAND消息放入到父窗口的消息队列中去，而是直接调用了父窗口的窗口过程，以 WM_COMMAND 为消息标识参数(UINT uMsg)，实现这个功能的API函数正是: LRESULT DispatchMessage(const MSG *lpmsg);
    (3).控件通知消息
    WM_NOTIFY消息，当用户与控件交互(Edit, Button...)时，通知消息会从控件窗口发送到父窗口，这种消息的目的不是为了处理用户命令，而是为了让父窗 口能够适时的改变控件。  

消息是怎么传递并处理的           
消息（Message）在窗口中产生后，系统把它放入到该窗口所属线程的消息队列中，等待处理。       
线程将队列中的消息取得后，在翻译后，将它“投放”到相应的窗口过程函数中进行处理。       

消息处理机制的核心代码：       
while(GetMessage(&msg, NULL, 0, 0))       
{       
TranslateMessage(&msg);       
DispatchMessage(&msg);       
}       
根据MSDN，上面几个函数的作用：       
　　1.GetMessage只获取自己所属线程的消息队列中的消息，包括windows消息和通过PostThreadMessage发送的线程消息。       
　　2.TranslateMessage是为了将虚拟键消息“翻译”成字符消息，然后把字符消息放回到线程的消息队列中，在下一次被GetMessage取得。（具体内容见MSDN）        
　　3.DispatchMessage的作用是将从GetMessage获得的消息分发给相应的窗口处理函数（WndProc），然后窗口过程函数对消息进行处理。       

上面代码中使用while循环的意义是：循环是应用程序能够持续存在的根本原因。如果循环退出,则应用程序就结束了。



消息是根据窗口进行分发的，而不考虑该窗口的从属关系。也就是说在子窗口中产生的消息只在子窗口函数中处理，处理完后不会再把消息传递给父窗口（除非你自己做反射）。       
对窗口、线程、消息的关系总结：       
1.每一个窗口都是属于某一个线程的，注意是线程       
2.每一个窗口都“绑定”了一个“窗口函数”！也就是在每个窗口上产生的消息，会发往对应的函数来处理！
3.每一个线程都有一个属于自己的“消息队列”    
4.一个线程可以创建多个窗口
5.队列消息只能具体到线程，具体哪个窗口，有消息中的特定参数指明