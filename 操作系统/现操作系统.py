第三章 存储管理
    3.1 无存储器抽象
        最简单的存储器抽象，就是无存储抽象，每个程序都直接访问物理内存
        这时，呈现给编程人员的存储器模型就是简单的物理内存：从0到某个上限的地址集合
        这种情况下，要想在内存中同时运行两个程序几乎是不可能的：
        一个程序在某个地址写入的值，可能会被另一个程序在相同位置放入别的值。
        但这也不绝对，利用下面的方法，也还是能做到"同时"运行多个程序的：
        一种方法是采用"置换"的思想：把当前内存中的程序，存储到磁盘中，再运行别的程序，
        等需要的时候，再把磁盘中存储的程序转移到内存中，当然内存中原先的程序也要先存到磁盘上。
        另一种方法是使用"静态重定位"技术：两个程序被依次加载到内存，第一个程序是能正常执行的，
        第二个程序中所有涉及访问内存地址的指令都是有问题的，"静态重定位"技术就是
        在加载第二个程序时，对程序中所有涉及内存地址访问的指令进行修改，
        在其访问地址的基础上，加上当前程序加载的基地址。相加后的地址作为最终的内存访问地址。
        但这种方法需要程序提供额外的信息来区分哪些地址是内存访问地址，哪些地址不需要重定位，
        而且这种方式无疑会减慢程序的加载速度。
    3.2 一种存储器抽象：地址空间
        地址空间是一个进程可用于寻址内存的一套地址集合。
        借助"基址寄存器 & 界限寄存器"实现地址空间（可称为动态重定位技术）
            简单的把每个进程的地址空间映射到内存的不同部分。
            Intel的8086、8088都是使用的这种思路。借助"基址寄存器 & 界限寄存器"，程序在加载到内存中时，
            无需"静态重定位"，只需将程序的装载地址存到"基址寄存器"中，将程序的长度存到"界限寄存器"中。
            操作系统负责维护进程的切换和记录和设置每个进程的"基址寄存器 & 界限寄存器"的值。
            缺点：这种技术的假定前提是：内存足够大，可以保存所有进程。
        解决内存不够用的问题
            交换技术
                这里所说的交换技术，是指比较原始的交换，即把一个进程完整的在内存和磁盘之间交换。
                配合上面的动态重定位技术，内存中只能放有数的几个进程，每个进程只能在内存中存放一段时间，
                然后便会被置换到磁盘上，以便为其它放在磁盘上的进程或新的进程让出空间。
                有一个问题值得注意，就是进程被创建或换入时，应该为其分配多大的空间，
                因为有些程序可能涉及新内存申请的操作，一种解决办法是事先为其分配额外的内存，
                但因为无法预料每个程序可能需要多大的额外空间，所以这对于不需要那么多额外空间的进程是一种浪费
            虚拟内存技术
                该策略旨在使程序在只有一部分调入内存（其他部分在硬盘中）时，也能使程序正常执行。
                之一部分的内容在3.3节详细介绍
            如何记录内存的使用情况
                位图法
                    将内存划分为一个个的分配单元，再有一块区域负责记录内存分配单元的使用情况，称这块区域为位图
                    一个内存分配单元，对应位图中的1位
                    如果内存划分的约精细，内存分配单元的粒度越小，则意味着位图占用的内存空间越大，
                    而如果内存划分的越粗糙，内存分配单元的粒度越大，则内存的有效利用越不充分
                链表法
                    一个链表记录已分配内存段，一个链表记录空间内存段
    3.3 虚拟内存
        虚拟内存的基本思想是：每个程序拥有自己的地址空间（线性空间），
        这个地址空间被分为多个块，每一块称为"页"
        而物理内存也可对应的划分为多个块，每一块称为"页框"
        "页"和"页框"的大小通常是一样的。
        "页表":
            每个程序都分别有一张"页表"，一个程序有多少页(=线性空间/页大小)，
            对应的"页表"中就有多少格，每格记录了对应的"页框"的序号（反应物理内存地址），
            如果程序的某个"页"不在内存中，而在磁盘上，则"页表"中对应的这一格就为空。
            内存管理单元(MMU)会检索该页表，完成虚拟地址到物理地址的转换。
            如果MMU要转换的某个虚拟地址，检索页表时，发现对应的"页"没有相应的页框号，
            就知道该页没有在内存中，就会产生中断，从而陷入内核，
            内核会找一个很少使用的页框，将他的内容写入磁盘，再把要访问的页写入该页框，
            同时还会修改相应的"页表"项，完成后，再从原来中断的位置继续执行。
            每个进程控制块(PCB,process control block)中就有一项，指向进程对应的页表。
            为了提高MMU的检索页表进行地址转换的速度，后来还增加了TLB
            （translation lookaside buffer，转换后备缓冲区）硬件缓冲，
            把表常用的一部分存放到这个缓冲区中。
            另外需要补充说明的是，其实"页表"的每个表格不知记录了"页框"号，
            还记录了其他一些信息，如"在与不在标记位"表明了该"页"是否在物理内存中，
            有一个位表明了该页是否是只读的，有一个位表明了该页的内容是否发生了修改，
            这是有用的，因为当把一个未修改的页框从内存中换出时，只需单纯的删掉它即可。
            还有一个位用于禁止该页被放到高速缓存中（作为副本），如果"页表"中的该"页"
            对应的不是物理内存的页框，而是某个IO设备的缓存区域的页框，则这个页框如果被
            告诉缓存的话，就不能保证每次从设备读取到最新的信息（而是缓存的过时的信息）。
