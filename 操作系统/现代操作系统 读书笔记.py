第三章 存储管理
    3.1 无存储器抽象
        最简单的存储器抽象，就是无存储抽象，每个程序都直接访问物理内存
        这时，呈现给编程人员的存储器模型就是简单的物理内存：从0到某个上限的地址集合
        这种情况下，要想在内存中同时运行两个程序几乎是不可能的：
        一个程序在某个地址写入的值，可能会被另一个程序在相同位置放入别的值。
        但这也不绝对，利用下面的方法，也还是能做到"同时"运行多个程序的：
        一种方法是采用"置换"的思想：把当前内存中的程序，存储到磁盘中，再运行别的程序，
        等需要的时候，再把磁盘中存储的程序转移到内存中，当然内存中原先的程序也要先存到磁盘上。
        另一种方法是使用"静态重定位"技术：两个程序被依次加载到内存，第一个程序是能正常执行的，
        第二个程序中所有涉及访问内存地址的指令都是有问题的，"静态重定位"技术就是
        在加载第二个程序时，对程序中所有涉及内存地址访问的指令进行修改，
        在其访问地址的基础上，加上当前程序加载的基地址。相加后的地址作为最终的内存访问地址。
        但这种方法需要程序提供额外的信息来区分哪些地址是内存访问地址，哪些地址不需要重定位，
        而且这种方式无疑会减慢程序的加载速度。
    3.2 一种存储器抽象：地址空间
        地址空间是一个进程可用于寻址内存的一套地址集合。
        借助"基址寄存器 & 界限寄存器"实现地址空间（可称为动态重定位技术）
            简单的把每个进程的地址空间映射到内存的不同部分。
            Intel的8086、8088都是使用的这种思路。借助"基址寄存器 & 界限寄存器"，程序在加载到内存中时，
            无需"静态重定位"，只需将程序的装载地址存到"基址寄存器"中，将程序的长度存到"界限寄存器"中。
            操作系统负责维护进程的切换和记录和设置每个进程的"基址寄存器 & 界限寄存器"的值。
            缺点：这种技术的假定前提是：内存足够大，可以保存所有进程。
        解决内存不够用的问题
            交换技术
                这里所说的交换技术，是指比较原始的交换，即把一个进程完整的在内存和磁盘之间交换。
                配合上面的动态重定位技术，内存中只能放有数的几个进程，每个进程只能在内存中存放一段时间，
                然后便会被置换到磁盘上，以便为其它放在磁盘上的进程或新的进程让出空间。
                有一个问题值得注意，就是进程被创建或换入时，应该为其分配多大的空间，
                因为有些程序可能涉及新内存申请的操作，一种解决办法是事先为其分配额外的内存，
                但因为无法预料每个程序可能需要多大的额外空间，所以这对于不需要那么多额外空间的进程是一种浪费
            虚拟内存技术
                该策略旨在使程序在只有一部分调入内存（其他部分在硬盘中）时，也能使程序正常执行。
                之一部分的内容在3.3节详细介绍
            如何记录内存的使用情况
                位图法
                    将内存划分为一个个的分配单元，再有一块区域负责记录内存分配单元的使用情况，称这块区域为位图
                    一个内存分配单元，对应位图中的1位
                    如果内存划分的约精细，内存分配单元的粒度越小，则意味着位图占用的内存空间越大，
                    而如果内存划分的越粗糙，内存分配单元的粒度越大，则内存的有效利用越不充分
                链表法
                    一个链表记录已分配内存段，一个链表记录空间内存段
    3.3 虚拟内存（分页）
        虚拟内存的基本思想是：每个程序拥有自己的地址空间（线性空间），
        这个地址空间被分为多个块，每一块称为"页"
        而物理内存也可对应的划分为多个块，每一块称为"页框"
        "页"和"页框"的大小通常是一样的。
        "页表":（主要记录了线性空间到物理内存地址的映射关系）
            每个程序都分别有一张"页表"，一个程序有多少页(=线性空间/页大小)，
            对应的"页表"中就有多少格，每格记录了对应的"页框"的序号（反应物理内存地址），
            如果程序的某个"页"不在内存中，而在磁盘上，则"页表"中对应的这一格就为空。
            内存管理单元(MMU)会检索该页表，完成虚拟地址到物理地址的转换。
            如果MMU要转换的某个虚拟地址，检索页表时，发现对应的"页"没有相应的页框号，
            就知道该页没有在内存中，就会产生中断，从而陷入内核，
            内核会找一个很少使用的页框，将他的内容写入磁盘，再把要访问的页写入该页框，
            同时还会修改相应的"页表"项，完成后，再从原来中断的位置继续执行。
            每个进程控制块(PCB,process control block)中就有一项，指向进程对应的页表。
            为了提高MMU的检索页表进行地址转换的速度，后来还增加了TLB
            （translation lookaside buffer，转换后备缓冲区）硬件缓冲，
            把表常用的一部分存放到这个缓冲区中。
            页表的结构
                页表主要记录了虚拟地址到物理内存地址的映射关系
                需要补充说明的是，其实"页表"的每个表格不只记录了"页框"号，
                还记录了其他一些信息，如"在与不在标记位"表明了该"页"是否在物理内存中，
                有一个位表明了该页是否是只读的，有一个位表明了该页的内容是否发生了修改，
                这是有用的，因为当把一个未修改的页框从内存中换出时，只需单纯的删掉它即可。
                还有一个位用于禁止该页被放到高速缓存中（作为副本），如果"页表"中的该"页"
                对应的不是物理内存的页框，而是某个IO设备的缓存区域的页框，则这个页框如果被
                告诉缓存的话，就不能保证每次从设备读取到最新的信息（而是缓存的过时的信息）。
            页表的大小与访问速度问题
                如果虚拟地址空间为8G，每页大小为4K，则"页表"中将有100万项，而64位的地址将多，
                而且是每个进程都有一个页表，这带来两个问题：表占用空间大、查表速度慢
                解决办法有优化"页表"结构(如多级页表)、使用TLB缓存常用页表项（TLB通常设计在MMU中）
    3.7 分段
        首先需要说明的是，有了分页机制就已经够了，Linux就没有使用分段机制。
        但分段机制也有一定的优点，所以Windows使用了分段+分页的内存管理机制。
        有了分页技术，为什么还要使用分段
            使得每个段都可以从0开始编址，配合段基址，就可得到唯一的线性空间地址
            如果程序有多个段，每个段都可占用4G大小，而不是整个程序总共占4G大小
            方便在不同进程之间共享过程和数据，共享的部分可占单独的段，从0编址而不用重定位
                在纯分页系统中的共享库实现起来要麻烦的多，并且实际也是模拟分段来实现的
                在Linux中的共享库，使用的是相对编码地址（-fPIC）
            可以分段保护
                保护对分段是有意义的，分页机制不需要页保护，因为每个分段中存的是什么是确定的
                要么是代码，要么是数据，要么是堆栈等，他们的是只读，还是可写，还是可执行，
                都是明确知道的，但分页机制中，每个页存的是什么则是可变的，不可知的，
        奔腾处理器的分段机制
            奔腾处理器有16k（2^14）个独立的段，每段的容量为4G，每个内部又使用了分页机制
            LDT和GDT
                崩腾处理器中，虚拟内存的核心时LDT（局部描述符表）和GDT（全部描述符表）。
                每个程序都有自己的LDT，同一台计算机上所有的程序共享一个GDT。
                LDT描述每个程序的段，包括代码段、数据段、堆栈段等，
                GDT描述系统段，包括操作系统本身。
                一个段描述符（LDT或GDT的表项）由8个字节构成，
                通过段描述符表，可获知段的基地址、大小、是否在内存中、特权等级、段类型及保护等信息
                程序中代码段中使用的地址，都是偏移地址，转为线性地址时，先根据段寄存器中存放的
                段选择子，拿到段描述符表的表项，根据表项中的信息，得到段的基址，
                在将该段基址与程序中的偏移地址相加，得到最终的32位线性地址。
                可见使用段机制，使得每个段都可以从0开始编址。
            段寄存器
                为了选择一个段，必须先把段的选择子装入到机器的一个段寄存器中。
                段寄存器有16位，虽然上面提到处理器支持2^14个段，但其实是LDT和GDT各占2^13表项，
                所以需要占用寄存器的13位存放段描述符表的表项索引，
                1位存放LDT(=1)/GDT(=0)标记，另外还剩两位存放特权等级(1~3)，
                奔腾处理器虽然有6个段寄存器，但重要的只有两个：CS代码段寄存器、DS数据段寄存器。
第四章 文件系统
    磁盘是块设备，可以按块为单位进行读写
    4.1 文件
        文件是一种抽象机制，它提供了一种在磁盘上保留信息和读取信息的方法
        用户无需了解信息的存储方法、位置、磁盘工作方式等细节。
        文件结构
            无结构：Windows/Linux 都是使用的这种模型，应用程序负责解释文件结构
            记录序列：存盘中存放的是一条条的记录，每个记录都是等长的。已弃用
            记录树：记录按树结构组织，记录大小各不相同，
                    它在一些处理商业数据的大计算机中广泛使用
    4.2 目录 
        略，没什么重要知识点
    4.3 文件系统的实现
        4.3.1 文件系统布局
            多数磁盘划分为一个或多个分区，每一个分区中有一个独立的文件系统。
            磁盘的0号删除，称为"主引导记录"（Master Boot Record,MBR）,用来引导计算机。
            在MBR的结尾，是"分区表"。该表记录了每个分区的起始和结束位置。
            表中的一个分区会被标记为"活动分区"。
            在计算机被引导时，BIOS读入并执行MBR，MBR做的第一件事就是确定活动分区，
            然后读入活动分区的第一个块，并执行这个快，这个块被称作"引导块"。
            引导块中的程序将装载该分区中的操作系统。
            为了统一，每个分区都从一个启动块开始，即使它不含有一个可启动的操作系统。
            每个分区中还必有一个"超级块"，它包含文件系统的所有关键参数，
            系统系统后，超级块会被读到内存中，超级块包含了文件系统类型、文件系统中
            数据块的数量及其它一些重要信息。
            其他的，磁盘中还有存放文件i节点的区域、存放文件和目录的区域等。
        4.3.2 文件的实现
            文件存储的关键问题是：记录文件，分别会用到磁盘的哪些块。
            不同的操作系统，有不同的处理办法
            1. 连续分配
                每个文件按块对齐、依次存放在磁盘上
                优点是实现简单，记录每个文件所用到的磁盘块，只需记录开始磁盘块和总块数。
                其次，读操作性能好，只需定位到文件开始位置，之后不在需要寻到和旋转延迟，
                所以数据以磁盘带块的速率输入。
                缺点：随着文件不断的增加和删除，磁盘会变量零碎。而且后期，磁盘上存在的
                将是一块块大小不一的空白区段，一个新的文件需要放在某个空白区段上，但这
                需要提前知道文件的大小，才能找出一个合适的区段存放新文件。
                但这种分配方案也有其用武之地，就如在CD-ROM文件系统中。
                DVD情况稍复杂点，它使用的系统是UDF（Universal Disk Format）格式，
                它使用一个30位的数来表示文件长度，从而每个文件的最大大小是1G，
                其结果是，一个将近3G的电脑，将存储在3个1GB的连续文件中，
                这些（最终组成一个电影文件的）文件块称作，称作extents。
            2. 链表分配
                这种方法是为每个文件构造一个"磁盘块链表"：每个块的第一个字节作为指向
                下一块的指针，快的其他部分存放数据。
                优点：不必分配连续的块了，可以充分利用磁盘空间
                缺点：磁盘块的大小是2^n的，所以数据块的大小为：2^n - 块指针所占字节数，
                所以每个磁盘块中存放的数据不是 2^n 长度的，而许多程序往往善于处理2^n
                长度的数据块，意味着要读到 2^n 长度的数据块，需要读两个磁盘块才行。
                并且，这种方式如果要读文件的第15个块，必须从前面的14个块依次找过来，
                所以这种方式的文件的随机读写效率比较低。
            3. 链表分配：内存版
                针对链表分配方式的上述两个缺点，改为在内存中存放一个表，依次记录
                文件使用到的各个磁盘块，内存中的这个表，称为"文件分配表"
                (File Allocation Table, FAT)。
                这种方法的缺点是，必须把所有文件的表都放在内存中，如果一个磁盘有200G，
                每个磁盘块的大小为4KB，如果每个磁盘块指针占用4字节，则需要800M内存。
                所以这种方案，对于大磁盘不太合适。
            4. i节点
                该方案是没每个文件赋予一个i节点（index-node）的数据结构，
                该数据结构中记录了文件属性和文件块的磁盘地址，于是，根据给定的i节点，
                就可以找到文件所有的块。
                只有当文件打开时，i节点才放在内存中，所以也不占用大内存。
                i节点方案的一个问题是，如果每个i节点的结构是固定的，则意味着它只能存储
                固定数量（上限数量）的磁盘块地址，如果一个文件很大，占用的磁盘块数量
                超过这个上限，则一个i节点就没法表达这个大文件了，一种解决办法是，
                i节点结构体的最后一项，原本用来存放磁盘块地址的，改为指向另一个结构，
                再在这个新结构中，记录剩余（文件所占用的）各个磁盘块的地址。
        4.3.3 目录的实现
            上面4.3.2中，除了i节点方式外，另外几种文件存放方式都面临着一个问题，
            即如何存放每个文件的属性（如创建时间、是否可见等）
            一种简单的办法是，把每个文件的属性，放在该文件对应的目录项中，
            在这种设计方式中，每个文件对应的目录项的结构大小是固定的，
            结构中包含一个固定长度的文件名、一个文件属性结构以及必要的索引信息，
            指示文件实体如何被定位。
            对于i节点的文件组织方式，实现起来要简单的多，每个目录项中只需记录文件名和
            i节点号即可。
    4.5 文件系统实例
        4.5.1 CD-ROM文件系统
            1. ISO 9660文件系统
                现在市场上所有的CD-ROM都支持这个标准，有的则带有一些扩展
第五章 输入/输出                
    5.1 i/o硬件原理
        i/o设备可分为两类：块设备、字符设备
            块设备
                信息存储在固定大小的块中，每个块都有自己的地址
                块的大小通常在512~2^31字节之间
                传输以一个或多个完整的块为单位
                硬盘、CD、U盘，都是块设备
                可以看到磁盘上的文件，即使只有1字节，也要占用最小4k的空间
            字符设备
                以字符为单位读写，不考虑任何块结构
                字符设备是不可寻址的
                打印机、网络接口、鼠标、以及大多数与磁盘不同的设备都是字符设备
            对该模型的评价
                这种分类方法并不完美，有些设备没有包括进来，如时钟，
                内存映射的显示器也不适用于此模型。
                但块设备和字符设备模型具有足够的一般性，
                将其抽象出来，可以使系统不必关注设备的实现细节
                如文件系统只处理抽象的块设备，而把与设备相关的部分留给底层的软件
        cpu如何与设备的控制寄存器和数据缓冲区通信
            方法一（端口空间）
                为每个寄存器分配一个I/O端口号，所有I/O形成端口空间，
                并且受到保护，普通用户程序不能进行访问
                使用特定的I/O指令读写这些端口
            方法二（内存映射I/O）
                所有控制寄存器都映射到内存空间中
                每个控制寄存器都被分配唯一的内存地址（占用物理地址空间）
                优点：
                    不需要专门的CPU指令，像C/C++语言，直接读写内存就可以控制寄存器
                    所以对于内存映射I/O，设备的驱动完全可以用C语言编写，
                    而如果不用内存映射I/O,就要用到某些汇编语言
                缺点：
                    因为映射I/O的内存页不应被高速缓存，所以为系统和硬件添加量复杂性
                    。。。
            方法三（混合模式）
                设备的数据缓冲区使用内存映射，控制寄存器使用I/O端口空间
                奔腾处理器就是使用的这种方式
        直接存储器存取（DMA）
            参：https://blog.csdn.net/as480133937/article/details/104927922
            上面提到的方式，都需要CPU直接与设备的寄存器进行数据交换
            为了使CPU从这种工作中解脱出来，所以提出了直接存储器存取的方法，
            我们知道有3中内存-外设间的通信关系：内存-内存、内存-外设、外设-外设
            内存-外设间的通信是这里关注的重点，根据DMA的参与情况，可分为两种模型：
            1：DMA控制设备寄存器直接读写内存，DMA不参与数据的传输
            2：DMA负责中转数据的传输，
            第2种方式占用更多的总线周期，但更加灵活，
            可以执行设备-设备，甚至内存-内存的复制
            DMA的工作思路是：让CPU把要读写的任务告诉DMA，由DMA完成，最后DMA在告知CPU
            具体是：以磁盘为例，CPU通过设置DMA的寄存器，告诉它将什么数据传送到什么地方，
            DMA控制器给磁盘控制器发出命令，告知它从磁盘读数据，
            磁盘控制器将数据读到其缓冲区中，并进行校验，完成后通知DMA控制器，
            DMA控制器再给磁盘控制器发送读请求，进行DMA传送
            最后完成数据的传送后，DMA通过中断的方式通知CPU
            另外需要补充的是，不是所有的计算机都使用DMA，反对的主要论据是：
            CPU要比DMA控制器快的多，如果CPU没有其他工作要做，让CPU等待DMA是无意义的，
            而且，去除DMA控制器还可节约金钱，旨在低端的嵌入式计算机上很有意义。
        外设的中断
            硬件层面的中断
                当一个I/O设备工作完成时，他就在分配给它的一条总线信号线上
                置器信号从而产生中断。该信号被主板上的中断控制器芯片检测到，
                而中断控制器芯片决定做什么。
                当同时又多个中断信号到达中断控制器时，中断控制器在地址线上放置一个
                数字（中断向量），表明当前受理了哪个中断，并置起一个中断CPU的信号
第八章 多处理机系统
    8.3 虚拟化
        有两种虚拟化的方法：I型管理程序、II型管理程序
            I型管理程序
                运行在HAL层上的是虚拟机管理器，他是唯一一个运行在内核态的程序
                他的工作是支持真实硬件的多个副本，也称作虚拟机
                虚拟机内运行的客户操作系统，它认为自己运行在内核态，
                但实际是运行在用户态，我们称这种状态为虚拟内核态。
                当客户操作系统一条敏感指令时，如果cpu支持虚拟化，则会引发中断，
                并因此陷入到真正的内核――――虚拟机管理器中；
                然后虚拟机判断当前指令时客户机内核中的代码，还是客户机用户程序代码
                如果是内核代码，则调度真实cpu执行该指令，
                如果是用户程序中的指令，则仿真面对运行在用户态的敏感指令时，
                真实硬件的行为：可能引起中断、可能忽略、也可能调度执行
            II型管理程序
                它运行在windows或Linux上，他是用户程序，能够“解释”机器指令集，
                也就是说，它并不是把托管的客户操作系统的指令代码直接交给cpu执行，
                而是对这些指令代码解释执行。
                VMWare就是这种模式的例子
                它是在Windows或Linux宿主操作系统上的作为普通用户运行的程序
                当运行一个适用于奔腾cpu的二进制文件时，VMware先浏览程序的代码段，
                将之分为一个个的基本块，所谓基本块，就是以jump、call、trap或
                其他改变控制流(PC指针)的指令结束的、可顺序运行的指令序列。
                然后通过二进制分析，检查基本块，找出基本块中是否有敏感指令
                如果有，则把每条敏感指令替换为"处理相应情况的VMWare调用"。
                于是，本来二进制文件不知道自己运行在虚拟机中，而是认为自己
                运行在真实机中，但经过VM的二进制有意的替换后的程序，
                就等同于该程序知道自己运行在虚拟机中了，
                所以这种程序(主动的)不会访问真实硬件，
                而是有意的访问虚拟机提供的特定的假的硬件，
                所以它始终不会使用到特权指令，也就避免了陷入内核
                要知道陷入内核的代价其实是非常昂贵的，需要清空处理器内的缓存、
                TLB和分支预测表等，所以相比而言，这就是II型管理程序的优势了。
                所以在有的情况下，II型管理程序比cpu支持虚拟化的I型程序效率也不差
                另外，II程序不关心cpu是否支持虚拟化技术，因为它根本不用特权指令
        虚拟机有两种类型的原因，与 x86 体系结构的设计缺陷有关：
            如果我们把希望虚拟机拦截的指令称作敏感指令
            把需要cpu在特权模式下才能执行，否则会引起特权中断的指令称作特权指令
            则当敏感指令是特权指令的子集时，该CPU才是可虚拟化的。
            而像x86这样的，那些不是特权指令的敏感指令，称为虚拟化漏洞。
            参：file://虚拟化/虚拟化面临的问题.png
            但从2005年开始，Intel和amd在他们的处理器上引进来虚拟化技术，
            从而从根本上解决了x86系列CPU不支持虚拟化的问题。
            Intel的虚拟化技术称为VT，amd的虚拟化技术称为SVM
        类虚拟化
        内存虚拟化
        IO虚拟化
第九章 安全
    9.8.1 防火墙  
        硬件防火墙
            有局域网需要被保护的公司，一般选择硬件防火墙
            外网的电缆或光纤等，接在防火墙的一侧，局域网接在防火墙的另一侧
            不经过防火墙的允许，任何包都不能通过防火墙
            实际情况下，防火墙通常会和路由器、网络地址转换盒、
            指令检查系统及其他设备联合起来工作。
            防火墙根据一些规则来配置，这些规则描述了什么是允许的，什么是不允许的
            防火墙的管理者可以修改这些规则（通常通过一个web界面进行）
            最简单的一种防火墙是无状态防火墙，
            它只检查通过的包的头部，然后根据头部的信息和防火墙的规则，
            判断是传送还是丢弃这个包。
            通过提取，可以拿到源/目的主机的IP、端口号、服务的类型、协议等。
            除了无状态防火墙，还有一种跟踪连接及连接状况的防火墙
            这些防火墙能更好的防止某些类型的共计，特别是那些和"建立连接"有关的攻击
        软件防火墙
            和硬件防火墙有同样的功能，只不过是通过软件实现的
第十章 实例研究1：Linux
    10.2.5 内核结构简介
        内核坐落在硬件之上，其结构大体如下：
        ----------------------------------系统API------------------------------------
        │   ------------IO部件------------      │ -内存管理部件- │ --进程管理部件-- │
        │-----------虚拟文件系统----------------│                │                  │
        │----终端---- │ --套接字-- │ -文件系统- │    虚拟内存    │     信号处理     │
        │ ↓ / 行规则  │  网络协议  │  通用块层  │    页面替换    │进程/线程创建/终止│
        │             │   路由器   │  IO调度器  │    页面缓存    │     CPU调度      │
        │字符设备驱动 │网络设备驱动│   块驱动   │                │                  │
        -----------------------------中断---------分配器-----------------------------
        将内核子系统，可以大体分为三个部件：
            IO部件
                包含所有负责与设备交互（包括网卡设备）的内核部件
                在最高层，所有这些IO功能，全部整合在一个虚拟系统层中。
                从顶层看，对一个文件的读写操作，不管文件是在那里，其使用方法都是一样的；
                从底层看，所有的IO操作都要通过每个设备驱动器
                块设备与字符设备的主要区别是块设备支持随机访问，从技术上讲，网络设备
                也属于字符设备，但因其处理方式与其它字符设备区别较大，所以独立出来。
                字符设备
                    在字符设备之上，每种字符设备的内核代码都不一样。
                    字符设备有两种不同的使用方式，
                    一种是像有的编辑器那样，可以把每个键盘输入，直接发送到驱动程序，
                    另一种是像终端那样，会缓存行，当按下回车后，可能还要进行行规则检查，
                    如shell会进行语法检查，然后才会把缓存的整行发送给驱动程序。
                网络设备
                    大多数Linux系统在内核中包含一个完整的硬件路由器功能，确保每个包被
                    送到正确的设备，或从设备送到正确的协议处理器，该功能比实际路由器差一些。
                    路由器代码之上是协议栈，它总是包含tcp/ip协议，页包含其他一些协议。
                块设备
                    在磁盘驱动器之上，是IO调度器，它负责排序和分配磁盘读写操作，以尽可能减少
                    磁头的无用移动，或满足其他的一些系统原则（如尽可能连续存储原则）。
                    块设备最顶层是文件系统，如fat32、ntfs、ext3、ext4等。
                    Linux支持多个文件系统同时存在，为了对文件系统隐藏不同硬件设备体系之间的区别
                    一个通用的块设备层被提供（给文件系统）以完成对块设备的抽象。
            内存管理部件
                任务包括维护虚拟内存到物理内存的映射、维护最近访问页面的缓存、实现页面置换算法等
            进程管理部件
                主要负责进程的创建和终止，另外还包括进程、线程的调度、信号处理等
            各部件之间的关系
                尽管上面把这三个部件相互分开，但实际他们是高度相互依赖的：内存中的数据来自磁盘，
                而文件系统中的文件，如提供运行时资源使用情况的文件，可能旨在内存中存在，
                另外，进线程与内存也是密不分割的。
            动态可装载模块
                处理内核中的静态部件外，Linux还支持动态可装载模块。
                这些模块用来补充或替换缺省的设备驱动、文件系统、网络或其他内核模块。
        HAL
            https://blog.csdn.net/colorant/article/details/2611559
            跟Windows一样，Linux也是建立在HAL上的
            Hal通过udev发现一个新的设备
    10.3.5 启动Linux系统
        BIOS详解
            参：百度百科
            主要芯片
                BIOS设置程序是储存在BIOS芯片中的，BIOS芯片是主板上的一块芯片（印有bios字样），
                只有在开机时才可以进行设置（按Delete或F12等键，进入bios设置界面）
                在BIOS发展的初期，BIOS是存在ROM中的，但因为它不支持改写，后来升级为EPROM，
                再后来升级为EEPROM，最后又升级为NORFlash。
            主要程序
                中断服务
                    BIOS中断实际是对一些端口的输入输出操作。
                    DOS/Windows系统对硬盘、键盘、显示器等外设的管理即建立在系统BIOS的基础上
                    程序与也可以通过INT 5、INT 13等中断的访问，直接调用BIOS的中断服务
                    更多BIOS中断服务：https://blog.csdn.net/liguodong86/article/details/3973337
                上电自检
                    这是由一个称为POST（power on self test，上电自检）的程序完成的。
                    检查项包括cpu、640k基本内存、1M以上的扩展内存、ROM、主板、
                    CMOS存储器、串并口、显卡、软键盘子系统、键鼠。
                    自检中若发现问题，系统将给出提示或鸣笛警告。
                自检程序
                    完成POST自检后，BIOS按照设置的启动顺序，搜索光驱、磁盘、网络服务器等，
                    找到有效的启动驱动器，从中读入系统引导记录（MBR）
                    然后将系统的控制权交给阴曹记录，由引导记录完成系统的启动。
            主要功能
                自检及初始化
                    1. 加电自检
                        电脑刚接通电源时的自检，检查电脑是否良好
                    2. 初始化
                        创建中断向量、设置寄存器、对外部设备进行初始化和检测
                    3. 引导程序
                        功能是引导操作系统
                        https://blog.csdn.net/farmwang/article/details/49962235
                        BIOS会读取硬盘的第一个扇区（MBR）到内存的0x7C00处，
                        并跳转到此处开始执行，不关心MBR里的代码是什么。
                程序服务处理
                    程序服务处理程序主要是为应用程序和操作系统服务，
                    这些服务主要与输入输出设备有关，例如读磁盘、文件输出到打印机等。
                    为了完成这些操作，BIOS必须直接与计算机的I/O设备打交道，
                    它通过端口发出命令，向各种外部设备传送数据以及从它们那儿接收数据，
                    使程序能够脱离具体的硬件操作。
                    BIOS可以和外设驱动器按照规范，进行简单的交互，
                    如显示服务（10H），只能控制屏幕显示字符或修改屏幕像素颜色等。
                    再如磁盘服务（13H），只能进行扇区的读写、读取磁盘类型、驱动器参数、驱动器状态
                    初始化硬盘参数、设置磁盘类型以及一些磁盘及控制器的诊断等基本操作。
                硬件中断处理
                    上面的服务是通过中断的形式来调用的，输入参数和输出参数都放在指定的寄存器中。
                    BIOS的服务功能是通过调用中断服务程序来实现的，
                    这些服务分为很多组，每组有一个专门的中断
                    例如显示服务，中断号为10H；屏幕打印，中断号为05H；磁盘及串行口服务，中断14H等
            BIOS中断、DOS中断、Linux中断之间的关系
                参：https://developer.aliyun.com/article/99280
                中断向量表（Interrupt Vector Table，IVT）
                    BIOS和DOS都是存在于实模式下的程序，由它们建立的中断调用的地址
                    都是建立在中断向量表（Interrupt Vector Table，IVT）中的。
                    它们都是通过软中断指令"int 中断号"来调用的。
                    BIOS中断调用的主要功能
                        计算机启动之初，中断向量表中的中断例程是由BIOS建立的，
                        它从物理内存地址0x0000处初始化并在中断向量表中添加各种处理例程。
                        的主要功能是提供了硬件访问的方法，该方法使对硬件的操作变得简单易行。
                        操作硬件无非是通过in/out指令来读写外设的端口，
                        BIOS中断程序处理是用来操作硬件的，故该处理程序中一定到处都是in/out指令
                        BIOS为什么添加中断处理例程呢？
                            （1）给自己用，（2）给后来的程序用，如加载器或boot loader
                        BIOS是如何设置中断处理程序的呢？
                            先硬件厂商为了让自己生产的产品易用，肯定事先写好了一组调用接口，
                            那这些硬件自己的接口代码在哪里呢？每个外设，
                            包括显卡、键盘、各种控制器等，都有自己的内存（ROM的），
                            硬件自己的功能调用例程及初始化代码就存放在这ROM中。
                            根据规范，第1个内存单元的内容是0x55，第2个存储单元是0xAA，
                            第3个存储代码长度（以512字节为单位），从第4个存储单元起就是实际代码了
                            这些外设的ROM会映射到内存的某处（0xC000~0xE000之间的内存），
                            如何映射过去的，这里暂不深究，只需知道这是硬件完成的工作。
                            然后BIOS会在运行期间扫描0xC0000到0xE0000之间的内存，
                            若在某个区域发现前两个字节是0x55和0xAA时，设意味着这是一段驱动程序，
                            BIOS会执行驱动程序的初始化代码部分，然后把驱动程序代码中中断响应函数
                            的地址填写到中断向量表中，至于驱动程序的哪部分是初始化代码、
                            哪部分是中断响应函数等，应该都是有格式、位置规范的。
                        BIOS维护和使用的中断向量表在0H~1FH之间，只要CPU遇到"INT 中断号"指令，
                        就会自动查询该中断向量表，并继而调转到真正的中断服务程序位置。
                    DOS中断
                        DOS和BIOS一样，都是运行在实模式，所以他们使用的是同样的中断向量表
                        不过规定0x20~0x27中断区间归DOS专用。当然DOS也可以调用BIOS中断。
                中断描述符表（Interrupt Descriptor Table，IDT）
                    Linux内核是在进入保护模式后才建立中断例程的，它维护和使用的是中断描述符表
                    如果在实模式下执行int指令，会自动去访问中断向量表。
                    如果在保护模式下执行int指令，则会自动访问中断描述符表。
                    inux是通过int 0x80指令进入一个中断程序，
                    再根据eax寄存器的值来调用不同的子功能函数
        MBR详解（Master Boot Record，主引导记录）
            计算机启动时，BIOS加电自检，对必备硬件进行检测和初始化，
            然后调用BIOS的磁盘IO服务，将MBR加载进内存
            ――――磁盘扇区级的操作通过BIOS即可完成，涉及文件路径的，才需要文件操作系统。
            接下来执行主磁盘第一个扇区的代码，即主引导记录（MBR），这个代码只有512字节，
            MBR包含三个部分：引导程序、分区表、分隔标识，
            之所以需要MBR，是因为BIOS太小，功能有限。
            https://www.cnblogs.com/CasonChan/p/4546658.html
                MBR主引导扇区位于磁盘的第一个扇区，即0号扇区，
                主要由引导代码、分区表、结束标志三部分构成，总共占512字节
                1、引导代码
                    引导程序，占扇区前446字节。计算机在上电完成BIOS自检后，
                    会将该主引导扇区加载到内存中并执行前面446字节的引导程序，
                    引导程序首先会在分区表中查找活动分区，若存在活动分区，
                    则根据活动分区的偏移量找到该活动分区上的引导扇区的地址，
                    并将该引导扇区加载到内存中，同时检查该引导扇区的有效性，
                    然后根据该引导扇区的规则去引导操作系统。
                    在一些非启动磁盘上，MBR引导代码可能都是0，这对磁盘使用没有任何影响。
                2、分区表
                    分区表，占扇区中间64字节。
                    分区表包含4个分区项。
                    每一个分区项通过位置偏移、分区大小来唯一确定一个主分区或者扩展分区。
                    每个分区项占16字节，包括引导标识、起始和结束位置的CHS参数、
                    分区类型、开始扇区、分区大小等
                    需要注意的是，分区项的第1个字节表示该分区是否是活动分区，
                    即是否包含系统引导扇区，用来引导操作系统。
                    每个磁盘只能同时有一个活动分区，活动分区的引导指示符是0x80，其他均为0x00
                    尽管我们可以通过一些工具来手动修改引导指示符，将其改成0x80，
                    但是引导程序只会查找并使用第一个引导指示符为0x80的活动分区
                3、结束标志
                    最后的"55 AA"即为结束标志，或者称魔数，占扇区最后2字节
                    次执行系统引导代码时都会检查MBR主引导扇区最后2字节是否是"55 AA"，
                    如果不是，则认为这是一个无效的MBR引导扇区，停止引导系统
        启动过程
            MBR从启动设备中（通常是磁盘）调入一个 boot程序。
            注：
                Linux中并不存在boot程序，而只是存在boot文件夹，boot下又有grub文件夹
                所以这里说的boot程序，是一种泛称，如Linux的grub，Windows的lilo等
                都可称之为boot程序（boot程序的含义可能更广泛，见下文）
            grub
                https://www.cnblogs.com/liuzhenbo/p/10806119.html
                grub不是 Linux 系统，它本身可以看作一个小型操作系统，
                内置了简单的文件系统，可以读取分区
                所以 grub 启动之后首先就是加载它自己的一个简单的文件系统，
                然后读取自己的相关配置文件
                总体上GRUB更像是一个mini os，
                只不过这个mini os的作用只是加载其他的操作系统，
                在GRUB中包括stage1、stage1.5（可选）和stage2
                其中stage1和stage1.5属于boot loader，stage2属于mini os的内核部分
                stage1
                    GRUB中stage1过程主要位于MBR的前446字节中
                    stage1的主要的也是唯一的作用就是找到你存放在硬盘上某个地方的
                    stage2文件，来完成后续的工作。
                    stage1部分占用了446字节，其代码文件是源码目录下stage1/stage1.S文件
                    汇编后生成一个512字节的boot.img，被写在硬盘的0面0道1扇区中，作为硬盘的MBR
                    stage1的工作很简单，就是加载0面0道2扇区上的512字节到0×8000，
                    然后跳转到0×8000执行
                    在0面0道2扇区上的512字节内容为stage1/start.S文件汇编后生成
                    该扇区上的内容的作用是加载stage1.5或是stage2过程，并将控制权转交
                stage1.5
                    该过程之所以区分stage1.5和stage2，主要原因是GRUB和GRUB2的区别
                    在GRUB2中，将stage1.5过程集成到了stage2的过程中，
                    所以stage1.5过程仅仅是针对GRUB的
                    Stage1.5的作用很单一，但是非常关键
                    它的主要功用就是构造一个'boot分区'系统对应的文件系统
                    这样可以通过文件系统的路径（/boot/grub/）寻找stage2过程需要的core.img，
                    进而加载到内存中开始执行。
                    Stage1.5存在于0面0道3扇区开始的地方，并一直延续十几k字节的区域，
                    具体的大小与相应的文件系统的大小有关
                    为了能引导不同的文件系统，所有有不同stage1.5过程的文件系统，如：
                    e2fs_stage1_5（针对ext2fs，可引导ext2和ext3文件系统）、
                    fat_stage1_5（针对fat文件系统，可引导fat32和fat16）、
                    ffs_stage1_5、jfs_stage1_5、minix_stage1_5、reiserfs_stage1_5、
                    vstafs_stage1_5和xfs_stage1_5等。
                    这些文件每个至少都在11k以上。
                    除此之外还有两个比较特殊的文件，分别为nbgrub和pxegrub，
                    这两个文件主要是在网络引导时使用，只是格式不同而已。
                    对于ext2fs文件系统，用于生成该文件系统的stage1.5过程文件
                    （e2fs_stage1_5）的代码为stage2/fsys_ext2fs.c文件。
                    在stage2/filesys.h文件中定义了每个文件系统对外的接口，
                    用于上层调用，作为stage2过程寻找核心代码使用。
                    文件系统一般被定义的接口主要就是三个函数，分别是mount、read和dir函数。
                    其中ext2fs_mount函数用于检查文件系统类型，并将superblock读入到内存中
                    ext2fs_read函数和ext2fs_dir函数用于对文件系统具体的操作
                    在stage2/fsys_ext2fs.c文件中除了需要对这三个函数的定义之外，
                    还需要文件系统的属性的数据结构（superblock、inode和group结构），
                    这些结构最初被定义在include/linux/ext2_fs.h文件中，
                    通过这些数据结构描述一个文件系统。
                stage2
                    GRUB中的核心过程也就是stage2过程了
                    该过程主要是在文件系统建立以后选择合适的操作系统进行加载并转交控制权，
                    达到最后引导操作系统的目标
                    由于GRUB属于multi boot loader，
                    因此在引导的时候要进行选择，选择哪种操作系统来运行
                    stage2入口的地方就是stage2/asm.S文件
                    Stage2/asm.S文件属于汇编代码，
                    主要作用是初始化C语言的运行环境，为下面执行C语言的函数做好准备
                    在准备好之后，将执行init_bios_info(stage2/common.c)函数
                    init_bios_info函数的作用是执行一些底层的函数，然后跳转到cmain执行
                    cmain函数位于stage2/stage2.c文件中
                    stage2.c ：https://blog.csdn.net/lanzheng_1113/article/details/104243068  
                    cmain函数内部进行一个死循环，在循环内部首先加载配置文件，显示给用户，
                    然后会进入一个内层循环，一条条的读取并执行配置文件中的命令；
                    如果在cmain外层村换中，找不到可用的文件，则进入命令行模式，
                    然后如果找到可用的menu，那么开始执行menu的对应的内容。
                    只要看到了启动菜单,表示已经成功的进入了grub的stage 2阶段,
                    因为启动菜单是在2 stage生成的.
                小结
                    因为stage1的容量有限（主引导记录MBR和启动扇区的大小只能够是512字节），
                    所以它对文件系统是无法识别的，那如果你把 stage2存放在ext2或者fat
                    格式的文件系统上，它如何来找到这个文件呢？
                    这就要用到上面提到的那些stage1_5的文件了，它们负责解释文件系统。
                    你的stage2放在什么格式的文件系统上，就要调用对应的那个stage1_5文件。
                    比如，你把stage2存放在ext2格式的文件系统上，就需要e2fs_stage1_5；
                    stage2存放在fat格式的文件系统上，就需要fat_stage1_5了。
                    grub的话，肯定是要在mbr里写东西的，但446字节的机器码也干不了太多东西，
                    只是负责把后续的内容加载到内存在执行而已。
                    这个写到mbr的是stage1，它加载的是写在mbr之后62个扇区中的stage1.5
                    但为stage1.5预留的代码空间基本也只够一种类型的文件系统，
                    所以stage1.5是有好几个，分别对应ext4，xfs等等，在grub安装时根据需要写入
                    stage1.5可以识别文件系统，然后根据安装时硬写到里面的系统路径
                    （hexdump可以看到）找到stage2，
                    然后这个stage2才是真正负责干活的，它会读取grub.cfg并生成启动菜单，
                    然后根据你的选择加载内核并把执行权限转过去，完成启动。
        总结
            总的来说，就是BIOS先进行加电自检，然后调用自己的磁盘IO服务，将MBR（主引导记录）
            加载进内存，MBR包含三个部分：引导程序(stage1)、分区表、魔数，然后stage1从固定
            扇区将stage1.5加载进内存，stage1.5内部实现了一个小的文件系统，可以识别/boot分区
            中的文件，然后stage1.5将固定文件名(/boot下）的stage2文件加载进内存，stage2根据grup.cfg
            的配置情况，在用户界面上显示系统启动菜单，并根据用户选择情况，加载系统内核并转交控制权
        补充：
            grub的全称是GRand Unified Bootloader
            现在grub已经被淘汰了，取而代之的是grub2，但grub2通常也称为grub，而早期的grub被称为grub legacy
            uboot和grub一样，同时BootLoader，uboot即universal boot loader，通常用在嵌入式系统中
        内核加载之后
            http://blog.chinaunix.net/uid-26495963-id-3066282.html
            加载内核
                根据grub设定的内核映像所在路径，系统读取内存映像，并进行解压缩操作
                解压后的内核放置在内存之中，并调用start_kernel()函数来启动一系列的
                初始化函数并初始化各种设备，完成Linux核心环境的建立。
            用户层init依据inittab文件来设定运行等级
                内核被加载后，第一个运行的程序便是/sbin/init，
                该文件会读取/etc/inittab文件，并依据此文件来进行初始化工作。
                其实/etc/inittab文件最主要的作用就是设定Linux的运行等级
                其设定形式是“：id:5:initdefault:”，这就表明Linux需要运行在等级5上
                Linux的运行等级设定如下：
                0：关机
                1：单用户模式
                2：无网络支持的多用户模式
                3：有网络支持的多用户模式
                4：保留，未使用
                5：有网络支持有X-Window支持的多用户模式
                6：重新引导系统，即重启
            init进程执行rc.sysinit
                在设定了运行等级后，Linux系统执行的第一个用户层文件就是
                /etc/rc.d/rc.sysinit脚本程序，
                它做的工作非常多，包括设定PATH、设定网络配置（/etc/sysconfig/network）、
                启动swap分区、设定/proc等等
            启动内核模块
                具体是依据/etc/modules.conf文件或/etc/modules.d目录下的文件来装载内核模块
            执行不同运行级别的脚本程序
                根据运行级别的不同，系统会运行rc0.d到rc6.d中的相应的脚本程序，
                来完成相应的初始化工作和启动相应的服务
            执行/etc/rc.d/rc.local
                rc.local就是在一切初始化工作后，Linux留给用户进行个性化的地方。
                你可以把你想设置和启动的东西放到这里。
            执行/bin/login程序，进入登录状态
                此时，系统已经进入到了等待用户输入username和password的时候了，
                你已经可以用自己的帐号登入系统了
    10.5 Linux中的I/O系统   
        Linux把设备当做一种特殊文件，整合到文件系统中
        每个i/o设备都分配了一条路径，通常在/dev目录下，
        可用于访问其他普通文件相同的方法来访问这些特殊文件，如
        cp file /dev/lp  文件打印
        每个特殊文件，都和一个处理其对应设备的设备驱动相关联
        大部分的i/o设备，只使用其对应的特殊文件即可进行交互，
        无需特殊的系统调用，然后，有时也需要一些设备专用的处理。
        如设置/获取终端的输入/输出速率等。
        Linux中，I/O是通过一系列的设备驱动来实现的，
        每个设备类型对应一个设备驱动。
        通过在驱动程序和操作系统其它部分之间提供一层标准的接口，
        使得大部分I/O系统可以被划分到内核的机器无关部分。
        当用户访问一个特殊文件时，由文件系统提供此特殊文件的主设备号
        和次设备号，并判断他是一个块特殊文件，还是字符特殊文件。
        根据主设备号，检索存有字符设备数据结构的散列表，
        （或检索存有块设备数据结构的散列表）
        从中定位到保存了打开设备、读设备、写设备等函数指针的数据结构，
        次设备号当做参数传递给这些函数。
        每个驱动程序都分为两部分，
        这两部分都属于Linux内核的一部分，运行在内核态。
        上半部分运行在调用者的上下文，并且与Linux其它部分交互；
        下半部分运行在内核上下文，并且与设备交互。
        驱动程序可以调用内存分配、定时器管理、DMA控制等内核过程。
        Linux依靠一个i/o调度器来对块设备的读写请求重新排序，
        或对这些读写请求进行合并。
    10.6 Linux文件系统
        文件系统的发展历史
            最初的Linux文件系统是MINIX 1文件系统，只支持14字节的文件名和最大64M的文件
            后来在此基础上开发出ext系统，支持255个字符和最大2G的文件，但它比MINIX 1速度慢
            再后来，又继续开发出ext2系统，它能支持长文件名和大文件，并且具有更好的性能
        Linux使用虚拟文件系统（VFS）层支持多类型的文件系统
            VFS定义了一个基本的文件系统抽象一级这些抽象上允许的操作的集合。
            VFS对高层进程和应用程序隐藏了Linux支持的所有文件系统之间的区别，
            以及文件系统是存储在本地的，还是在远程设备上。
            设备和其他特殊文件也可通过VSF访问。
            使用VFS时，首先要确定要访问的文件系统，然后通过存储在VFS数据结构中的函数指针
            调用该文件系统的相应操作
            VFS支持的4个主要的数据结构
                superblock   操作超级块
                dentry       操作目录项，方便目录操作及路径遍历
                    该数据结构在文件系统运行过程中创建
                    目录项缓存在dentry_cache中
                inode        操作特定文件
                file         操作打开的文件，如读、写、锁定等，
                    file数据结构是一个打开文件在内存中的表示，在调用open系统调用时被创建
                这四个VFS对象内部的 operations数据结构 的元素，都是指向底层文件系统函数的指针
        ext2文件系统
            磁盘：  引导块  块组0   块组1   块组2   块组3   。。。
            ext2存放于某个块组中，如块组2
            块组2： 超级块  组描述符  块位图  i节点位图   i节点   数据库
            ● 超级块
                包含了该文件系统的信息，包i节点的个数、磁盘块数、
                空闲链表的起始位置。
            ● 组描述符
                存放位图的位置、空闲块数、组中的i节点数、目录数等信息
            ● 块位图
                记录空闲块，本身占用一整个块
                例如块大小是1K，则块位图能标记1024*8=8192个块的使用情况
            ● i节点位图
                记录空闲节点，本身占用一整个块
                例如块大小是1K，则i节点位图能标记最多1024*8=8192个i节点的使用情况
            ● i节点区
                每个i节点占128字节，编号从1开始
                存放了文件的大小、读写执行模式、用户id、组id、创建/修改/访问时间、
                相应数据存放的磁盘块位置等等。
                该表中有12个指针记录直接(0级)磁盘块的位置，
                如果文件占用的磁盘空间不大于12个磁盘块的话，用着12个指针记录就够了。
                该表中还有1个一级磁盘块指针，
                这个指针指向的磁盘块中，记录了一个指针数组，每个元素记录了一个磁盘块号
                假设一个磁盘块的大小是1K，磁盘地址长度为4字节，
                则一个磁盘块可以存放1024/4=256个磁盘地址，
                则在这种假设下，可以记录一个小于256+12=268k的文件，
                该表中还有1个二级磁盘块指针，
                这个指针指向的磁盘块中，记录了一个指针数组，每个指针指向一个磁盘块地址，
                每个地址指向的磁盘块中，又是存放了一个指针数组，每个元素记录一个磁盘块号
                还是像上面一样假设磁盘块大小是1k，则1*256*256=65536k=64M的文件可以被索引
                该表中还有1个三级磁盘块指针，
                还是假设一个磁盘块大小为1k，则1*256*256*256=16G的文件可以被索引。
                如果假设一个磁盘块大小为8k，则一个磁盘块中可以存放8k/4=2k个磁盘块指针，
                在这种假设下，一个1*2k*2k*2k*8k=64TB的文件可以被索引。
            ● 数据块区
                所有的文件及目录（目录本质也是文件，也对应某个i节点）的存放位置
                如果文件大的在一个块上放不下，支持放在多个不连续的块上
            目录文件
                目录存放在整数个磁盘块中
                在一个目录文件中记录的子文件和子目录项是未排序的
                目录文件的格式
                    struct 目录文件
                        struct 目录项 []
                            i节点号
                            目录项大小
                            文件类型
                            文件名长度
                            文件名（\0结束，32字节对齐）
                            额外的填充
                    具体参看书本446页
                    目录文件中的各目录项原本是一个紧跟着一个，连续排列的
                    如果删了某个子文件，则目录文件中的相应目录项也要随之删除
                    删除该目录项后空出的位置，并入到前一目录中（额外的填充）
                    并修改前一目录项的目录项大小
                检索目录文件
                    在目录文件中检索某个子文件（检索目录项）时，是顺序查找的，
                    这相当费时（一个目录中可能有成百上千个子文件，而且可能有多级目录），
                    所以系统会对近期访问的目录维护一个缓存，
                    该缓存的目录通过文件名进行索引，如果命中，就可以避免费时的查找工作
                    当前目录及每级父目录，都会保存一个dentry对象（VFS支持）
            内核i节点表
                另外，内核中还会维护一个i节点表，为了与磁盘上的i节点区域相区分，
                以后称为内核节点表，内核i节点表是一个内核数据结构，用于保存当前打开
                的文件/目录的i节点，内核i节点表项中，至少要包含stat方法展示的相关
                文件属性信息，如文件属于id、文件组id、文件大小、文件类型、保护位、
                最近访问/修改时间、最近改变i节点的时间等等，具体参书本447页。
            文件描述符数组
                提供了通过文件描述符，索引到内核i节点表相应表项的功能
                这个数据结构是进程独有的，随着相应进程的结束而消亡
                进程控制项（PCB）中会有指针指向它
                一个进程打开了几个文件，这个表就有几个表项
                该数组的结构很简单，每一条就记录一个fd（文件描述符）和其对应的
                指向下面打开文件描述符表中某一项的指针。
                默认（如果没有重定向过）这个数组的第0项为标准输入，
                第1项为标准输出，第2项为标准错误。
                使用dup时，也会增加一个表项。
                使用dup2时，如果目标fd存在时，就改写目标描述符的指向，
                使其与源fd的指向一致，如果不存在，就复制源描述符为目标描述符，
                所以dup2与dup相比，不但能复制fd，还能覆盖fd。
                我们常使用类似下面这样的语句：
                int fd = open("a.txt",O_RW,0644);
                dup2(fd,1);
                close(fd);
                这样，就把标准输出重定向到文件了。
                在close(fd)时，只会删除文件描述符中fd对应的表项，
                而不会删除打开文件描述符表中对应的表项，这是因为此时描述符1也指向它。
            打开文件描述符表
                为什么需要有这样一个表
                    通过上面的文件描述符数组，索引内核i节点表时，存在如下的问题：
                    当前进程打开文件时，文件的当前读写位置应该记录在哪里？
                    如果记录在内核i节点表中，因为这个表不是进程自有的，而是共享的，
                    这意味着两个不相关进程打开同一个文件时，将共享同一读写位置，
                    这是不合理的。
                    如果记录文件描述符数组中，这个数组倒是每个进程各有一份，
                    但考虑如下情况：一个脚本文件中有两条带输出指令，然后执行脚本，
                    将输出重定位到某个文件。执行shell脚本是一个进程，
                    执行脚本中的2条带输出的命令，分别是2个子进程，
                    第一个执行第一个命令的子进程把输出信息写到输出流（重定位成文件）中
                    然后读写位置记录在该进程的文件描述符数组中，
                    然后第一条命令的子进程执行结束，子进程的文件描述符数组随之销毁
                    第二条命令的子进程不会知道第一条命令子进程的最后书写位置，
                    所以它将输出信息打印到输出流（重定位成文件）时，也是从文件开始位置0
                    进行输出的，这将覆盖第一条命令子进程输出到文件中的数据信息。
                    综上可知，这个保存文件的位置，既不能是像内核i节点表这样，
                    各无关进程共享的位置，也不能是像文件描述符数组这样的，
                    各进程（即使是相关进程，如父子进程）完全自有的位置。
                    而是需要放在一个只在相关进程，如父子进程间共享的位置。
                    而打开文件描述符表，就是这样的一个位置
                该表可以认为处于文件描述符表和i节点表之间，只在相关进程间共享
                仍以上面的shell脚本为例，指令命令1时，子进程1的用户结构（包括文件描述符表）
                是shell父进程的用户结构的一个副本，因此两者都指向同一个打开文件描述符表的表项
                进程1结束后，执行第2条指令时，它也得到shell父进程用户结构的副本，
                因此也是与父进程一样，指向同一个打开文件描述符表的表项，
                该表项中记录了进程1最后的写位置，所以进程2可以在此位置之后继续写。
                打开文件描述符表中，除了存放当前文件的读写位置之外，还记录了这个文件的
                打开读写标记（标记以只读方式打开的，还是以读写方式的等），而且还存放了
                指向内核i节点表相应表项的指针，是的，这个指针没有放在文件描述符数组中，
                而是放在这个数组中。
        ext3文件系统
            一个文件如果1个磁盘块放不下，需要存在多个磁盘块上时，
            这些磁盘块不一定是连续的，对于这样的情况，
            必须在写完这个磁盘块时，然后移动磁头寻道到下一个可用磁盘块
            这个时间是最费时的地方，因此，对文件的改动，系统通常只是
            将之记录在内存中，而不会立即（甚至30秒内都不会）写入到磁盘上
            所以如果系统一旦断电，这些操作都将丢失了，
            再入正在进行一个非常大文件的复制，我们花了几分钟复制到
            快末尾了，然后系统突然断电了，则可能会出现比较严重的磁盘错误
            ext3文件系统就是为了增强文件系统的健壮性而改进出来的，
            它与ext2文件系统完全兼容，但增加了日志功能，
            该日志顺序记录了所有的文件系统操作，日志数据总是顺序写入到
            一块连续的磁盘空间中，所有不必忍受磁头移动带来的时间开销。
            最后，这些记录在日志中的文件操作，将在合适的时机被执行，
            而成功执行过的日志项将被丢弃，这样，系统崩溃或断点时，
            系统将在重启后，仍可继续执行日志记录所描述的文件系统改动。
            日志是一个环形缓冲器形式组织的文件，
            日志可以存放在主文件系统所在的设备上，也可以存储在其它设备上。
        ext4文件系统
            ext4与ext3完全兼容，但支持更大的文件系统、更大的单个文件、
            支持无限数目的子目录（ext3只支持最多32000个）
            如果文件数据，有一段是放在从100到200的连续100个磁盘块中，
            按ext3的方法，则需要有100个地址记录这100个磁盘块的位置，
            在ext4中改进了这种愚蠢的记录方法，只需记录开始的磁盘块号
            以及后面连续的磁盘块个数即可。
            ext3的数据块分配器一次只能分配一个磁盘块，
            如果写一个需要占用1000个磁盘块的文件，则需要调用1000次分配器，
            而ext4的多块分配器，可以一次调用分配多个数据块。
            ext4增加了日志校验功能，可以判断日志数据是否损坏。
            ext4允许关闭日志功能（日志功能总归有一些开销）。
            ext4的inode占用更多字节，可以容纳更多的属性（如纳秒级的时间戳等）
            此处之外ext4还增加了不少特性，近一步增强了文件系统的性能。
    Linux 安装时，各个分区的作用是什么？ 
        https://www.zhihu.com/question/454655784
        一般来说，你应该准备起码三个区
        第一个区是/boot分区
            大约200~500M就够用了。它的作用是安装grub、存放Linux kernel以及initrd映像。
            这些都是启动时必需的东西，单独存在boot区便于管理
        第二个区是swap分区
            这是因为Linux的swap分区格式为内存交换做过专门优化
            不设swap分区也行，或者指定主分区上的一个文件也行，
            但性能方面都比不过专门的swap分区
            这个区建议使用最快的硬盘（但如果用SSD的话，最好选用MLC甚至SLC，
            不然内存不足时读写量太大，容易把SSD写废）
            这个分区的大小一般建议和你机器上安装的内存大小相当。
            当然你设置的更大/更小也可以。
        第三个区就是/分区
            这里安装了Linux系统以及你自己的用户文件，
            请把你硬盘上的剩余空间都留给它。
            当然，如果你想搞的更细致的话，
            也可以分出10~50G安装Linux（以及其它应用），
            把它挂载到/；剩下的所有空间挂载到/home
            这样可以把Linux系统文件和你的用户文件分开，
            将来换其它版本的Linux也不会影响你自己的数据。
    POSIX
        ● 参：https://zhuanlan.zhihu.com/p/392588996
        POSIX：可移植操作系统接口（Portable Operating System Interface of UNIX）
        POSIX是IEEE为要在各种UNIX操作系统上运行的软件而定义的一系列API标准的总称
        有了这个规范，你就可以调用通用的API了，Linux提供的POSIX系统调用在Unix上也能执行，
        因此学习Linux的底层接口最好就是理解POSIX标准
        Windows从WinNT开始就有兼容POSIX的考虑，
        这为了把Unix用户拉到Windows阵营，被迫支持POSIX
        现在Win10对 Linux/POSIX 支持好，则是因为Linux已经统治了廉价服务器市场。
        为了提高Windows的竞争力搞的。
        POSIX 标准的制定最后投票敲定阶段大概是 1991~1993 年间，
        而此时正是Linux 刚刚起步的时候，这个 UNIX 标准为 Linux 提供了极为重要的信息，
        使得 Linux 能够在标准的指导下进行开发，并能够与绝大多数 UNIX 操作系统兼容。
        Linux下对文件操作有两种方式：
            系统调用（system call）和库函数调用（Library functions）
            系统调用是通向操作系统本身的接口，是面向底层硬件的
            通过系统调用，可以使得用户态运行的进程与硬件设备(如CPU、磁盘、打印机等)
            进行交互，是操作系统留给应用程序的一个接口。
            库函数（Library function）是把函数放到库里，供别人使用的一种方式
            glibc 是 Linux 下使用的开源的标准 C 库，它是 GNU 发布的 libc 库，即运行时库。
            这些基本函数都是被标准化了的，而且这些函数通常都是用汇编直接实现的。
            glibc 为程序员提供丰富的 API（Application Programming Interface），
            这些API都是遵循POSIX标准的，API的函数名，返回值，参数类型等
            都必须按照POSIX标准来定义
            区别：
                1. 库函数是语言或应用程序的一部分，
                而系统调用是内核提供给应用程序的接口，属于系统的一部分
                2. 库函数在用户地址空间执行，系统调用是在内核地址空间执行，
                库函数运行时间属于用户时间，系统调用属于系统时间，
                库函数开销较小，系统调用开销较大
                3. 系统调用依赖于平台，库函数并不依赖
                4. 库函数内部可能进行系统调用，如print，它会调用C库的write，
                并继而调用内核的write，也可能不使用系统调用，如strlen、memcpy等
        借助strace命令，我们可以知道一个程序在执行时都进行了哪些系统调用
            参： https://www.cnblogs.com/machangwei-8/p/10388883.html
            strace有两种使用模式
            直接运行模式
                在原本的命令前加上strace即可，如 strace a.out
            附加运行模式
                跟踪已经在运行的进程，在不中断进程执行的情况下，理解它在干嘛
                给strace传递个-p pid 选项即可
                使用 pidof some_server，获得程序的pid，然后 strace -p pid号
                完成跟踪时，按ctrl + C 结束strace即可
            strace有一些选项可以调整其行为，如下是一些常用选项：
                -tt 在每行输出的前面，显示毫秒级别的时间
                -T 显示每次系统调用所花费的时间
                -v 对于某些相关调用，把完整的环境变量，文件stat结构等打出来。
                -f 跟踪目标进程，以及目标进程创建的所有子进程
                -e 控制要跟踪的事件和跟踪行为,比如指定要跟踪的系统调用名称
                    要跟踪某个具体的系统调用，-e trace=xxx即可
                    注意这里的xxx，指的是某个具体系统调用的名称，
                    而不是某个库函数的名称，如我们知道创建进程使用的是fork系统调用
                    但在glibc里面，fork的调用实际上映射到了更底层的clone系统调用，
                    使用strace时，得指定-e trace=clone, 
                    指定-e trace=fork什么也匹配不上。
                    但有时候我们要跟踪一类系统调用，
                    比如所有和文件名有关的调用、所有和内存分配有关的调用
                    如果人工输入每一个具体的系统调用名称，可能容易遗漏。
                    于是strace提供了几类常用的系统调用组合名字：
                    -e trace=file     跟踪和文件访问相关的调用(参数中有文件名)
                    -e trace=process  和进程管理相关的调用，比如fork/exec/exit_group
                    -e trace=network  和网络通信相关的调用，比如socket/sendto/connect
                    -e trace=signal   信号发送和处理相关，比如kill/sigaction
                    -e trace=desc     和文件描述符相关，比如write/read/select/epoll等
                    -e trace=ipc      进程见同学相关，比如shmget等
                -o 把strace的输出单独写到指定的文件
                -s 当系统调用的某个参数是字符串时，最多输出指定长度的内容，默认32字节
                -p 指定要跟踪的进程pid, 要同时跟踪多个pid, 重复多次-p选项即可。
                实例：跟踪nginx, 看其启动时都访问了哪些文件
                    strace -tt -T -f -e trace=file -o /tmp/strace.log -s 1024 ./nginx
                    这里的输出只显示和文件访问有关的内容，
                    这是因为我们通过-e trace=file 选项指定了
        Linux内核目前有300多个系统调用，详细的列表可以通过syscalls手册页查看
        这些系统调用主要分为几类：
            文件和设备访问类 比如open/close/read/write/chmod等
            进程管理类 fork/clone/execve/exit/getpid等
            信号类 signal/sigaction/kill 等
            内存管理 brk/mmap/mlock等
            进程间通信IPC shmget/semget * 信号量，共享内存，消息队列等
            网络通信 socket/connect/sendto/sendmsg 等
            其他
        libc、glibc、posix
            ● 参：https://blog.csdn.net/weixin_44395686/article/details/104904172
            libc
                C 标准函数库（C standard library，缩写：libc）
                标准函数库通常会随附在编译器上，是最基本的C函数库
                ANSI C共包括15个头文件，1995年批准了3个头文件增加到C标准函数库中，
                C99标准增加了6个头文件，C11标准中又新增了5个头文件
                至此，C标准函数库共有29个头文件
            posix
                明定了一个可移植的操作系统所应具备的种种条件，
                其范围不只有系统函数库而已
                POSIX库 就是 C POSIX library。
                C POSIX library是C语言的POSIX系统下的标准库
                包含了一些在C语言标准库之外的函数
                为了OS之间的可移植性，POSIX标准规定了一些标准的接口。
                而这些接口标准的集合就是POSIX库。
            glibc
                GNU C库（英语：GNU C Library，常简称为glibc）
                按照LGPL许可协议发布的，公开源代码的函数库
                既包含C标准库，也包含POSIX库
                glibc本身是GNU旗下的C标准库，后来逐渐成为了Linux的标准c库
                glibc在/lib目录下的.so文件为libc.so.6
                glibc库不但包含标准C库的所有头文件，
                还包含了所有POSIX库的头文件。
第十一章 实例研究2：Windows
    NT系统
        WindowsNT操作系统的各个层次
            参：file://WindowsNT操作系统的各个层次.jpg
            内核层
                从图中可以看到，HAL层为上层提供的统一的硬件访问接口，如cpu、内存、io的访问
                然后上面是内核模块(ntoskrnl.exe)，它与各种驱动，共同组成了NTOS的内核层
            ntdll.dll
                处于用户态程序最基础层的是 ntdll.dll
                它描述了windows本地NTAPI的接口，当Windows启动时，
                ntdll.dll就驻留在内存中特定的写保护区域，使别的程序无法占用这个内存区域。
                打开NTDLL.dll,发现CRT的许多基本函数都是在这里实现的
                包括qsort,ceil这样的函数，还有strcpy堆的释放，进程管理，似乎都是在ntdll中实现。
                ntdll.dll中的大部分函数都是在MSDN中找不到描述的，
                因为这些函数介于Windows API与内核API之间，微软并未公开全部的内核函数
            环境子系统
                从图中可以看到，在用户态，有个子系统进程(csrss)
                其实这涉及到了NT子系统的概念
                一个NT子系统，只是一个主观上的概念，在系统中并没有一个独立的实体
                一个NT子系统包括四个部分：
                    1. 首先要有一个子系统进程
                       一个子系统进程是一个通过smss.exe启动的csrss.exe服务程序，
                       smss的全称是Session Manager Subsystem，
                       这是一个会话管理子系统，负责启动用户会话（子系统）
                       csrss的全称是client/server runtime server subsystem,
                       它调用了三个动态库：
                            WINSRV.DLL 最基本的dll, 提供包括管理控制台窗口等功能
                            CSRSRV.DLL 进程,线程维护, 调试
                            BASESRV.DLL 负责安全和登录
                       它响应来自用户程序的createprocess请求和
                       该子系统所提供的各种API的请求。
                       我们看进程管理器，可能有多个csrss.exe进程，
                       他们有不同的会话id，说明系统启动了多个会话子系统
                       每个进程都有一个会话id，表中该进程属于哪个会话（子系统）的
                       如果发现某个csrss.exe不是在system32下，那你电脑就是中毒了。
                    2. 一个createprocess钩子
                       这其实是跟第一点相照应的，正是通过钩子方法，
                       来接管（拦截）用户的创建进行操作
                       接管创建进程操作，是子系统实现进程管理的前提
                    3. 该子系统使用的，以及供子系统中程序使用的动态库
                    3. 该子系统所依赖的内核支持
                       除了基本的内核模块外，Windows子系统还有一个专门的内核模块, 
                       它工作在内核之中, Win32K.sys
                       提供GDI、 窗口绘制、USER 用户输入
                环境子系统向应用程序提供环境和应用程序编程接口
                Windows 2000/XP支持三种环境子系统：Win32、POSIX和OS/2
                用户应用程序调用系统服务时必须通过一个或多个子系统动态链接库作为中介才可以完成
                Win32 子系统提供 Win32 API 。
                符合 Win32 API 的应用程序可以不加修改地运行在所有32位平台上
    11.3 系统结构
        参：file://WindowsNT内核态组织结构.jpg
        下面对图中的硬件抽象层、NTOS、设备驱动等进行了分别介绍，
        组织顺序是按照依赖关系排布的，
        学习时，建议先看硬件抽象层，再看NTOS，最后看设备驱动
        设备驱动程序
            Windows中的设备驱动程序的动态库，是由NTOS装载的
            文件系统作为驱动程序被加载
            网络协议页作为使用IO模型的驱动被装载起来
        由上图可见，NTOS系统内核包括两层
            执行体层
                对应ntoskrnl.exe程序
                该层建立在HAL（硬件抽象层）之上，与各种驱动同层
                提供进程线程、虚拟内存、I/O管理、高速缓存管理、LPC、对象管理器等各种基础功能
                执行体层是用C语言编写的，经过少量的修改，就可移植到新的处理器上，如MIPS
                执行体的每个组件的数据接口和接口，有内部和外部之分。
                每个组件的内部方法是隐藏的，只有组件自己可以调用，而外部方法可以由执行体的其他组件调用
                ntoskrnl.exe提供了这些组件外部接口的一个子集，驱动程序可以像动态库一样调用它
                每个内部组件（微软称其为管理器）管理操作系统的一部分，如IO、内存、进程、对象等
                对象管理器
                    管理在执行体中使用的大部分内核态对象，包括进程、线程、文件、信号、IO设备及驱动、
                    定时器等。注意，这里的内核态对象，跟c++中的对象意义不同，这里仅仅是内核分配和
                    使用的数据结构。对象管理器负责管理这些对像内存分配与释放、支持通过句柄访问对象、
                    为内核态指针引用保留引用计数、在NT名字空间给对象命名、管理对象声明周期等。
                    其它数据结构，如内核层使用的控制对象类，则不归对象管理器管理。
                IO管理器
                    为实现IO设备驱动提供了一个框架，同时还为设备上的配置、访问和完成操作，提供一些
                    特定的服务。
                    新的Windows支持运行在用户态上的设备驱动，因为设备驱动运行在内核态时，如果驱动
                    出现bug，将引起整个系统的崩溃。
                    IO管理器还包括即插即用部件和电源管理部件。
                    当新设备在系统中检测到时，即插即用部件开始工作，
                    该即插即用设备的子模块首先被通知，它与服务一起工作，即，用户态的即插即用管理器，
                    找到适当的设备驱动并加载到系统中。
                    电源管理能降低能源消耗。
                进程管理器
                    进程管理器管理进程、线程的创建和终止（但进程的调度、同步等，则由核心层管理）。
                内存管理器
                    实现了虚拟内存的分页机制，它负责管理虚拟内存映射到物理页帧、管理现有的物理帧、
                    和使用备份管理磁盘上的页面文件。
                缓存管理器
                    优化IO的性能、管理页面缓存
                安全引用监视器
                    执行Windows的详细的安全机制，以支持计算机安全标准。
                    这个标准规范了一个符合要求的系统应该满足哪些规则，如登录验证、审核等。
                配置管理器
                    实现了注册表功能
                    注册表实质是一种称为“蜂巢”的文件系统文件，它包含了系统的配置数据
                    最关键的蜂巢是SYSTEM蜂巢，它在启动时被加载到内存中
            内核层
                该层的实现，建立在执行体层之上
                它实现了从用户态到内核态转换的陷入和中断机制。
                提供了一套管理CPU的抽象，最核心的抽象是线程，但也实现了异常处理、陷阱及各种中断。
                线程调度
                    线程数据结构的创建和终止功能，是在执行体实现的，而这一层负责调度和同步线程
                    内核线程调度程序负责决定哪些线程执行在系统的每一个CPU上。
                    当一个线程因为定时器的中断（时间片到）或是要等待资源，或者来了更高优先级的线程，
                    而需要进行线程切换时，调度程序会先在cpu上运行，请确保寄存器和其他硬件状态已保存，
                    然后调度程序将选中的线程放到CPU上运行，并根据需要回复这个选中线程之前的运行状态。
                    注意，调度的线程，可能是同一进程的，也可能是不同进程的。
                线程同步机制
                    控制对象类
                        包括线程、中断、定时器、同步、调试等原语对象，
                        以及用来实现DPC（Deferred Procedure Call，延迟过程调用）和
                        APC（asynchronous procedure call，异步过程调用）的两个特殊对象。
                            DPC对象用来减少执行中断服务例程所需要的时间的，
                            原理是让中断分为不同的优先级，而DPC对象用以表示将要做的中断服务工作
                    调度对象类
                        这是常用的内核对象，它包含一个dispatcher_header结构，
                        信号器、互斥体、事件、可等待定时器、其它一些可等待其他线程同步执行的对象等
                        这些都属于调度对象，另外，表示打开文件的对象、进程对象、线程对象、IPC端口等
                        这也也属于调度对象。
                        调度数据结构包含了表示对象'状态'的标志和等待(该被标记对象)的线程队列。
                        同步原语（如信号器）是标准的调度对象。   
        硬件抽象层
            可以注意到硬件抽象层还对BIOS进行了抽象，因为不同厂家的BIOS也有差异
            但HAL不对键盘、鼠标、硬盘等特殊的I/O设备及内存管理单元提供抽象服务
            HAL的功能举例
                1. 
                    以操作IO设备为例，IO设备分为内存映射和端口I/O端口两种访问方式，
                    有些机器上可能只提供IO映射这种方式，也有的机器上可能只提供内存映射这种方式，
                    那驱动程序该使用哪种方式访问其对应的设备呢？HAL对此提供了一致的访问方式：
                        uc = READ_PORT_ UCHAR(port);
                        us = READ_PORT_USHORT(port);
                        ul = READ_ PORT_ULONG(port);
                        WRITE_PORT_UCHAR(port, uc);
                        WRITE_PORT_USHORT(port, us);
                        WRITE_PORT_ LONG(port, ul);
                    然后由HAL层最终决定使用哪种方式，这样，驱动程序在上面两种机器上就都适用了。
                2.
                    再考虑另一个问题：一个计算机中可能有多种总线，如pci、pci-x、isa、usb、1394等，
                    每种总线都各有一套地址空间，于是不同总线上的设备，就可能使用相同的地址，
                    HAL在此时就发挥了它的功能，它把总线相关的设备地址，映射为系统逻辑地址，
                    于是所有在不同总线上的设备，都有了唯一的逻辑地址，而驱动程序也不用关心设备是
                    挂在哪种总线上的，只需要直接使用该设备的逻辑地址进行访问即可。
                3.
                    和例2类似，不同总线上的设备，产生中断时，发出的也是相对于本种总线上的地址，
                    通过HAL提供的服务，使得可以在系统范围内命名中断，并允许驱动程序将中断相应程序
                    附着到中断上，而无需知道中断向量与总线的关系。
                    另外对中断请求的管理，也是由HAL控制的。
                4.  
                    HAL还负责建立和管理DMA转换，对系统范围的DMA引擎和IO卡上的DMA引擎进行控制。
                5. 
                    HAL提供通用的方式来管理系统时钟和定时器
                6.  
                    HAL还提供自旋锁功能，用以在底层支持内核部件的同步
                7.  
                    系统被引导后，HAL会和BIOS进行通信，检查系统配置信息以查明系统中都包含哪些总线、
                    各种IO设备及其配置情况，同时把这些信息记录到注册表中
        11.3.2 启动Vista
            电脑打开时，cpu初始化硬件，然后开始执行内存中的一个程序
            在大多数pc机中，最初的初始化程序是bios
    11.7 输入/输出
    11.8 NTFS文件系统
        