#include <sdf.h>
#include <sdf_type.h>
#include <stdio.h>
#include <string.h>
#include <time.h>
#include <malloc.h>
#include <pthread.h>
#include <semaphore.h>

u32 SM1_CFB_Test(void *hSessionHandle)
{
	u8 key[] = {
		/* KEY 1 for ecb/cfb key256 */
		0x40,0xbb,0x12,0xdd,0x6a,0x82,0x73,0x86,0x7f,0x35,0x29,0xd3,0x54,0xb4,0xa0,0x26,
		0x0c,0x90,0xe1,0x5a,0x4f,0x92,0x36,0xb2,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
	};

	u8 iv[] = {
		/* IV 1 for key 1 */
		0x12,0x15,0x35,0x24,0xc0,0x89,0x5e,0x81,0x84,0x84,0xd6,0x09,0xb1,0xf0,0x56,0x63
	};

	 u8 data[] = {
		/* DATA 1 for ecb key256 */
		0x12,0x15,0x35,0x24,0xc0,0x89,0x5e,0x81,0x84,0x84,0xd6,0x09,0xb1,0xf0,0x56,0x63,
		/* DATA 2 for CFB key256 */
		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
	};	

	u8 stddata[] = {
		/* STD OUT 1 for ecb/cfb key256 */
		0x8f,0x8f,0x4b,0x94,0xe6,0xfa,0xbf,0x80,0x11,0xaf,0x39,0x04,0x54,0xfc,0x9e,0xf7,

		0xd8,0xbc,0x67,0x3c,0xcd,0x32,0x4a,0x7b,0xca,0x5d,0x7e,0xa8,0x9d,0xd4,0x52,0x94,
		/* STD OUT 1 for ecb key384 */
		0x93,0x0c,0x3f,0xe6,0xad,0x59,0x88,0xe5,0x32,0x08,0x0b,0x06,0xfd,0xda,0xac,0x13,
		/*STD OUT 1 for ofb key256*/
		0x8f,0x8f,0x4b,0x94,0xe6,0xfa,0xbf,0x80,0x11,0xaf,0x39,0x04,0x54,0xfc,0x9e,0xf7,
		0xd8,0xbc,0x67,0x3c,0xcd,0x32,0x4a,0x7b,0xca,0x5d,0x7e,0xa8,0x9d,0xd4,0x52,0x94

	};
	
	u32 r;	
	void *hKey;
	unsigned int enclen = 0;
	unsigned char encdata[64] = {0};
	unsigned int declen = 0;
	unsigned char decdata[64] = {0};	
	unsigned char tempIV[16];

	r = EVDF_SetKey(hSessionHandle, key, 32, &hKey);
	if(r)
	{
		printf("import session key fail:%x\n", r);
		return r;	
	}

	memcpy(tempIV, iv, 16);
	r = SDF_Encrypt(hSessionHandle, hKey, SGD_SM1_CFB, tempIV, data+16, 32, encdata, &enclen);
	if(r)
	{
		printf("encrypt data fail:%x\n", r);
		return r;
	}
#if 0
	printf("enclen %d\n", enclen);
	print_data("encrypt data:", encdata, enclen);
#endif	
	if((enclen != 32) || memcmp(encdata, stddata, 32))
	{
		printf("%s()-enc data != std data\n", __func__);
		return 1;
	}

	memcpy(tempIV, iv, 16);
	r = SDF_Decrypt(hSessionHandle, hKey, SGD_SM1_CFB, tempIV, encdata, enclen, decdata, &declen);
	if(r)
	{
		printf("decrypt data fail:%x\n", r);
		return r;
	}	
	if((declen != 32) || memcmp(decdata, data+16, 32))
	{
		printf("%s()-src data != dec data\n", __func__);
		return 1;
	}
	
	
	r = SDF_DestroyKey(hSessionHandle, hKey);
	if(r)
	{
		printf("destroy session key fail:%x\n", r);
		free(encdata);
		return r;
	} 
	
	printf("%s() - success\n", __func__);
	return 0;	
	
}


u32 SM1_OFB_Test(void *hSessionHandle)
{
	u8 key[] = {
		/* KEY 1 for ecb/cfb key256 */
		0x40,0xbb,0x12,0xdd,0x6a,0x82,0x73,0x86,0x7f,0x35,0x29,0xd3,0x54,0xb4,0xa0,0x26,
		0x0c,0x90,0xe1,0x5a,0x4f,0x92,0x36,0xb2,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
	};

	u8 iv[] = {
		/* IV 1 for key 1 */
		0x12,0x15,0x35,0x24,0xc0,0x89,0x5e,0x81,0x84,0x84,0xd6,0x09,0xb1,0xf0,0x56,0x63
	};

	 u8 data[] = {
		/* DATA 1 for ecb key256 */
		0x12,0x15,0x35,0x24,0xc0,0x89,0x5e,0x81,0x84,0x84,0xd6,0x09,0xb1,0xf0,0x56,0x63,
		/* DATA 2 for CFB key256 */
		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
	};	

	u8 stddata[] = {
		/* STD OUT 1 for ecb/cfb key256 */
		0x8f,0x8f,0x4b,0x94,0xe6,0xfa,0xbf,0x80,0x11,0xaf,0x39,0x04,0x54,0xfc,0x9e,0xf7,

		0xd8,0xbc,0x67,0x3c,0xcd,0x32,0x4a,0x7b,0xca,0x5d,0x7e,0xa8,0x9d,0xd4,0x52,0x94,
		/* STD OUT 1 for ecb key384 */
		0x93,0x0c,0x3f,0xe6,0xad,0x59,0x88,0xe5,0x32,0x08,0x0b,0x06,0xfd,0xda,0xac,0x13,
		/*STD OUT 1 for ofb key256*/
		0x8f,0x8f,0x4b,0x94,0xe6,0xfa,0xbf,0x80,0x11,0xaf,0x39,0x04,0x54,0xfc,0x9e,0xf7,
		0xd8,0xbc,0x67,0x3c,0xcd,0x32,0x4a,0x7b,0xca,0x5d,0x7e,0xa8,0x9d,0xd4,0x52,0x94

	};
	
	u32 r;	
	void *hKey;
	unsigned int enclen = 0;
	unsigned char encdata[64] = {0};
	unsigned int declen = 0;
	unsigned char decdata[64] = {0};	
	unsigned char tempIV[16];

	r = EVDF_SetKey(hSessionHandle, key, 32, &hKey);
	if(r)
	{
		printf("import session key fail:%x\n", r);
		return r;	
	}

	memcpy(tempIV, iv, 16);
	r = SDF_Encrypt(hSessionHandle, hKey, SGD_SM1_OFB, tempIV, data+16, 32, encdata, &enclen);
	if(r)
	{
		printf("encrypt data fail:%x\n", r);
		return r;
	}
#if 0
	printf("enclen %d\n", enclen);
	print_data("encrypt data:", encdata, enclen);
#endif	
	if((enclen != 32) || memcmp(encdata, stddata+48, 32))
	{
		printf("%s()-enc data != std data\n", __func__);
		return 1;
	}

	memcpy(tempIV, iv, 16);
	r = SDF_Decrypt(hSessionHandle, hKey, SGD_SM1_OFB, tempIV, encdata, enclen, decdata, &declen);
	if(r)
	{
		printf("decrypt data fail:%x\n", r);
		return r;
	}	
	if((declen != 32) || memcmp(decdata, data+16, 32))
	{
		printf("%s()-src data != dec data\n", __func__);
		return 1;
	}
	
	
	r = SDF_DestroyKey(hSessionHandle, hKey);
	if(r)
	{
		printf("destroy session key fail:%x\n", r);
		free(encdata);
		return r;
	} 
	
	printf("%s() - success\n", __func__);
	return 0;	
	
}


u32 SM6_ECB_Test(void *hSessionHandle)
{
	u8 key[] = {
		/* KEY 1 for ecb */
		0x40,0xbb,0x12,0xdd,0x6a,0x82,0x73,0x86,0x7f,0x35,0x29,0xd3,0x54,0xb4,0xa0,0x26,
		0x0c,0x90,0xe1,0x5a,0x4f,0x92,0x36,0xb2,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
		/* KEY 2 for cbc */
		0x40,0xbb,0x12,0xdd,0x6a,0x82,0x73,0x86,0x7f,0x35,0x29,0xd3,0x54,0xb4,0xa0,0x26,
		0x0c,0x90,0xe1,0x5a,0x4f,0x92,0x36,0xb2,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
		0xa2,0x91,0xb3,0xeb,0xa4,0xed,0x22,0x5f,0x1c,0xea,0xa6,0x07,0x62,0x8f,0xb2,0x36,
	};

	 u8 data[] = {
		/* DATA 1 for ecb test(128bit)*/
		0xff,0xee,0xdd,0xcc,0xbb,0xaa,0x99,0x88,0x77,0x66,0x55,0x44,0x33,0x22,0x11,0x00,
		/* DATA 1 for ecb key384*/
		0x12,0x15,0x35,0x24,0xc0,0x89,0x5e,0x81,0x84,0x84,0xd6,0x09,0xb1,0xf0,0x56,0x63,
		/* DATA 1/DATA2 for ecb key256,cbc key256/key384*/
		0x06,0xb9,0x7b,0x0d,0x46,0xdf,0x99,0x8d,0xb2,0xc2,0x84,0x65,0x89,0x37,0x52,0x12,
		0x00,0xf3,0xe3,0x01,0x06,0xd7,0xcd,0x0d,0x3b,0x23,0xf1,0x76,0x1e,0x8d,0xcd,0x3d,
	};	

	u8 stddata[] = {
		/* STD OUT 1 for ecb test*/
		0xed,0xd5,0x18,0x48,0xb6,0xde,0x03,0xfd,0x3f,0xf3,0x0d,0xfe,0xcc,0x8d,0xb8,0x1b,
		/* STD OUT 1 for ecb key384 */
		0x93,0x0c,0x3f,0xe6,0xad,0x59,0x88,0xe5,0x32,0x08,0x0b,0x06,0xfd,0xda,0xac,0x13,
		/* STD OUT 1 for ecb key256 */
		0xee,0x34,0xf8,0x9d,0x7d,0x95,0xdf,0x93,0xdb,0x85,0xa3,0x29,0x17,0x49,0x5c,0xd1,
		/* STD OUT 2 for cbc key256 */
		0x1a,0x10,0x1b,0xae,0xaa,0x65,0xa5,0xe2,0xdb,0x08,0x5a,0xa5,0x59,0xf3,0x94,0x66,
		0x88,0x4b,0xc3,0xf6,0x2c,0x84,0x25,0x52,0x58,0x6f,0x7d,0xd3,0xaa,0x31,0x1b,0x2c,
		/* STD OUT 2 for cbc key384 */
		0x9e,0x68,0xca,0x02,0xe0,0x93,0xf0,0x31,0x98,0xfc,0xee,0xed,0x64,0xac,0x3d,0x7a,
		0x7e,0x77,0x4e,0x6d,0x1b,0xbf,0xf0,0xfc,0x00,0xc8,0xf3,0x24,0x21,0x05,0xed,0xb3,

	};
	
	u32 r;	
	void *hKey;
	unsigned int enclen = 0;
	unsigned char encdata[64] = {0};
	unsigned int declen = 0;
	unsigned char decdata[64] = {0};	
	unsigned char tempIV[16];

	r = EVDF_SetKey(hSessionHandle, key, 32, &hKey);
	if(r)
	{
		printf("import session key fail:%x\n", r);
		return r;	
	}

	r = SDF_Encrypt(hSessionHandle, hKey, SGD_SM6_ECB, NULL, data+32, 16, encdata, &enclen);
	if(r)
	{
		printf("encrypt data fail:%x\n", r);
		return r;
	}
#if 0
	printf("enclen %d\n", enclen);
	print_data("encrypt data:", encdata, enclen);
#endif	
	if((enclen != 16) || memcmp(encdata, stddata+32, 16))
	{
		printf("%s()-enc data != std data\n", __func__);
		return 1;
	}

	r = SDF_Decrypt(hSessionHandle, hKey, SGD_SM6_ECB, NULL, encdata, enclen, decdata, &declen);
	if(r)
	{
		printf("decrypt data fail:%x\n", r);
		return r;
	}	
	if((declen != 16) || memcmp(decdata, data+32, 16))
	{
		printf("%s()-src data != dec data\n", __func__);
		return 1;
	}
	
	
	r = SDF_DestroyKey(hSessionHandle, hKey);
	if(r)
	{
		printf("destroy session key fail:%x\n", r);
		free(encdata);
		return r;
	} 
	
	printf("%s() - success\n", __func__);
	return 0;	
	
}


u32 SM6_CBC_Test(void *hSessionHandle)
{
	u8 key[] = {
		/* KEY 1 for ecb */
		0x40,0xbb,0x12,0xdd,0x6a,0x82,0x73,0x86,0x7f,0x35,0x29,0xd3,0x54,0xb4,0xa0,0x26,
		0x0c,0x90,0xe1,0x5a,0x4f,0x92,0x36,0xb2,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
		/* KEY 2 for cbc */
		0x40,0xbb,0x12,0xdd,0x6a,0x82,0x73,0x86,0x7f,0x35,0x29,0xd3,0x54,0xb4,0xa0,0x26,
		0x0c,0x90,0xe1,0x5a,0x4f,0x92,0x36,0xb2,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
		0xa2,0x91,0xb3,0xeb,0xa4,0xed,0x22,0x5f,0x1c,0xea,0xa6,0x07,0x62,0x8f,0xb2,0x36,
	};

	u8 iv[] = {
		/* IV 1 for key 1 */
		0xe8,0x3d,0x17,0x15,0xac,0xf3,0x48,0x63,0xac,0xeb,0x93,0xe0,0xe5,0xab,0x8b,0x90,
	};

	 u8 data[] = {
		/* DATA 1 for ecb test(128bit)*/
		0xff,0xee,0xdd,0xcc,0xbb,0xaa,0x99,0x88,0x77,0x66,0x55,0x44,0x33,0x22,0x11,0x00,
		/* DATA 1 for ecb key384*/
		0x12,0x15,0x35,0x24,0xc0,0x89,0x5e,0x81,0x84,0x84,0xd6,0x09,0xb1,0xf0,0x56,0x63,
		/* DATA 1/DATA2 for ecb key256,cbc key256/key384*/
		0x06,0xb9,0x7b,0x0d,0x46,0xdf,0x99,0x8d,0xb2,0xc2,0x84,0x65,0x89,0x37,0x52,0x12,
		0x00,0xf3,0xe3,0x01,0x06,0xd7,0xcd,0x0d,0x3b,0x23,0xf1,0x76,0x1e,0x8d,0xcd,0x3d,
	};	

	u8 stddata[] = {
		/* STD OUT 1 for ecb test*/
		0xed,0xd5,0x18,0x48,0xb6,0xde,0x03,0xfd,0x3f,0xf3,0x0d,0xfe,0xcc,0x8d,0xb8,0x1b,
		/* STD OUT 1 for ecb key384 */
		0x93,0x0c,0x3f,0xe6,0xad,0x59,0x88,0xe5,0x32,0x08,0x0b,0x06,0xfd,0xda,0xac,0x13,
		/* STD OUT 1 for ecb key256 */
		0xee,0x34,0xf8,0x9d,0x7d,0x95,0xdf,0x93,0xdb,0x85,0xa3,0x29,0x17,0x49,0x5c,0xd1,
		/* STD OUT 2 for cbc key256 */
		0x1a,0x10,0x1b,0xae,0xaa,0x65,0xa5,0xe2,0xdb,0x08,0x5a,0xa5,0x59,0xf3,0x94,0x66,
		0x88,0x4b,0xc3,0xf6,0x2c,0x84,0x25,0x52,0x58,0x6f,0x7d,0xd3,0xaa,0x31,0x1b,0x2c,
		/* STD OUT 2 for cbc key384 */
		0x9e,0x68,0xca,0x02,0xe0,0x93,0xf0,0x31,0x98,0xfc,0xee,0xed,0x64,0xac,0x3d,0x7a,
		0x7e,0x77,0x4e,0x6d,0x1b,0xbf,0xf0,0xfc,0x00,0xc8,0xf3,0x24,0x21,0x05,0xed,0xb3,

	};
	
	u32 r;	
	void *hKey;
	unsigned int enclen = 0;
	unsigned char encdata[64] = {0};
	unsigned int declen = 0;
	unsigned char decdata[64] = {0};	
	unsigned char tempIV[16];

	r = EVDF_SetKey(hSessionHandle, key+48, 32, &hKey);
	if(r)
	{
		printf("import session key fail:%x\n", r);
		return r;	
	}

	memcpy(tempIV, iv, 16);
	r = SDF_Encrypt(hSessionHandle, hKey, SGD_SM6_CBC, tempIV, data+32, 32, encdata, &enclen);
	if(r)
	{
		printf("encrypt data fail:%x\n", r);
		return r;
	}
#if 0
	printf("enclen %d\n", enclen);
	print_data("encrypt data:", encdata, enclen);
#endif	
	if((enclen != 32) || memcmp(encdata, stddata+48, 32))
	{
		printf("%s()-enc data != std data\n", __func__);
		return 1;
	}

	memcpy(tempIV, iv, 16);
	r = SDF_Decrypt(hSessionHandle, hKey, SGD_SM6_CBC, tempIV, encdata, enclen, decdata, &declen);
	if(r)
	{
		printf("decrypt data fail:%x\n", r);
		return r;
	}	
	if((declen != 32) || memcmp(decdata, data+32, 32))
	{
		printf("%s()-src data != dec data\n", __func__);
		return 1;
	}
	
	
	r = SDF_DestroyKey(hSessionHandle, hKey);
	if(r)
	{
		printf("destroy session key fail:%x\n", r);
		free(encdata);
		return r;
	} 
	
	printf("%s() - success\n", __func__);
	return 0;	
	
}



u32 AES_ECB_Test(void *hSessionHandle)
{
	u8 key[] = {
		/* KEY 128 bit */
		0xAF,0x86,0x18,0x23,0x8C,0x94,0xA1,0x19,0xAE,0x6D,0xE9,0x22,0xDB,0xB9,0x35,0x4D,
		/* KEY 192 bit */
		0x9F,0xCE,0xB8,0x96,0x34,0x5C,0xE3,0x7C,0x3F,0xFE,0x54,0xEA,0xD1,0x15,0x28,0xED,
		0x87,0x1D,0x0F,0x6E,0x93,0xCC,0xFD,0x54,
		/* KEY 256 bit */
		0xE3,0x83,0x0F,0x2F,0xF5,0x87,0x7D,0xAD,0x19,0x41,0x75,0x7B,0x17,0xB5,0xE3,0x92,
		0xB5,0x1D,0x7D,0x21,0x15,0xE7,0x0F,0x8B,0x6E,0x93,0x91,0x98,0xEB,0x6F,0xDE,0x4B
	};

	 u8 data[] = {
		/* DATA for 128/192/256 bit ecb */
		0xF7,0xAF,0x83,0xD4,0x98,0x7A,0x94,0x83,0x98,0xEE,0x24,0x8A,0xD8,0xB7,0x09,0x95,
		/* DATA for 128/192/256 bit CTR */
		0x63,0x36,0x3D,0x95,0xAC,0x94,0x46,0x28,0x29,0x2D,0xB1,0x2F,0x6B,0x39,0x37,0x5C,
		0x66,0x17,0x94,0x6A,0xFC,0xC2,0x73,0x14,0xE5,0xA9,0x4B,0x59,0xA1,0x98,0xCC,0x33
	};	

	u8 stddata[] = {
		/* STD OUT for 128 bit ecb */
		0xa9,0x18,0x0e,0x6c,0xf0,0x2c,0x4a,0xad,0xe2,0x57,0x3b,0xc1,0x50,0x9e,0x26,0x41,
		/* STD OUT for 192 bit ecb */
		0x96,0x96,0x4f,0x1f,0x4b,0x3b,0x1e,0x3d,0x70,0xf4,0x6e,0x20,0xad,0xfc,0x1c,0x40,
		/* STD OUT for 256 bit ecb */
		0x3f,0x51,0x8e,0xc6,0x4c,0x33,0xb9,0x33,0x50,0x0e,0xf6,0x45,0x12,0x64,0x8c,0xff
	};
	
	u32 r;	
	void *hKey;
	unsigned int enclen = 0;
	unsigned char encdata[64] = {0};
	unsigned int declen = 0;
	unsigned char decdata[64] = {0};	
	unsigned char tempIV[16];

	r = EVDF_SetKey(hSessionHandle, key, 16, &hKey);
	if(r)
	{
		printf("import session key fail:%x\n", r);
		return r;	
	}

	r = SDF_Encrypt(hSessionHandle, hKey, SGD_AES_ECB, NULL, data, 16, encdata, &enclen);
	if(r)
	{
		printf("encrypt data fail:%x\n", r);
		return r;
	}
#if 0
	printf("enclen %d\n", enclen);
	print_data("encrypt data:", encdata, enclen);
#endif	
	if((enclen != 16) || memcmp(encdata, stddata, 16))
	{
		printf("%s()-enc data != std data\n", __func__);
		return 1;
	}

	r = SDF_Decrypt(hSessionHandle, hKey, SGD_AES_ECB, NULL, encdata, enclen, decdata, &declen);
	if(r)
	{
		printf("decrypt data fail:%x\n", r);
		return r;
	}	
	if((declen != 16) || memcmp(decdata, data, 16))
	{
		printf("%s()-src data != dec data\n", __func__);
		return 1;
	}
	
	
	r = SDF_DestroyKey(hSessionHandle, hKey);
	if(r)
	{
		printf("destroy session key fail:%x\n", r);
		free(encdata);
		return r;
	} 
	
	printf("%s() - success\n", __func__);
	return 0;	
	
}


u32 AES_CBC_Test(void *hSessionHandle)
{
	u8 key[] = {
		/* KEY 128 bit */
		0xAF,0x86,0x18,0x23,0x8C,0x94,0xA1,0x19,0xAE,0x6D,0xE9,0x22,0xDB,0xB9,0x35,0x4D,
		/* KEY 192 bit */
		0x9F,0xCE,0xB8,0x96,0x34,0x5C,0xE3,0x7C,0x3F,0xFE,0x54,0xEA,0xD1,0x15,0x28,0xED,
		0x87,0x1D,0x0F,0x6E,0x93,0xCC,0xFD,0x54,
		/* KEY 256 bit */
		0xE3,0x83,0x0F,0x2F,0xF5,0x87,0x7D,0xAD,0x19,0x41,0x75,0x7B,0x17,0xB5,0xE3,0x92,
		0xB5,0x1D,0x7D,0x21,0x15,0xE7,0x0F,0x8B,0x6E,0x93,0x91,0x98,0xEB,0x6F,0xDE,0x4B
	};

	u8 iv[] = {
		/* IV for 128/192/256 bit CTR */
		0x38,0x32,0xF2,0x7E,0x0A,0x14,0x51,0xAF,0x4B,0x97,0x47,0xA0,0x17,0x7C,0xDF,0xC2
	};

	 u8 data[] = {
		/* DATA for 128/192/256 bit cbc */
		0xF7,0xAF,0x83,0xD4,0x98,0x7A,0x94,0x83,0x98,0xEE,0x24,0x8A,0xD8,0xB7,0x09,0x95,
		0xF7,0xAF,0x83,0xD4,0x98,0x7A,0x94,0x83,0x98,0xEE,0x24,0x8A,0xD8,0xB7,0x09,0x95
	};	

	u8 stddata[] = {
	/* STD OUT for 128 bit cbc */
		0x8c,0x5e,0x5e,0x40,0x97,0x0f,0xa1,0xbc,0x99,0x8b,0xd1,0xd0,0xf8,0xd0,0x5d,0xbd,
		/* STD OUT for 192 bit cbc */
		0x70,0xe5,0xd7,0xae,0xf7,0xac,0xcd,0x22,0x0e,0x57,0xdc,0xdf,0x49,0x31,0xad,0xc9,
		/* STD OUT for 256 bit cbc */
		0xa2,0xc1,0xb5,0x88,0x4a,0x30,0x0e,0x63,0xa5,0xd0,0x40,0x57,0x6f,0xf2,0xbc,0x05,
		/* STD OUT for 128 bit cfb */
	    0xdf,0x9a,0xc2,0xce,0xc3,0xe7,0xd5,0x39,0x25,0x88,0xf5,0x5a,0xaa,0xc2,0xb8,0x5a,
	    0x0c,0x91,0x93,0xd9,0xfc,0x7a,0x03,0xf7,0xa6,0x05,0x6a,0x3d,0x08,0x2e,0x91,0x68,
	    /* STD OUT for 192 bit cfb */
	    0x14,0x4c,0x59,0xac,0xe6,0xee,0x16,0x73,0x5b,0xbb,0xca,0x8d,0xf0,0x24,0x8f,0xdd,
	    0xf9,0x56,0x9a,0x07,0x6d,0xa8,0xed,0xb7,0xe9,0xc0,0x68,0x7f,0x6f,0xcf,0x87,0x82,
	    /* STD OUT for 256 bit cfb */
	    0xfb,0x17,0xb9,0x37,0xbe,0x93,0x06,0x43,0x16,0x47,0x8d,0x48,0x13,0x32,0x90,0xbb,
	    0xf6,0xae,0xad,0xff,0x0b,0xd5,0x8a,0x8f,0x36,0xbf,0x4d,0x15,0x92,0x01,0xee,0x83
	};
	
	u32 r;	
	void *hKey;
	unsigned int enclen = 0;
	unsigned char encdata[64] = {0};
	unsigned int declen = 0;
	unsigned char decdata[64] = {0};	
	unsigned char tempIV[16];

	r = EVDF_SetKey(hSessionHandle, key, 16, &hKey);
	if(r)
	{
		printf("import session key fail:%x\n", r);
		return r;	
	}

	memcpy(tempIV, iv, 16);
	r = SDF_Encrypt(hSessionHandle, hKey, SGD_AES_CBC, tempIV, data, 16, encdata, &enclen);
	if(r)
	{
		printf("encrypt data fail:%x\n", r);
		return r;
	}
#if 0
	printf("enclen %d\n", enclen);
	print_data("encrypt data:", encdata, enclen);
#endif	
	if((enclen != 16) || memcmp(encdata, stddata, 16))
	{
		printf("%s()-enc data != std data\n", __func__);
		return 1;
	}

	memcpy(tempIV, iv, 16);
	r = SDF_Decrypt(hSessionHandle, hKey, SGD_AES_CBC, tempIV, encdata, enclen, decdata, &declen);
	if(r)
	{
		printf("decrypt data fail:%x\n", r);
		return r;
	}	
	if((declen != 16) || memcmp(decdata, data, 16))
	{
		printf("%s()-src data != dec data\n", __func__);
		return 1;
	}
	
	
	r = SDF_DestroyKey(hSessionHandle, hKey);
	if(r)
	{
		printf("destroy session key fail:%x\n", r);
		free(encdata);
		return r;
	} 
	
	printf("%s() - success\n", __func__);
	return 0;	
	
}


u32 Symm_Step_Test(void *hSessionHandle)
{
	int r;
	u32 i = 0;
	u32 j = 0;	
	u32 cnt = 0;
	u8  key[32] = {0};
	u8  temp_iv[16] = {0};
        u8  iv[16] = {0};
	void *hKey;
	u32 ulAlgID;
	u32 ALGID_ARRAY[16] = {SGD_SM1_ECB, SGD_SM1_CBC, SGD_SM1_CFB, SGD_SM1_OFB,
						SGD_SMS4_ECB, SGD_SMS4_CBC,SGD_SMS4_CFB, SGD_SMS4_OFB,
						SGD_SSF33_ECB, SGD_SSF33_CBC,SGD_SSF33_CFB, SGD_SSF33_OFB,
						SGD_SM6_ECB, SGD_SM6_CBC, SGD_SM6_CFB, SGD_SM6_OFB};

	BYTE *src_data = NULL;
	BYTE *enc_data = NULL;
	BYTE *enc_data1 = NULL;	

	u32 enc_datalen;
	u32 dec_datalen;
	u32 datalen;

	srand((unsigned int)time(NULL));
	do{
//		ulAlgID = ALGID_ARRAY[rand()%0x6];
		ulAlgID = ALGID_ARRAY[cnt%16];

		printf("---------------%d(id:%x)---------------\n",cnt++, ulAlgID);
		datalen = 0x100000;
		//datalen  = 0x20;
		if(datalen==0)
			datalen = 16;
		printf("datalen = 0x%x\n",datalen);

		src_data = malloc(datalen);
		enc_data = malloc(datalen);
		enc_data1 = malloc(datalen);

		for(i=0;i<16;i++)
		{
			key[i] = (u8)rand();
			iv[i] = (u8)rand();
		}
		for(i=0;i<datalen;i++)
		{
			src_data[i] = (u8)rand();
			enc_data[i] = 0;
			enc_data1[i] = 0;
		}

		r = EVDF_SetKey(hSessionHandle, key, 16, &hKey);
		if(r)
		{
			printf("import session key fail:%x\n", r);
			return r;	
		}

		memcpy(temp_iv, iv, 16);
		r = SDF_Encrypt(hSessionHandle, hKey, ulAlgID, temp_iv, src_data, datalen/4, enc_data, &enc_datalen);
		if(r)
		{
			printf("encrypt data fail:%x\n", r);
			return r;
		}
		r = SDF_Encrypt(hSessionHandle, hKey, ulAlgID, temp_iv, src_data+datalen/4, datalen-datalen/4, enc_data+datalen/4, &enc_datalen);
		if(r)
		{
			printf("encrypt data fail:%x\n", r);
			return r;
		}


		memcpy(temp_iv, iv, 16);
		r = SDF_Encrypt(hSessionHandle, hKey, ulAlgID, temp_iv, src_data, datalen, enc_data1, &enc_datalen);
		if(r)
		{
			printf("encrypt data fail:%x\n", r);
			return r;
		}	

		r = SDF_DestroyKey(hSessionHandle,hKey);
		if(r)
		{
			printf("destroy session key fail:%x\n", r);
			return r;
		}
		
		printf("enc_datalen :0x%x\n", enc_datalen);
		if((enc_datalen != datalen)||(memcmp(enc_data1, enc_data, datalen)))
		{
			printf("source data != dec data\n");

			return -1;
		}
		else
		{
			printf("%s() - success\n",__func__);	

		}
		
		free(src_data);
		free(enc_data);
		free(enc_data1);
	}while(cnt<0x100);
	
	return 0;	
}