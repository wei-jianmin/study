在win7 64位系统下，32位的dll放在sysWoW64目录下，64为的dll放在system32目录下

sysWoW是system window on window的意思
技术上说, WOW64是由三个DLL实现的：
 Wow64.dll是Windows NT kernel的核心接口, 在32位和64位调用之间进行转换, 包括指针和调用栈的操控；
 Wow64win.dll 为32位应用程序提供合适的入口指针；
 Wow64cpu.dll 负责将处理器在32位和64位的模式之间转换。
可以理解为，sysWoW64是一个兼容用的平台，64为系统借助这个平台，访问32位的dll

重定向：
window64位系统下，编译32位程序时会自动进行重定向操作，如果是编译64位的程序，不进行重定向操作。
当编译32位版本程序时，如果程序调用系统目录下dll，如果原来路径写的是system32路径，编译器会自动
将之重定向为sysWoW64目录。

考虑这么一种情况：有一个源码项目，早先是在64位系统出来之前就写好了的，项目中会调用到系统目录下的user32.dll,(这是个系统自带dll），出于当时的情况，源码中很多调用系统目录地方，并没有调用系统API获取系统路径，而是直接写死为system32\user32.dll了，现在64位系统出来了，要把这个项目编译为64为版本，可知，在64位系统下，其系统目录中必然也应提供个64位的user32.dll。微软的考量是，如果在64位系统下生成64位版本的程序，为了提高编译效率，不应进行重定向操作，所以，像编译上面的源码的这种情况，为了源码能够正确编译，而且修改量小甚至可以不用修改，所以微软就在64位系统下保留了system32这样的名字，不过这里面的dll，却相应的都编程64位版本的了。那如果在64位系统下仍要编译为32位版本的程序呢？处于效率考虑，是不推荐的，但微软却不能因此而不支持，所以在这种情况下，微软采用了重定向的方案，还拿上面的例子，程序中访问user32.dll，如果不重定向，因为system32下实际存的是64为版本的user32.dll，所以32位程序在调用他的时候就会出错。所以这种情况，编译其碰到访问system32目录时，会自动将之替换为sysWoW64目录，这下面存放32位版本的user32.dll，这样就能保证程序的正确执行了，需要说明的是，关于重定向，上面为了讲解方面，将之认为是在编译期进行的转换，实际是在程序每次执行的时候进行的转换。这样64位系统下运行32为的程序，不管是在32位系统下编译生成的，还是在64为下生成的，在其调用32位的系统dll时，都将之重定向到sysWoW64目录，因为这种的重定向操作，可能导致64位系统运行32位程序，反而不如32位系统运行32位程序效率更高。
简言之，64位系统目录之所以不叫system64，而仍然保留叫system32 ，是为了早先的源码能够不加改变的移植生成64位版本的程序。

