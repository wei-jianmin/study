进程的消息队列就是进程的所有线程的消息队列的总称了（进程没有消息队列）。
另外，也不是所有的线程都有消息队列，只有在线程调用过某些GUI相关的API后，
系统才会为线程创建消息队列。
系统消息队列中的消息是由操作系统负责，在必要的时刻投递到进程的消息队列的。

消息队列是属于线程的，所以消息队列是对线程来说的，
进程并不存在消息队列一说，虽然线程属于进程，但是进程并不是执行单元，
所以认为所有的线程消息队列合在一起就是进程的消息队列这个没有什么意义。

当消息产生时，比如按了下键盘，这个事件转成消息，然后放到系统消息队列中，
windows从系统消息队列中移走消息，确实消息的接收窗口，
打到相应窗口所在的线程，然后将消息放入到线程的消息队列中。

系统消息队列由Windows维护，线程消息队列则由每个GUI线程自己进行维护，
为避免给non-GUI线程创建消息队列，所有线程产生时并没有消息队列，
仅当线程第一次调用GDI函数数系统给线程创建一个消息队列。
队列消息送到系统消息队列，然后到线程消息队列；非队列消息直接送给目的窗口过程。
对于队列消息，最常见的是鼠标和键盘触发的消息，
例如WM_MOUSERMOVE,WM_CHAR等消息，还有一些其它的消息，
例如：WM_PAINT、WM_TIMER和WM_QUIT。当鼠标、键盘事件被触发后，
相应的鼠标或键盘驱动程序就会把这些事件转换成相应的消息，然后输送到系统消息队列，
由Windows系统去进行处理。Windows系统则在适当的时机（Windows主动进行的），
从系统消息队列中取出一个消息，根据前面我们所说的MSG消息结构
确定消息是要被送往那个窗口，然后把取出的消息送往创建窗口的线程的相应队列，
下面的事情就该由线程消息队列操心了，Windows开始忙自己的事情去了。
线程看到自己的消息队列中有消息，就从队列中取出来，
通过操作系统发送到合适的窗口过程去处理（线程中可能有多个窗口）。
一般来讲，系统总是将消息Post在消息队列的末尾。
这样保证窗口以先进先出的顺序接受消息。
然而,WM_PAINT是一个例外，同一个窗口的多个 WM_PAINT被合并成一个
 WM_PAINT 消息, 合并所有的无效区域到一个无效区域。
合并WM_PAIN的目的是为了减少刷新窗口的次数。