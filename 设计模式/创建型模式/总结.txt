创建型模式有4中：工单建原

1.单例模式
    全局只有一个类实例
    
================================================================

2.工厂模式
    由工厂类负责产品类实例的创建，使用工厂类，客户类只需知道产品类的接口以及工厂类的头文件就可以了，产品类实现了最大程度的隐藏。

2.1 简单工厂模式
    客户类将产品名称以参数的形式告诉工厂类的创建函数，工厂类创建函数创建产品，并返回产品的指针。简单工厂模式不是23中设计模式之一，因为新增产品时，会改变工厂类，不符合开闭原则――可以为一个类添加方法，但不要修改其方法。

2.2 工厂方法模式
    工厂方法与简单工厂区别很大。在工厂方法中，产品和工厂都基于接口设计，一个产品对应一个工厂。客户不是直接创建产品，而是通过工厂创建产品。
    好处是，对客户屏蔽产品，从而增加了产品修改的灵活性，继承自上一代产品的新一代产品，能够很容易的替换，而不需要客户类做任何修改，这在一些不稳定的，容易升级的产品类上是很有用的。当人，坏处也很明显，在增加新产品时，会使系统中的类成对的增加。

2.3 抽象工厂
    抽象工厂可以说是简单工厂模式与厂方方法模式的结合品。抽象工厂中，一个工厂不再只生产一样产品，而是生产一系列产品（如海尔可以同时生产电视机、电冰箱、空调等）。
    应用场景：如界面更换主题，一个主题工厂可生成该主题的按钮、输入框、列表框等。

========================================================================

3.建造者模式
    //有的时候，一个产品不是一个工厂能创建出来的，现实中的例子，一台手机，有的厂商做屏幕、有的厂商做主板、有的厂商做芯片、有的厂商做手机壳、有的厂商做系统，等等，最终，需要一个组装厂把这些都工厂的产品按一定的流程组装起来后，才是一台完整的手机。
    当工厂不是一下就能创建出最终成品，而是在工厂内能分别生产产品的各个部分时，这是还需要一个指挥者（装配者）类，完成产品的装配工作。
    还是拿抽象工厂的例子来说，一个主题工厂可生产按钮、输入框、列表框等，还可以再创建一个装配者类，把按钮、列表框、输入框等组装成一个特定的对话框。
    可见，建造者模式的前提是，工厂能生成多个产品（或产品部件）。