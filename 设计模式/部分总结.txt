建造者模式
建造者模式适合于建造比较复杂的对象，如。建造汽车对象包括方向盘，车门，轮胎，发动机，底座等等，如果把这些东西。都放在一个构造函数中，则这个构造函数会非常复杂且容易出错。所以汽车产品。相对适合于把各个零件的构造分成不同的创建函数，然后再创建个汽车厂生产
对象。
再有一个例子就是套餐，像如套餐a套餐B等，厨师可以创建炸鸡腿，炸鸡翅，炸鸡柳等，服务员就相当于建造者，可以构建套餐a套餐B等对象。
在很多游戏软件中，地图包括天空、地面、背景等组成部分，人物角色包括人体、服装、装备等组成部分，可以使用建造者模式对其进行设计，通过不同的具体建造者创建不同类型的地图或人物。
------------------------------------------------------------
原型模式
圆形模式类似于拷贝构造函数，但又有所不同。用户使用一个对象时，往往只持有这个对象的接口，而不知道这个对象真正的类名叫什么，所以这时候是没法new出还对象的，这时候原型模式的价值就体香出来了。
原型模式创建出的新对象，并不是一个纯新的对象，否则用工厂也能，而是和当前对象具有完全一样的状态。
------------------------------------------------------------
工厂模式
工厂模式的目的就是想把建造对象和使用对象分开，为什么要这样做呢？因为用户要建造这个对象，就意味着必须要知道这个类的定义，而现实是，我们只想把类的接口暴露给用户。
让用户包含产品类的头文件，还有个坏处就是，假设用户和产品在不同的动态库中，当产品类中增加一个新的变量时，用户类所在的动态库就不得不重新编译。
------------------------------------------------------------
状态模式
不同的类继承同样的接口，这些类不应理解为接口的不同实现方式，而是代表不同状态下的不同的行为，称为状态类。
状态机模式脱胎于状态模式，是状态模式的一种。
环境类是状态类的管理类，维护了一个状态类的数组或映射表，并提供方法以控制使用哪个状态类。
状态模式或状态机模式，看起来跟责任链模式有些相似性：目的都是为了在符合某种条件时，使用相应地类进行处理（调用相应的处理类）。但细看之下，两者的区别还是挺大的，主要体现在处理类的调度方面，责任链类是自管理，自已在符合条件时就处理，处理完后一般会结束责任链的执行，不符合就凋用自已记录的下个结点，责任链每发起一次，一般只有一个处理类符合条件并进行处理，而状态模式中，状态类不是链表结构，而是数组或表线构，是环境类负责维护，但也是状态类负责调度的，在状态模式中，一般而言，各种状态类，在一次调度中，都能在合适的时候被执行到。
状态模式vs策略模式
策略是外界给的，策略怎么变，是调用者考虑的事情，系统只是根据所给的策略做事情。状态是系统自身的固有的，由系统本身控制，调用者不能直接指定或改变系统的状态转移。状态模式是策略模式的孪生兄弟，是因为它们的UML图是一样的。但意图却完全不一样，策略模式是让用户指定更换的策略算法，而状态模式是状态在满足一定条件下的自动更换，用户无法指定状态，最多只能设置初始状态。