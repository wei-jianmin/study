设计模式核心原则：
   高内聚，低耦合   
   -------   最终目的：添加修改代码后，不用担心对别处的代码产生影响

SOLID D
S : Single Responsibility Principle
O : Open-Closed Principle
L : Liskov Substitution Principle
I : Interface Segregation Principle
D : Dependence Inversion Principle
D : Law Of Demeter

替换单一  替换掉单一的
接口隔离  用接口隔离起来
依赖倒转  
开闭少知  什么时候开闭让最少的人知道


单一与开闭
里氏与倒置
组聚与隔离


设计模式之七大基本原则
1. 单一职责原则 (Single Responsibility Principle)
   通俗地说，即一个类只负责一项职责

2. 开放-关闭原则 (Open-Closed Principle)
   开放-关闭原则表示软件实体 (类、模块、函数等等) 应该是可以被扩展的，但是不可被修改。
   (Open for extension, close for modification)
   一个类一旦完成，只能因错误而修改， 如果要对类增加新特性或改变已有特性，应该通过新的类来完成。
   虽然直接继承或组合已有类比较方便，但这会破坏高聚低耦的核心原则，使用接口方式或是解决之道，但这在前期设计时可能有点麻烦
   开闭原则希望的最好是增加文件/类，次之是添加新的成员方法，不建议在原有函数上修改

3. 里氏替换原则 (Liskov Substitution Principle)   https://www.zhihu.com/question/27191817
   派生类对象能够替换基类对象，而程序逻辑不变
   这意味着任何一级的派生类，都不应该重写其父类的方法？
   不违反里氏替换的多态：重写父类的抽象方法
   里氏替换原则是说，任何基类可以出现的地方，子类一定可以出现
   （只有当衍生类可以替换基类，软件单位的功能不受到影响，基类才能真正被复用，衍生类也能够在基类的基础上增加新的行为）。
   里氏替换原则告诉我们，当使用继承时候，类 B 继承类 A 时，除添加新的方法完成新增功能，尽量不要修改父类方法预期的行为。
   里氏替换原则的重点在不影响原功能，而不是不覆盖原方法。
   ----  因为如果子类覆盖了父类的方法，则在调用父类的地方，就不能随意替换成子类了

4. 依赖倒转原则 (Dependence Inversion Principle)
   该原则规定：
   高层次的模块不应该依赖于低层次的模块，两者都应该依赖于抽象接口。
   抽象接口不应该依赖于具体实现。而具体实现则应该依赖于抽象接口。

5. 接口隔离原则 (Interface Segregation Principle)
   真正的意图是 “分离” 接口(的功能)
   也就是说，接口的功能应该专一，如果接口中包含各方面的功能，则意味着实现类就要实现各种功能的接口。
   接口隔离原则的思想在于建立单一接口，尽可能地去细化接口，接口中的方法尽可能少
   但是凡事都要有个度，如果接口设计过小，则会造成接口数量过多，使设计复杂化。所以一定要适度。

6. 迪米特法则（Law Of Demeter）
   不要越俎代庖
   迪米特法则又称为最少知道原则，它表示一个对象应该对其它对象保持最少的了解。
   它因其在Demeter项目中的起源而得名。
   该原则认为，任何一个对象或者方法，它应该只能调用下列对象：
   ・该对象自身（的数据或方法）
   ・作为参数传进来的对象（也可以是该对象中的字段）
   ・在方法内创建的局部对象
   ・类的成员对象
   ・全局对象
   避免直接调用某对象的数据成员
   避免使用某对象的方法返回的对象
        这里同时也要求避免通过成员函数的返回值，
        将内部的成员对象的指针或引用向外返回，
        因为这会导致无法方便确定是谁修改了该成员对象的值
        也违背隔离原则
  
7. 组合/聚合复用原则 (Composite/Aggregate Reuse Principle)
   在面向对象的设计中，如果直接继承基类，会破坏封装，因为继承将基类的实现细节暴露给子类（违背隔离原则）；
   如果基类的实现发生了改变，则子类的实现也不得不改变；
   从基类继承而来的实现是静态的，不可能在运行时发生改变，没有足够的灵活性。
   于是就提出了组合/聚合复用原则，也就是在实际开发设计中，尽量使用组合/聚合，不要使用类继承。
   总体说来，组合/聚合复用原则告诉我们：组合或者聚合好过于继承。
   聚合组合是一种 “黑箱” 复用，因为细节对象的内容对客户端来说是不可见的。
   组合： A中包含对象成员变量B *b;且b是由A创建的，并由A负责销毁；
   聚合： A中包含对象成员变量B *b;但b是通过外部参数传来的，A不负责b的生死
-------------------------------------------------------------------------------
附注一：
   依赖倒转原则，如何理解“倒转”：
   不是在现有的底层类基础上设计高级类，而是让高级类依赖于抽象接口进行底层调用（底层类依赖于抽象接口进行底层功能实现），
   因为高级类明确需要什么样的需求，所以高级类才有资格定义需求抽象（即定义所依赖的抽象接口），
   而底层类反而需要参照高级类所依赖的抽象接口取实现（如果底层类已经实现，则可能需要适配器配合）。
   本来高级类需要依赖底层类的，现在成了底层类依赖高级类所定义的抽象接口了，所以称依赖倒转原则。

附注二：
    一个违背迪米特原则的案例为：（参：https://zhuanlan.zhihu.com/p/36883436，知乎：迪米特法则与重构）
   class 收银员类
   {
   public:
     void 收钱(float cost_money)
     {
        钱包类 钱包对象 = 顾客.交出钱包();
        钱包对象.从里面取钱(cost_money);
     }
   };
   an object should avoid invoking methods of a member object returned by another method.
   一个对象应该避免调用另一个方法返回的成员对象的方法。（参：https://en.wikipedia.org/wiki/Law_of_Demeter）
   信息专家模式告诉我们：“信息的持有者即为操作该信息的专家”。在这里，顾客作为钱包的持有者，所以顾客应作为操作钱包的专家，对其进行操作，而不应该将钱包的操作交给外部调用者进行操作。
   不要跟一个对象去索要他的子对象，然后调用其子对象的方法

------------------------------------------------------------------------------------

关于接口隔离的理解：
    接口隔离，本质是在变化与不变之间进行隔离，而这个隔离墙，就是接口
    要设计一个程序，前期应进行预测，哪些是易变的，哪些是稳定的，
    把稳定的部分作为中心，把易变的部分，分别包装成类，然后与稳定代码之间，通过接口进行隔离。
    其实这种隔离的思想还可以进一步延伸
    以oes为例，oes中的印章格式是易变的，所以在ess.lib中，做了个印章管理类，然后对外提供一致的印章编辑与访问方法，
    这其实就是使用的隔离的思想。
    另外，将一个数据作为类进行封装，将数据的变化限制在类内部，这也是隔离的思想，迪米特原则就是确保这种隔离。
    而且，使用组合与聚合，替代直接使用继承，其实也有一部分原因是处于隔离的目的，保护基本的成员不被子类访问
    所以，这可以划分为三种级别的隔离：
        1. 类内部的（数据成员）的隔离   ： 里氏替换、组合与聚合
        2. 类之间的、或与稳定代码间的隔离  ： 接口隔离
        3. 功能模块级别的隔离
    隔离的思想是和高内聚、低耦合的思想相统一的：
        高内聚、低耦合是目的，隔离是为实现这种目的所采取的措施
        
    
里氏替换原则和多态矛盾吗
    里氏替换的一般定义 ： “派生类对象能够替换基类对象，而程序逻辑不变”
    注意，是程序的逻辑不变，而不是功能不变，这是有区别的
    如一个类提供了访问子成员方法at()，而其子类将at()方法的功能实现为删除子成员，那就是违背里氏替换原则了
    另一个角度看，里氏替换就是用来约束多态的，多态实现时，应参考接口类或父类的本来用意，不要乱来。
