介者模式(Mediator Pattern)：
用一个中介对象（中介者）来封装一系列的对象交互，中介者使各对象不需要显式地相互引用，从而使其耦合松散，而且可以独立地改变它们之间的交互。

事类（都继承自同事接口）本来可以直接调用其它同事的通信方法完成交互，现在则是自己内部聚合中介者类，调用中介者的通信方法（需要把自己的代号告诉中介者），而中介者负责与其它同事进行通信。

https://juejin.im/post/5bd275dc51882529290fe2c5 中以数据库为例进行了介绍

使用中介者模式，有3个关键点：
1. 抽象同事聚合抽象中介者，具体中介者聚合所有具体同事 （类特点）
2. 同事借助中介者与其它同事通信，并传入自身代号 （成员函数特点）
3. 用户使用时，需要把各个具体同事的引用依次传给中介者（用户使用特点）

不是用中介者模式，各个同事间是网状关系，
使用中介者模式后，各个同事间是星形关系。

中介者起两方面作用： 中转 + 协调

不使用中介者模式时（网状结构）：
●系统结构复杂且耦合度高。每个同事需要拥有所以其它与之相关同事的引用。
●组件的可重用性差。没法把一个或一类同事单独拿到其它地方使用。
●系统的可扩展性差：如果需要增加、修改或删除某个同事、将导致多个其它同事类的源代码需要修改，这违反了 "开闭原则"，可扩展性和灵活性欠佳。

中介者模式的缺点：在具体中介者类中包含了大量同事之间的交互细节，可能会导致具体中介者类非常复杂，使得系统难以维护。

===================================================

参看中介者模式关系图可知，聊天工具的行为类似于中介者模式：
每个用户间的交流，不是直接p2p，而是都跟服务器通信（告诉服务器把消息转发给谁）
● QQ客户端要知道QQ服务器的地址（信息交互对象包含中介者接口的指针）
● QQ用户注册时，填写注册信息（中介者对象录入信息交互对象时，需要知道该对象的ID）
● QQ用户发消息时，要指明接收人（信息交互对象调用中介者接口的转发消息函数时，要指明接受者ID）

注意点：
1. 各个信息交互的对象，继承自同一接口。 （意味着接口中收发消息的函数成对出现）
2. 各个信息交互的对象，需要持有中介者接口的指针。（主要用于把消息发给中介者）
3. 信息交互对象发消息给中介者时，需要指明消息接收者ID；
   同时中介者录入信息交互对象时，也需要知道该对象的ID。
   （ID要么以单独参数的形式提现，要么包含在类中）
   
适用场景：
信息交互对象比较多，且相互间交互的形式比较简单（交互用的接口少，如只有一对收发信息接口）

例子：
1. https://design-patterns.readthedocs.io/zh_CN/latest/behavioral_patterns/mediator.html  
   该例子是C++的，中介者接口中，录入及转发函数都以单独参数的形式指明了信息交互对象的ID
2. https://blog.csdn.net/codedancing/article/details/104729660
   该例子是java的，中介者接口中，录入及转发函数都没有指明信息交互对象的ID，
   但录入对象的ID可以从该对象的接口方法中获得，而转发目标对象的ID，可以通过“消息”对象的成员方法获得
