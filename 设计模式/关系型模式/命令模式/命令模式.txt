本来 功能调用类 可以直接调用 功能实现类 的特定方法，以完成某种工作，
现在则是 功能调用类 去调用命令类的execute方法，而命令类则聚合了 功能实现类，并在execute方法内部调用 功能实现类 的相应方法。

理解：所谓的命令类，就是只实现了一个特定功能（公有方法是action/excute）的类。

特点：每个功能实现类的方法，都有一个对应的命令类，所以如果一个系统中，如果有很多功能方法，则不适宜用命令模式，否则会创建出大量命令类。

举例分析： 
    一个系统，要实现支持 qq登录、微信登录、邮箱登录、手机登录，
    如果使用命令模式，则会有4个命令类，
    可以写一个功能类，里面实现各种登录方法，也可以随意的增加别的功能类，里面一个实现部分或全部登录方法，
    而这4个命令类，则可以用在任意地方（任意调用者）。
    当然，这也可以不用命令模式：功能调用类 直接聚合 功能实现类 的接口，然后传入功能实现类， 通过接口调用 功能实现类 的特定方法，
    但这意味着我们要实现一个新的 功能实现类 ，就必须实现 功能实现类接口 中规定的各种方法，不然将它传给 功能调用类 使用时，就可能出现问题。
    这里，通过对比，就发现了 命令模式 的一个优点： 命令独立
    命令模式，把每个命令（即功能、函数）都独立了, 可以针对每个命令，分别指定调用哪个 功能实现类 的相关方法，
    这种特点，使得命令模式的代码写起来很繁杂，也是因为这种特点，成就了其灵活性。

好处：
把 功能调用类 和 功能实现类 解耦了：可以随意选择功能调用类，也可以随意选择功能实现类



命令对象 持有 接受者对象的接口，命令对象的执行，实际是调用接受者的相关方法
调用者 持有 命令对象的接口，调用者的执行，实际是命令对象的执行

如果不使用命令模式：调用者持有执行者的接口，直接调用执行者的相关方法
使用命令模式：在调用者和执行者之间加了个命令对象，调用者持有命令对象的接口，命令对象持有执行者的接口
好处：调用者可以

=======================================

命令类并不是命令的真正执行者，而是在命令类的构造函数中，通过参数传来执行者的接口，以及调用接口方法时的必要参数。

如文件阅读器接口IReader中包含有“打开文档”、“向下翻n页”、“向上翻n页”、“缩放到指定分辨率”、“页面旋转90*n度”、“关闭文档”、
“在当前页特定位置盖章” 、“在当前页特定位置做直线标注”、“在当前页特定位置做文字标注”、。。。等等接口方法。

我们可以new一个IReader的实现类，并直接调用IReader的接口方法，
除此之外，我们也可以针对接口中的一个或多个方法，再增加 m 个命令类，
如 “打开文档命令类”、“翻页命令类”、“缩放命令类”、“盖章命令类”等，
这些命令类的构造函数接受IReader参数，以及调用相应IReader方法所需的参数，
如 OpenFileCmd(IReader* reader, const char* filename)
这看似脱了裤子放屁（多此一举），还增加了项目中类的个数，
但其实这种方法也有其好处，
1. 简化接口调用（其实策略模式的上下文类也有这个作用）
   如我们可以封装一个文件盖章命令类，该命令类可以在某文档的第n页的指定坐标处盖章（构造函数参数获得这些信息）
   在命令类的exec函数中，依次调用IReader的打开文档、向下翻n页、在当前页的特定位置盖章、关闭文档等方法。
2. 便于实现命令记录、命令重放
   如要实现绘图录制功能，就可以创建“绘制直线命令”、“绘制矩形命令”、“绘制椭圆命令”、“绘制多边形命令”、“填充上个闭合路径命令”等，
   然后通过一个list<ICmd*> 依次记录下这些命令对象
   重放时，依次调用list<ICmd*>中的 ICmd->exec()方法即可
扩展：
   针对上面提到的实现命令记录与重放，其实更好的做法是，
   再创建一个MacroCmd ：public ICmd 类， 让这个MacroCmd类负责 list<ICmd*> 的维护与使用，
   即 MacroCmd 包含 list<ICmd*> cmd_lst 成员变量，
   并提供append(ICmd*)、clear()等方法管理 cmd_lst
   同时又因为继承ICmd，所以他也实现了exec方法，内部就是依次调用cmd_lst中的exec方法，
   注意，append方法，不但可以传来普通的ICmd实现类的指针，也可以传来MacroCmd(宏命令)类的指针
   这种方法非常类似于设计模式中的组合模式，这里的MacroCmd 相当于组合模式目录树例子中的文件夹，
   而一般的命令实现类，相当于不同的文件，稍微有点区别的是MacorCmd类中要多实现个exec方法。
   
《图解设计模式.pdf》中有个这方面的例子讲得不错。

qt中的QEvent，虽然有点像，但并不是这里的命令模式，最明显的，它没有exec方法。

-------------------------------------------------------------------------------------------------------------------------
命令模式像工厂模式一样，把功能类和使用者通过中间类分离开来，起到解耦的作用
   




