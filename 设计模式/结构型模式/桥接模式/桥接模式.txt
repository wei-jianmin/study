● 基本概念

1.  委托 vs 继承：
    委托即A类中包含类成员变量B _imp，A类只是个“功能类”(相对实现类，功能类是基于实现类进行的上层的封装），具体的底层实现委托给类成员变量_imp完成。
    从耦合度上看，继承属于强关联关系，委托属于弱关联关系，委托比继承的耦合度要低。

2.  功能层次结构 vs 实现层次结构
    A2类继承并扩展了A1的功能接口，同理A3又继承并扩展了A2的功能接口，如此形成的层次结构，称为功能层次结构。
    IB是个虚接口，B1继承并实现了IB，还可以再多一个B2也继承并实现了IB，如此形成的层次结构，称为实现层次结构。

3.  桥接模式
    桥接模式的基本特点就是在“功能层次结构”最上层的类(A1)中
    包含“实现层次结构”最上层的抽象类(IB)的成员变量。
    A功能层次结构的基本功能实现，借助IB *_imp,“委托”给B实现层次结构完成。类成员IB *_imp成为连接两种层次结构的关系桥。
    该模式的关键点在于如何正确划分出功能类和实现类之间的界限。



● 扩展

桥接模式 vs 适配器模式
区别于适配器模式，桥接模式不改变接口形式。

桥接模式 vs 装饰模式
两个模式都是为了解决子类过多问题, 但他们的诱因不同: 
1.桥接模式对象自身有沿着“多个维度”变化的趋势 , 本身不稳定; 
2.装饰者模式对象自身非常稳定, 只是为了增加新功能/增强原功能。


● 理解
桥接模式用抽象关联取代了传统文化的多重继承：
    一个实体类继承另一个实体类 
--> 一个实体类组合另一个实体类
--> 一个实体类组合另一个实体类的接口
--> 一个实体类的接口组合另一个实体类的接口（桥接模式）

========================

产品会在多个维度发生变化，且在一个维度发生变化时，可以不影响其他维度，如阅读器，可能在界面样式和功能上发生变化，此时可以通过桥接模式
class IFunc
{
};

class FuncImpl : public IFunc
{
};

class IFace
{
  public:
  private:
    IFunc * func;   //提现了桥接模式的特点
};

class FaceImpl : plubic IFace
{

};

桥接模式不仅适用于多个维度的分离，还可以用来实现抽象和具体的分离
class IConcrete
{

}
class ConcreteImpl : plubic IConcrete
{

}

class IAbstract
{

  private:
  IConcrete * con;
}

class AbstractImpl : public IAbstract
{

}
上面例子中，IConcrete并不是给客户的抽象接口，IAbstract才是
