装饰模式：

两个基本特点：
（假设被装饰类都继承自IF接口，装饰类为D）
1. 继承被装饰类的接口，即D继承IF
2. 被装饰类的接口作为构造函数参数，即D的构造函数接受IF参数
有了这两个特点后，假设有某个被装饰类C，就可以 IF* p = new D(&c);

装饰模式可以起到强化被装饰类原有接口的目的，而且使用很方便。

-------------------------------------------------------------------

● 装饰类的实现：
・ 同时继承自被装饰类（的基类），内部又包含被装饰类(基类)的成员变量。
・ 实现基类（被装饰类）函数时，内部调用了“基类成员变量相应的功能接口”，同时，又对“基类成员功能接口”的实现结果做了一定的处理(修饰)。
・ 第一级的装饰类（作为其他装饰类的基类）：
   继承自被装饰类
   包含被装饰类的成员变量
   具有被装饰类做参数的构造函数，完成被装饰类成员变量的赋值

● 继承的特点：
   子类至少包含与父类完全一致的接口，在接口调用方面，子类完全可以充当基类。也可以理解为：后代完全具有前代的功能――甚至还具有更多的功能,如果要前代完成某项功能，则也完全可以通过其后代完成该功能，而且使用方法"完全一致"。
   注意：这里的“使用方法完全一致”,是区分继承和委托的关键点之一，如果用委托，也可以实现与关联类一致的功能，但在调用方法上，包括函数名和参数，不要求完全一致。

● 装饰类的使用特点:
   因为是继承的关系，所以装饰类能够完全作为被装饰类使用。
   只要是继承自被装饰类的，不管是被装饰类的子类，还是其他兄弟装饰类(继承自相同的被装饰类)，都可以作为当前装饰类的构造函数参数，进行装饰。

● vs 桥接模式
   桥接模式只使用了委托，装饰模式同时使用了委托和继承。
   桥接模式通过委托，实现了功能层次和实现层次的分离。
   装饰模式因为使用了继承，所以具有强耦合关系，所以不能实现分离不同层次的功能，装饰类与被装饰类必属于同一层次。但使用继承也有使用继承的优点，即类的“等效替换”――子类可以等效替换父类而在使用上看不出任何区别（使用方式完全一致）。