DH算法学习及SSL实现

算法原理：
假设(q, p) = (7,15)，我们让Alice和Bob再来协商一遍
（1）Alice 选择一个范围在[1, p-1]的随机数，				为da = 3
（2）Alice 计算Pa = q^da mod p 							Pa = 7^3 mod 15 = 13
（3）Bob选择一个范围在[1, p-1]的随机数，				为db = 2
（4）Bob计算Pb = q^db mod p 							Pb = 7^2 mod 15 = 4
（5）Alice和Bob交换Pa和Pb
（6）Alice计算共享密钥S = Pb ^da mod p 					S = 4^3 mod 15 = 4
（7）Bob计算共享密钥S = Pa ^db mod p 					S = 13^2 mod 15 = 4

算法整理：
前提： (q,p) = （7，15） ： 这是可以公开的，A、B都知道的数据
1. A选择一个数x1，要求： 1 <= x1 <= p-1
2. A计算得到： y1 = q ^ x1 % p
3. B选择一个数x2，要求： 1 <= x2 <= p-1
4. B计算得到： y2 = q ^ x2 % p
5. A 和 B 交换 y1, y2
6. A计算得到密钥 S = y2 ^ x1 % p
7. B计算得到密钥 S = y1 ^ x2 % p

数学原理：将上面的 y1 和 y2 带入得到下面的等式：
          (q ^ x2 % p) ^ x1 % p = (q ^ x1 % p) ^ x2 % p
          用法：
            q,p是公共参数(通过DH组约定)，x1和x2是私有的
            y2=(q ^ x2 % p), y1=(q ^ x1 % p) 是双方要交换的
          证明：
          先证明：a^b % p = (a%p)^b % p (模除运算法则)
          证明参：file://RSA原理.txt
            (q ^ x2 % p ) ^ x1 % p
          = (q ^ x2 ) ^ x1 % p
          = (q ^ x1 ) ^ x2 % p
          = (q ^ x1 % p ) ^ x2 % p
          DH组：
            DH 组 1： 768 位组
            DH 组 2： 1024 位组
            DH 组 5： 1536 位组
            Diffie-Hellman (DH) 组确定了在密钥交换进程中使用的密钥的强度。 
            组的编号越大安全性就越高，但是也就需要更多的时间来计算密钥。
            性能测试：
            DH 组	每个密钥对需要的时间
            组 1	21 毫秒
            组 2	42 毫秒
            组 5	123 毫秒

验证： 假设 q = 7, p = 15, x1 = 3, x2 = 2， 代入公式：
       (7 ^ 2 % 15) ^ 3 % 15 = (7 ^ 3 % 15) ^ 2 % 15
       (49 % 15) ^ 3 % 15 = (343 % 15) ^ 2 % 15
       4 ^ 3 % 15 = 13 ^ 2 % 15
       64 % 15 = 169 % 15
       4 = 4
       验证成功

注意事项：
    p 必须是质数且足够大（至少300位）
    a，b 也要足够大（至少100位），且必须是随机生成。
    g 必须是质数，不需要很大，比如 2 或 3 或 5 都可以。g 如果太大并不能显著提升安全性，反而会影响性能。

DH算法的优缺点
    优点：
        通信双方都无法根据已知的数来推算出对方的私钥
        对于一个旁观者（偷窥者），虽然能看到 p，g，A，B，但是无法推算出私钥 a 和 b，自然也无法推算出对称密钥k
    缺点：
        DH密钥交换算法不进行认证对方，所以易受到中间人攻击
        中间人攻击 描述：
        （1） Alice 公开发送值a和p给Bob,攻击者C截获这些值，随即把自己产生的公开值发给Bob。
        （2） Bob 公开发送值a和p给Alice,又被 C截获，随即把自己产生的公开值发给Alice。
        （3） Alice 和C计算出两人之间的共享密钥k1。
        （4） Bob 和C计算出两人之间另一个的共享密钥k2
        利用数字签名可以解决中间人攻击的缺陷。
        
DH算法分类标准有两类：第一种是基于密钥；第二类基于计算方式。
    按照密钥情况，可分为：静态DH算法和DHE算法
    按照计算方式，可分为：模指数DH算法和椭圆曲线DH算法（ECDH）
    静态DH vs. DHE：
        通信双方有一方的私有密钥是固定的，另一方临时生成，一般是服务器端固定。
        但是这样随着时间的验证，很容易被破解，而一旦被破解，之前所有的通讯数据都很容易被解密，不具备前向安全的特性。
        既然静态DH算法中，一方固定一方临时生成的方式不安全，那么我们就双方都不固定。
        通讯双方的私有密钥都采用临时生成的方式，这中DH算法称之为DHE算法（E是指Ephemeral, 临时的）。
    模指数DH算法 vs. 椭圆曲线DH算法（ECDH）
        IPSec中的DH算法绝大多数是模指数DH算法，
        SSL/TLS中采用的椭圆曲线DH算法。        
        
具体SSL应用过程：
单项验证
Client：生成随机数q，将随机数q和支持的密码套件发送给Server
Server: 
		1.接收Cilent发送的随机数q（作为基数）和密码套件列表
		2.根据自身证书和Client发送的套件列表选择使用的密码套件
		3.生成随机数p（作为模数），与Client发来的基数q组成（q，p）
		4.根据（q,p）生成临时私钥db ：私钥db < 模数p
		5.根据随机数q^db mod p （模幂运算）生成临时公钥pb
		5.将随机数p（模数），Server证书，临时公钥pb发送给Client
		6.发送Server Hello done
Client:
		1.接收Server发送过来的随机数p（模数），Server证书，以及Server端临时公钥pb
		2.利用Server发送的随机数p（模数）和原来的q（基数）组成（q，p）
		3.根据(q，p)生成临时私钥da ：私钥da < 模数p
		4.根据q^da mod p （模幂运算）生成临时公钥pa
		5.使用Server证书对临时公钥pa加密
		6.将加密后的pa发送给Server
		7.根据Server发送来的临时公钥pb及随机数p，计算对称密钥S = pb ^ da mod p,至此，客户端得到对称密钥
Server:
		1.接收Client发送来的临时公钥pa，计算对称密钥  S = pa ^ db mod p
注：原本 "P = 基数^私钥 mod 模数" 中，模数和基数应该是客户端和服务端实现约定好的，
    在SSL验证过程中，改为让客户端生成基数（随机数），让服务端生成模数（随机数），并让客户端和服务端互通有无