EIP，EBP，ESP都是系统的寄存器，里面存的都是些地址。系统中栈的实现上离不开他们三个。
1.栈是用来存储临时变量，函数传递的中间结果。
2.操作系统维护的，对于程序员是透明的。
void fun(void)
{
   printf("hello world")；
}
void main(void)
{
  fun()
  printf("函数调用结束");
}
当调用fun函数开始时，三者的作用。
1.EIP寄存器里存储的是CPU下次要执行的指令的地址。
 也就是调用完fun函数后，让CPU知道应该执行main函数中的printf（"函数调用结束"）语句了。
2.EBP寄存器里存储的是是栈的栈底指针，通常叫栈基址，这个是一开始进行fun()函数调用之前，由ESP传递给EBP的。（在函数调用前你可以这么理解：ESP存储的是栈顶地址，也是栈底地址。）
3.ESP寄存器里存储的是在调用函数fun()之后，栈的栈顶。并且始终指向栈顶。
 
当调用fun函数结束后，三者的作用：
1.系统根据EIP寄存器里存储的地址，CPU就能够知道函数调用完，下一步应该做什么，也就是应该执行main函数中的printf（“函数调用结束”）。
2.EBP寄存器存储的是栈底地址，而这个地址是由ESP在函数调用前传递给EBP的。等到调用结束，EBP会把其地址再次传回给ESP。所以ESP又一次指向了函数调用结束后，栈顶的地址。

程序为什么开头总是PUSH EBP
先把EBP当前的值存入栈中，然后为下一步（把ESP赋值给EBP做准备，返回时需要进行EBP恢复操作）

eax, ebx, ecx, edx, esi, edi等都是X86 汇编语言中CPU上的通用寄存器的名称，是32位的寄存器。
这些32位寄存器有多种用途，但每一个都有“专长”，有各自的特别之处。
EAX 是"累加器"(accumulator), 它是很多加法乘法指令的缺省寄存器。
EBX 是"基地址"(base)寄存器, 在内存寻址时存放基地址。
ECX 是计数器(counter), 是重复(REP)前缀指令和LOOP指令的内定计数器。
EDX 则总是被用来放整数除法产生的余数。
ESI/EDI分别叫做"源/目标索引寄存器"(source/destination index),因为在很多字符串操作指令中, DS:ESI指向源串,而ES:EDI指向目标串.

一般寄存器:AX、BX、CX、DX
AX:累e捍嫫鳎BX:基底捍嫫鳎CX:捍嫫鳎DX:Y料捍嫫
EAX、ECX、EDX、EBX：ax,bx,cx,dx的延伸，各32位元 
ESI、EDI、ESP、EBP：si,di,sp,bp的延伸，32位元

EBP是"基址指针"(BASE POINTER), 它最经常被用作高级语言函数调用的"框架指针"(frame pointer). 在破解的时候,经常可以看见一个标准的函数起始代码:
push ebp ;保存当前ebp
mov ebp,esp ;EBP设为当前堆栈指针
sub esp, xxx ;预留xxx字节给函数临时变量.  //栈的生长方向是从高地址向低地址
这样一来,EBP 构成了该函数的一个框架, 在EBP上方分别是原来的EBP, 返回地址和参数. EBP下方则是临时变量. 函数返回时作 mov esp,ebp/pop ebp/ret 即可.

栈的基本模型:
参数N						↓高地址
参数…						函数参数入栈的顺序与具体的调用方式有关
参数 3
参数 2
参数 1
EIP						返回本次调用后，下一条指令的地址
EBP						保存调用者的EBP，然后EBP指向此时的栈顶。
临时变量1
临时变量2
临时变量3
临时变量…
临时变量5					↓低地址

CR0，CR1，CR2和CR3 ： 这几个寄存器中保存全局性和任务无关的机器状态。
CR0中包含了6个预定义标志，0位是保护允许位PE(Protedted Enable)，用于启动保护模式，如果PE位置1，则保护模式启动，如果PE=0，则在实模式下运行。1位是监控协处理位MP(Moniter coprocessor)，它与第3位一起决定：当TS=1时操作码WAIT是否产生一个“协处理器不能使用”的出错信号。第3位是任务转换位(Task Switch)，当一个任务转换完成之后，自动将它置1。随着TS=1，就不能使用协处理器。CR0的第2位是模拟协处理器位 EM (Emulate coprocessor)，如果EM=1，则不能使用协处理器，如果EM=0，则允许使用协处理器。第4位是微处理器的扩展类型位ET(Processor Extension Type)，其内保存着处理器扩展类型的信息，如果ET=0，则标识系统使用的是287协处理器，如果 ET=1，则表示系统使用的是387浮点协处理器。CR0的第31位是分页允许位(Paging Enable)，它表示芯片上的分页部件是否允许工作。
CR1是未定义的控制寄存器，供将来的处理器使用。
CR2是页故障线性地址寄存器，保存最后一次出现页故障的全32位线性地址。
CR3是页目录基址寄存器，保存页目录表的物理地址，页目录表总是放在以4K字节为单位的存储器边界上，因此，它的地址的低12位总为0，不起作用，即使写上内容，也不会被理会。
这几个寄存器是与分页机制密切相关的，因此，在进程管理及虚拟内存管理中会涉及到这几个寄存器，读者要记住CR0、CR2及CR3这三个寄存器的内容。

32位CPU有4个32位的通用寄存器EAX、EBX、ECX和EDX。对低16位数据的存取，不会影响高16位的数据。这些低16位寄存器分别命名为：AX、BX、CX和DX，它和先前的CPU中的寄存器相一致。
4个16位寄存器又可分割成8个独立的8位寄存器(AX：AH-AL、BX：BH-BL、CX：CH-CL、DX：DH-DL)，每个寄存器都有自己的名称，可独立存取。程序员可利用数据寄存器的这种“可分可合”的特性，灵活地处理字/字节的信息。

在用途方面，他们有各自默认的用途：
Eax用来保存所有API函数的返回值。
寄存器AX和AL通常称为累加器(Accumulator)，用累加器进行的操作可能需要更少时间。累加器可用于乘、除、输入/输出等操作，它们的使用频率很高；
寄存器BX称为基地址寄存器(Base Register)。它可作为存储器指针来使用； 
寄存器CX称为计数寄存器(Count Register)。在循环和字符串操作时，要用它来控制循环次数；在位操作中，当移多位时，要用CL来指明移位的位数；
寄存器DX称为数据寄存器(Data Register)。在进行乘、除运算时，它可作为默认的操作数参与运算，也可用于存放I/O的端口地址。

由于存储的数据大小关系，AX、BX、CX和DX不能作为基址和变址寄存器来存放存储单元的地址， 32位寄存器EAX、EBX、ECX和EDX不仅可传送数据、暂存数据保存算术逻辑运算结果，而且也可作为指针寄存器，所以，这些32位寄存器更具有通用性。（什么是基址，什么是变址以后会说到）

2个变址和指针寄存器(ESI和EDI)
32位CPU有2个32位通用寄存器ESI和EDI。其低16位对应先前CPU中的SI和DI，对低16位数据的存取，不影响高16位的数据。

寄存器ESI、EDI、SI和DI称为变址寄存器(Index Register)，它们主要用于存放存储单元在段内的偏移量，用它们可实现多种存储器操作数的寻址方式，为以不同的地址形式访问存储单元提供方便。
变址寄存器不可分割成8位寄存器。作为通用寄存器，也可存储算术逻辑运算的操作数和运算结果。它们可作一般的存储器指针使用。在字符串操作指令的执行过程中，对它们有特定的要求，而且还具有特殊的功能。