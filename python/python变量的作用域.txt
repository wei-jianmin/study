参： https://zhuanlan.zhihu.com/p/103164544

L = Local 局部作用域
E = Enclosing 嵌套作用域
N = nonlocal 只作用于嵌套作用域，而且只是作用在函数里面
G = global 全局作用域
B = Built-in 内置作用域

与C语言的不同：
1. 不存在语句块作用域，如 if for while等不会产生作用域
2. 如果本层作用域中不存在某变量，会一级一级向外层作用域查找
   其实这一点跟C语言是一样的
   我们在写Python的时候，发现在函数中可以直接使用函数外定义的变量
   这是因为这些"函数外的变量"。其实相当于C语言中的全局变量
   另外，Python函数内支持嵌套子函数，这是C语言所不具有的功能
   所以在Python中还会涉及内层函数访问外层函数变量的问题（嵌套作用域）
3. Python中，在函数作用域中，没法做到又访问外部变量，又使用与该外部变量同名的局部变量
   例如，在 C 中，如下代码是可以的：
   int g=3;
   void func()
   {
      printf("g=%d\n",g);
      int g=5;
      printf("g=%d\n",g);
   }
   但在Python中，想达到同样的效果，则代码应写为：
   g=3
   def func():
      # global g
      print("g=%d"%g)
      g=5
      print("g=%d"%g)
   如果不加 global g 这一句，则调用该函数时会报错，提示变量不能在定义前被引用
   如果加上 global g 这一句，则所有的修改又全是对外部变量的修改，内部不会自动创建同名的局部变量了
   而Python中也没有 local 关键字，所以，目前看来，Python无法达到如上面 C代码 同样的功能
4. 内层函数访问外层函数变量的问题（嵌套作用域）
   这是Python因为支持函数嵌套，才会面临的情况
   在嵌套函数中，使用 'nonlocal 变量名' 标明：如果该作用域内，使用了与外层同名变量的变量，
   则不是对该变量重新定义赋值，而是使用的'紧邻的'上一层作用域的那个变量，
   如果'紧邻的'上一层没有这个变量，则在向上层找，直到找到这个变量，如果最终找不到这个变量，则会报错
   nonlocal和global是不同的，global是一下子找到全局作用域那一层，而nonlocal则优先只向上找一层

与C语言的相同点：
1. 都有函数作用域，在函数作用域可以定义使用与外部作用域同名的变量，而不会影响外部作用域的变量值
   且在函数作用域定义的变量，出了该函数作用域，就不可访问了    