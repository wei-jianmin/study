<catalog s0>
python2 vs. phthon3
    Python2和Python3分别是Python的两个版本，
    按照Python官方的计划，Python2只支持到2020年。
    为了不带入过多的累赘，Python3在设计的时候没有考虑向下相容，
    许多针对早期Python版本设计的程序都无法在Python3上正常执行。
    python3是不向下兼容的，但是绝大多数组件和扩展都是基于python2的。
    Py3.0运行 pystone benchmark的速度比Py2.5慢30%。
    Python3 比 Python2更容易理解，更加合理。
    PyPy，各大 Web 框架，科学计算包，Scrapy 等常用模块， 
    都已经很好的支持Python3。 
    但是还有部分比较陈旧的库已经无人维护， 也就没有支持最新的Python3，
    不过不用担心， 这些库往往是不常用的，或者说可以找到替代方案。
phthon 查看保留字
    Python 的标准库提供了一个 keyword 模块，可以输出当前版本的所有关键字：
    >>> import keyword
    >>> keyword.kwlist
注释
    Python中单行注释以 '#' 开头，'#' 后面要紧跟一个空格
    多行注释可以每行一个 '#' 号，还可以用连续的三个'或"：
代码格式
    区分大小写，变量、函数、还是类，都要严格的区分大小写
    每一个代码块的语句，必须缩进相同的空格数，否则会导致错误
    每行一条命令，在命令结尾无需使用 ;
    一条语句在多行书写时，在行尾处用 \ 连接
    多行语句在同一行书写时，用 ; 分隔
    复合语句
        像if、while、def、class这样的语句，称为复合语句
        特点是以关键字开始，以：为该行结束标记，之后接代码块
        如：
            if expression :   #以结尾的分号，标记携带子语句块，以反缩进代表子语句块的结束
               suite
            elif expression : 
               suite 
            else : 
               suite
数据类型
    3个不可变数据：Number、String、Tuple
    3个可变数据：  List、Dictionary、Set
    数字类型（Number）
        python中数字有四种类型：整数、布尔型、浮点数和复数。
        int (整数), 如 1, 只有一种整数类型 int，表示为长整型，没有 python2 中的 Long。
        bool (布尔), 如 True，注意，布尔是int的子类型，True==1,False==0。
        float (浮点数), 如 1.23、3E-2
        complex (复数), 如 1 + 2j、 1.1 + 2.2j
        通过内置type()函数，可以查看变量类型：  #&<查看变量类型的函数>
        x=3;print(type(x)) 输出结果为 : <class 'int'>
        通过isinstance(变量,类型) ，判断变量是否为指定类型或其子类(派生类)。 #&<判断变量是否是某种类型或其子类型>
        python中的变量本质是引用，数字类型的变量引用的是Number（派生类的）实例
        py和Java一样，采用了享元模式的设计思想，
        每个对象都已一个唯一的id，用id(变量名)可得到该对象的id  #&<获取变量的id>
        可以用del语句删除对象的引用，如 del var1,var2  #&<删除变量>
        在混合运算时，py会把整形转为浮点型。     #&<隐式类型转换>
        py可以同时为多个变量赋值，如：a,b=1,2     #&<多变量赋值>
        赋值二进制用0b开头，赋值8进制用0o开头，赋值十六进制用0x开头  #&<表示其它进制的数据>
        小整数池  #&<小整数池>
            编译器会有一个小整数池的概念，会把（-5，256）间的数预先创建好，
            而当a和b超过这个范围的时候，两个变量就会指向不同的对象了，
            因此地址也会不一样，比如下例：
            >>> a=1000
            >>> b=1000
            >>> id(a);id(b)
            2236612366224
            2236617350384
            >>> a,b=1000,1000
            >>> id(a);id(b)
            2076636440944
            2076636440944
        is和==   #&<is和==>
            is 判断两个变量是否是引用同一个内存地址。
            == 判断两个变量值是否相等
    字符串(String)
        python中单引号和双引号使用完全相同
        使用三引号可以指定一个多行字符串。
        py中的字符串只能读，不能修改。 #&<字符串只读>
        支持字符串自动拼接，如"this ""is"等价于"this is"  #&<字符串自动拼接>
        字符串可以用 + 运算符连接在一起，用 * 运算符重复   #&<字符串拼接与重复运算>
        Python 中的字符串有两种索引方式，从左往右以 0 开始，从右往左以 -1 开始 #&<字符串索引方法>
        Python中的字符串不能改变
        Python 没有单独的字符类型，一个字符就是长度为 1 的字符串
        字符串的截取的语法格式如下：变量[头下标:尾下标:步长]? #&<字符串的截取>
        尾下标和步长值都是可选的
        str = 'Runoob'
        print (str)          # 输出字符串
        print (str[0:-1])    # 输出第一个到倒数第二个的所有字符
        print (str[0])       # 输出字符串第一个字符
        print (str[2:5])     # 输出从第三个开始到第五个的字符
        print (str[2:])      # 输出从第三个开始的后的所有字符
        print (str * 2)      # 输出字符串两次，也可以写成 print (2 * str)
        print (str + "TEST") # 连接字符串
        print (str[0::2])    # 输出Rno
        print (str[-1::-1])  # 字符串反向输出，输出结果为：boonuR
        原生字符串  #&<原生字符串>
            r""或R""为原生字符串写法，里面的\不转义。
        %格式化字符串
            语法：
                格式化字符串描述 % 变量  或  
                格式化字符串描述 % (变量1,变量2,...)
            占位符
                %c	 格式化字符及其ASCII码
                %s	 格式化字符串
                %d	 格式化整数
                %u	 格式化无符号整型
                %o	 格式化无符号八进制数
                %x	 格式化无符号十六进制数
                %X	 格式化无符号十六进制数（大写）
                %f	 格式化浮点数字，可指定小数点后的精度
                %e	 用科学计数法格式化浮点数
                %E	 作用同%e，用科学计数法格式化浮点数
                %g	 %f和%e的简写
                %G	 %f 和 %E 的简写
                %p	 用十六进制数格式化变量的地址
            例：
                >>> name = 'Runoob'
                >>> 'Hello %s' % name
                'Hello Runoob'
        f-string
            f""为f-string写法，可以自动把字符串中用{}标识的变量，替换为实际值
            f-string 是 python3.6 之后版本添加的，称之为字面量格式化字符串
            f-string 格式化字符串以 f 开头，后面跟着字符串，
            字符串中的表达式用大括号 {} 包起来，它会将变量或表达式计算后的值替换进去
            用了这种方式明显更简单了，不用再去判断使用 %s，还是 %d。
            例：
                >>> name = 'Runoob'
                >>> f'Hello {name}'  # 替换变量
                'Hello Runoob'
                >>> f'{1+2}'         # 使用表达式
                '3'
                >>> w = {'name': 'Runoob', 'url': 'www.runoob.com'}
                >>> f'{w["name"]}: {w["url"]}'
                'Runoob: www.runoob.com'
        unicode字符串
            在Python2中，普通字符串是以8位ASCII码进行存储的，
            而Unicode字符串则存储为16位unicode字符串，表示语法为:u""
            在Python3中，所有的字符串都是Unicode字符串。
        format字符串
            format是python2.6新增的一个格式化字符串的方法
            它比%格式化字符串的方式更加灵活，更加强大
            它的基本格式为 "格式字符串".format(参数,...)
                format中的参数将会替换到格式化字符串中相应占位符的位置，
                参数可以是直接的数据值，也可以是 变量名=数据值 的形式，
                格式字符串中可以使用{0},{1}这样的占位符代表format中的第n个参数
                也可使用{变量名}代表format中的关键字参数
            格式字符串讲解1
                "{ [索引名] [!r/!s/!a] [:格式细节] }".format(...)
                索引名： 
                    可选，当不存在时，指代第一个format中的参数
                    索引名格式： 关键字/数字【.属性名/.[数字/字典键]】
                    关键字指代的是format()中的相应关键字参数
                    上面的"数字"分别表示第n个format中的参数，第n个成员,
                    n总是从0开始算起
                    .[数字/字典键]实际是调用对象的__getitem__()方法
                    索引名可以有多级，从而可以访问一个参数的子成员的子成员...
                    从py3.1开始，当索引名为数字时，可以省略，
                    这意味着像如'{} {}'.format(a, b) 等价于 '{0} {1}'.format(a, b)
                [!r/!s/!a]
                    在将format中的参数（按照[:格式化细节]进行格式化后）
                    替换到占位符位置时，默认调用变量的__format__()成员方法，
                    然而我们也可以控制先调用该变量的相关方法，将其转换为字符串，
                    再调用转换成的字符串的__format__()方法
                    !r 先调用变量的str()成员方法将其转换为一个字符串
                    !s 先调用变量的repr()成员方法将其转换为一个字符串
                    !a 先调用变量的ascii()成员方法将其转换为一个字符串
                [:格式细节]
                    :[[填充字符]对齐方式][符号标记][井号][0][宽度][分组标记][.精度][变量类型]
                    口诀：齐符井0宽分精型（旗服、井灵、宽分、经行）
                    [填充字符]对齐方式
                        填充字符 ： 可以是任意的单个字符
                        对齐方式 ： "<" | ">" | "=" | "^"
                            < 左对齐
                            > 右对齐
                            ^ 居中对齐
                            = 两段对齐：符号(+/-)巨作，中间是空白，值居右
                    符号标记 ："+" | "-" | " "
                        +    数字时负的时，前面带-，数字时正的，前面带+
                        -    数字时负的时，前面带-，数字时正的，前面啥也不带
                        空格 数字时负的时，前面带-，数字时正的时，前面带空格
                    井号 ：
                        该控制项只有当变量是整数、浮点数、复数时才有效
                        当整数时，会给数字前面加上进制前缀0b/0o/0x/0X
                        当浮点数时，会强制输出小数点，即使没有小数部分
                        当复数时，实数部分和虚数部分后面总是加一个小数点
                        举例：
                            "{:o}".format(13)    # 输出为'15'
                            "{:#o}".format(13)   # 输出为'0o15' 
                            "{:.0f}".format(3)   # 输出为'3.000000'
                            "{:#.0f}".format(3)  # 输出为'3.'
                            "{}".format(1+2j)    # 输出为'(1+2j)'
                            "{:#}".format(1+2j)  # 输出为'(1.+2.j)'
                    宽度 ： 指定输出变量所占的宽度
                    分组标记 ： "_" | ","
                        这在表示一个比较大的数字时才有用
                        如："{:,} {:_}".format(12345,12345) ,输出为：12,345 12_345
                    .精度 ： 指定保留的小数位数
                    变量类型 :  "b" | "c" | "d" | "e" | "E" | "f" | "F" | "g" 
                                    | "G" | "n" | "o" | "s" | "x" | "X" | "%"
                        字符串类型
                            可用的类型为's'，也可以不写，效果等同于写了 's'
                        整数类型
                            b : 二进制类型
                            c ：字符类型，将把数字值转为相应的Unicode字符
                            d : 十进制类型
                            o : 八进制类型
                            x : 十六进制类型，a~f为小写
                            X : 十六进制类型，A~F为大写
                            n ：等同于d
                            不写 ： 等同于d
                         浮点类型
                            e/E ：科学计数法表示
                            f/F : 浮点，保留至少六位小数，不足的补0
                            g/G ：浮点，只显示小数的有效位
            格式字符串讲解2
                !s : 相当于对于参数调用str()
                !r ：相当于对于参数调用repr()
                {0}、{1} : 位置型占位符
                    如 ："名字:{0} 年龄:{1}".format("张三",12)
                {变量名} : 名字像占位符
                    如 ："名字:{name} 年龄:{age}".format(name="张三",age=12)
                {0[1]}、{0[2]} :  按位置访问相应变量(元组/列表)子元素
                    如 :  "名字:{0[0]} 年龄:{0[1]}".format(["张三",12])
                {变量名.成员变量名} : 访问format相应变量的成员
                    注意，只能是成员变量名，不能是成员函数名，而且必须是公有的
                    如 ： 
                    >>> class AB:
                    ...     a=12
                    ...     b=18
                    >>> ab=AB
                    >>> "ab.a={ab.a}".format(ab=ab) 
                    'ab.a=12'
                    上面例子中，format参数部分，=前面的ab为索引用的变量名，
                    =后面的为赋给变量名的值， =前后两个ab，不会冲突
                对齐控制
                    ^   居中       后面带宽度
                    <   左对齐     后面带宽度
                    >   右对齐     后面带宽度
                    如： "{:>5}".format(1)   # 设置宽度为5，右对齐，空白处用空格填充
                    #: 号后面带填充的字符，只能是一个字符，不指定则默认是用空格填充。
                数字格式化
                    print("{:.2f}".format(3.1415926));  # 3.14
                    +       表示在正数前显示 +，
                    -       负数  
                    (空格)  表示在正数前加空格
                    b       二进制
                    d       十进制
                    o       八进制
                    x       十六进制
                使用逗号作为千位分隔符
                    print('{:,}'.format(1234567890))  #'1,234,567,890'
                数字显示未百分比格式
                    "{:.2%}".format(0.25)        #25.00%
                字符串截断
                    '{:.5}'.format('Hello Chen') # 截取前5个字符
                时间格式化
                    import datetime 
                    d = datetime.datetime(2018, 7, 31, 15, 58, 58)
                    print('{:%Y-%m-%d %H:%M:%S}'.format(d)) 
                    # 2018-07-31 15:58:58    
                访问字典中的元素
                    people = {"name": "Chen", "age": 18}
                    "name {p[name]}, age {p[age]}".format(p=people) 
                    # 输出 'name Chen, age 18'
                格式化字符串中包含{或}
                    {}通常作为占位符的标记，但连续的讲个{{或}}将被解释为单纯的大括号
                    如："{{0,{0}}}".format("asdf")  #'{0,asdf}'
    Tuple（元组）
        元组（tuple）与列表类似，不同之处在于元组的元素不能修改。
        元组写在小括号 () 里，元素之间用逗号隔开。
        tup1 = ()                 # 空元组
        tup2 = (20,)              # 一个元素，需要在元素后添加逗号
        tuple = ( 'abcd', 786 , 2.23, 'runoob', 70.2  )
        print (tuple)             # 输出完整元组
        print (tuple[0])          # 输出元组的第一个元素
        print (tuple[1:3])        # 输出从第二个元素开始到第三个元素
        print (tuple[2:])         # 输出从第三个元素开始的所有元素
        print (tinytuple * 2)     # 输出两次元组
        print (tuple + tinytuple) # 连接元组
        元组与字符串类似，可以被索引且下标索引从0开始，-1 为从末尾开始的位置，也可以进行截取。
        可以把字符串看作一种特殊的元组。
        虽然tuple的元素不可改变，但它可以包含可变的对象，比如list列表。
    List（列表）
        List（列表） 是 Python 中使用最频繁的数据类型
        列表中元素的类型可以不相同，它支持数字，字符串甚至可以包含列表（嵌套）
        列表是写在方括号 [] 之间、用逗号分隔开的元素列表。
        和字符串一样，列表同样可以被索引和截取，
        列表被截取后返回一个包含所需元素的新列表。
        列表截取的语法格式 ： 变量[头下标:尾下标:步长]，
        索引值以 0 为开始值，-1 为从末尾的开始位置。
        加号 + 是列表连接运算符，星号 * 是重复操作。
        列表中的元素是可以改变的：
            >>> a = [1, 2, 3, 4, 5, 6]
            >>> a[0] = 9
            >>> a[2:5] = [13, 14, 15]
            >>> a[2:5] = []   # 将对应的元素值设置为 []
            >>> a
            [9, 2, 6]
        第三个参数表步长值，可选，如果第三个参数为负数表示逆向读取
        可以用append方法，给列表添加项，接前面的例子：
            >>> a.append(7)
            >>> a
            [9,2,6,7]
        可以用del删除列表元素，接前面的例子：
            >>> del a[2]
            >>> a
            [9,2,7]
        len可以取列表的元素个数
            >>> len(a)
            3
        +可以将列个列表连接为一个列表
        *相当于n个+
            ['a']*4 得到 ['a','a','a','a']
        for in 可以遍历列表
            for x in [1,2,3]: print(x,end="")
            输出：1 2 3
    Set（集合）
        可以使用大括号 { } 或者 set() 函数创建集合
        创建一个空集合必须用 set() 而不是 { }，因为 { } 是用来创建一个空字典。
        s={"a","bc","def","bc"}     # 重复的值会被合并为一个
        s2=set("asdf")              # set赋值法，会以字符为单位，分割为n多个元素
        a-b                         # a 和 b 的差集
        a|b                         # a 和 b 的并集
        a&b                         # a 和 b 的交集
        a^b                         # a 和 b 中不同是存在的元素
        集合的特点是里面的元素不能重复
        可以用关键字in判断一个值是否属于某个集合
        集合可通过"集合推导式"赋值
    Dictionary（字典）
        列表是有序的对象集合，字典是无序的对象集合。两者之间的区别在于：
        序列（列表或元组）可以认为是使用连续的整数为索引，
        字典当中的元素是通过键来存取的，而不是通过偏移存取。
        dict = {}
        dict['one'] = "1 - 菜鸟教程"
        dict[2]     = "2 - 菜鸟工具"
        dict2={"a":"aaaaa",1:"1234"}
        dict3 = {'name':'zhansan','age':15}
        dict4([('sape', 4139), ('guido', 4127), ('jack', 4098)]) #语法错误
        dict5(sape=4139, guido=4127, jack=4098)  #语法错误
        dict6={x: x**2 for x in (1, 2, 3)}
        print (dict3.keys())   # 输出所有键,返回类型为：<class 'dict_keys'>
        print (dict3.values()) # 输出所有值,返回类型为：<class 'dict_values'>
        print (dict3.items())  # 输出所有键值对，返回类型为：<class 'dict_items'>
        遍历字典方法：
        for k, v in list.items():
            print(k, v)
    类型强制转换
        函数	                描述
        int(x [,base])          将x转换为一个整数
        float(x)                将x转换到一个浮点数
        complex(real [,imag])   创建一个复数
        str(x)                  将对象 x 转换为字符串
        repr(x)                 将对象 x 转换为表达式字符串
        eval(str)               计算在字符串中的有效Python表达式,并返回一个对象
        tuple(s)                将序列 s 转换为一个元组
        list(s)                 将序列 s 转换为一个列表
        set(s)                  转换为可变集合
        dict(d)                 创建一个字典。d 必须是一个 (key, value)元组序列。
        frozenset(s)            转换为不可变集合
        chr(x)                  将一个整数转换为一个字符
        ord(x)                  将一个字符转换为它的整数值
        hex(x)                  将一个整数转换为一个十六进制字符串
        oct(x)                  将一个整数转换为一个八进制字符串
变量赋值
    变量无需声明，直接赋值即可
    py中变量是没有类型的，只有数据才有类型这一说，
    变量只是一个引用（一个指针），
    它可以指向List类型对象，也可以指向String类型对象
    py支持一次对一组变量赋值：
    如： a,b,c=1,2,3
    这里的逗号，与C语言中的逗号表达式意义完全不同
    py的这种赋值方式可以在有些情况下带来便利，如：
    a,b=b,a  实现了a个b两个变量值的交换
    另外，当变量指向不可变类型对象时，如Strings，
    给变量赋值，通常将使变量指向一个新对象，而将旧对象丢弃
    这里的"通常"，是考虑到py中维护"小整数池"(具体查看数据类型一节)
命令行中与用户的交互
    input
        str = input("按下 enter 键后退出。")
        用户按下 enter 键后，输入的值存到str中
    print
        语法：print(value,...,sep=' ',end='\n',file=sys.stdout,flush=False)
        print 默认输出是换行的，如果要实现不换行需要在变量末尾加上 end="",
        这种专门制定end参数值的方式，为"关键字参数"
        print( x )  #输出后自动换行
        print( x, end=" " ) # 不换行输出
        print还支持像C语言一样，格式化输出,如：
        print ("我叫 %s 今年 %d 岁!" % ('小明', 10))
        可以参看<数据类型/字符串>一节，了解不同格式的字符串
    import sys; sys.stdout.write("")
        这种输出方式的本质是写文件，标准输出文件是sys.stdout
        这种方式输出的字符串有些特别，
        它先原样输出字符串，
        之后紧跟着(不会换行)输出的字符个数，
        然后再输出一个换行符，
        如：import sys; sys.stdout.write('asdf')
        输出 ：asdf4
    str() 和 repr()
        str()： 函数返回一个用户易读的表达形式。
        repr()： 产生一个解释器易读的表达形式。
        使用str()函数，可以把要输出的对象转换为字符串进行输出
        可以参看<数据类型/字符串>一节，了解不同格式的字符串
import 与 from...import
    <关联节点：模块>
    想使用 Python 源文件，只需在另一个源文件里执行 import 语句，语法如下：
    import module1[, module2[,... moduleN]
    当解释器遇到 import 语句，如果模块在搜索路径(sys.path)中找到，就会被导入
    将整个模块(somemodule)导入，格式为： import somemodule
    从某个模块中导入某个函数,格式为： from somemodule import somefunction
    从某个模块中导入多个函数,格式为： from somemodule import firstfunc, secondfunc
    将某个模块中的全部函数导入，格式为： from somemodule import * 
    一个模块只会被导入一次，不管你执行了多少次import。
    这样可以防止导入模块被一遍又一遍地执行。
    模块被导入后，就可以使用模块里定义的函数和变量了
    使用的语法为：模块名.函数名()  模块名.变量名
    sys.path变量：
        >>> import sys
        >>> sys.path
        ['', '/usr/lib/python3.4', 
         '/usr/lib/python3.4/plat-x86_64-linux-gnu', 
         '/usr/lib/python3.4/lib-dynload', 
         '/usr/local/lib/python3.4/dist-packages', 
         '/usr/lib/python3/dist-packages']
        sys.path 输出是一个列表，其中第一项是空串''，代表当前目录
        （若是从一个脚本中打印出来的话，可以更清楚地看出是哪个目录）
        通过在当前代码中修改sys.path的值，可以增加搜索路径，
        通过sys.path.append() 方法，添加新的搜索目录后，
        之后的 import 语句，会使用新的 sys.path 搜索模块
        添加的新搜索目录，可以使用相对路径，也可以使用绝对路径
    from ... import：
        直接使用import 模块名 的方式引入的模块
        使用其中定义的函数或变量时，前面要带模块名
        而用from ... import的方式，则可直接使用引入的函数
        不用在引入函数前带函数名（有点类似C++的using效果）
        from .. import *的方式将引入模块中所有的函数和变量
        但这种方式不推荐使用，容易造成名字冲突
    不管是import方式，还是from...import方式，import后面的东西，
    才是真正引入的东西，from只是指定了一个import的基路径。
    import ... as ...
        使用这种方法，可以给引入的模块重命名，
        这在引入包中的模块时，会很有用
        如 import pack1.pack2.modle as abc
        这样，使用modle中的成员时，
        不必 pack1.pack2.modle.func() ， 只需 abc.func()
交互式与脚本式
    命令行直接输入Python，进入交互式状态，通过quit退出
    命令行输入python 脚本文件.py， 则通过解释器执行脚本文件
Python3 解释器
    Python 解释器可不止一种哦，有 CPython、IPython、Jython、PyPy 等。
    顾名思义，CPython 就是用 C 语言开发的了，
    是官方标准实现，拥有良好的生态，所以应用也就最为广泛了。
    而 IPython 是在 CPython 的基础之上在交互式方面得到增强的解释器（http://ipython.org/）。
    Jython 是专为 Java 平台设计的 Python 解释器（http://www.jython.org/），
    它把 Python 代码编译成 Java 字节码执行。
    PyPy 是 Python 语言（2.7.13和3.5.3）的一种快速、兼容的替代实现
    （http://pypy.org/），以速度快著称。
运算符
    算术运算符
        +	两个对象相加，除了两个数字相加外，两个字符串也能相加
        -	一个数减去另一个数，集合类型支持减法，字符串之间不能作减法
        *	一个数乘以另一个数，字符串和数字两个可以相乘
        /	除	    b / a 输出结果 2.1
        %	取模	b % a 输出结果 1
        **	幂	    a**b 为10的21次方
        //	取整除  如果除数和被除数都是整数，则向下取接近商的整数
    比较（关系）运算符
        ==	等于 - 比较对象是否相等	
        !=	不等于 - 比较两个对象是否不相等
        >	大于 - 返回x是否大于y
        <	小于 - 返回x是否小于y。
        >=	大于等于 - 返回x是否大于等于y。
        <=	小于等于 - 返回x是否小于等于y。
        所有比较运算符返回1表示真，返回0表示假。
        这分别与特殊的变量True和False等价。
        注意，这些变量名的大写
    赋值运算符
        =	简单的赋值运算符
        +=	加法赋值运算符	
        -=	减法赋值运算符	
        *=	乘法赋值运算符	
        /=	除法赋值运算符	
        %=	取模赋值运算符	
        **=	幂赋值运算符	
        //=	取整除赋值运算符
        :=	海象运算符，可在表达式内部为变量赋值。
            Python3.8 版本新增运算符。
    逻辑运算符
        not
        and
        or
    位运算符
        &	按位与运算符
        |	按位或运算符
        ^	按位异或运算符
        ~	按位取反运算符
        <<	左移动运算符，空位补0
        >>	右移动运算符，空位补0
    成员运算符
        in     如果在指定的序列中找到值返回 True，否则返回 False
        not in 与in相反
        a = 10
        b = 5
        list = [1, 2, 3, 4, 5 ]
        a in list     :  false
        a not in list :  true
        b in list     :  true
    身份运算符
        is     判断两个标识符是不是引用自一个对象
        is not 判断两个标识符是不是引用自不同对象
        a = 20
        b = 20
        c = 30
        a is b   :  返回true
        id(a) == id(b)   :  返回true
        a is not c  : 返回true
    运算符优先级
        **	        指数 (最高优先级)
        ~ + -	    按位翻转, 一元加号和减号 (最后两个的方法名为 +@ 和 -@)
        * / % //	乘，除，求余数和取整除
        + -	        加法减法
        >> <<	    右移，左移运算符
        &	        位 'AND'
        ^ |	        位运算符
        <= < > >=	比较运算符
        == !=	    等于运算符
        = %= /= //= -= += *= **=	赋值运算符
        is is not	身份运算符
        in not in	成员运算符
        not and or	逻辑运算符
        注意：位运算符的优先级与C语言的不一致
        口诀：指(数)单(目)，基移位比赋值，身份成员逻辑
特殊变量
    _  : 在交互模式中，下划线_在没有被专门赋值时，代表上一步的结果
内置函数
    注意
        py中，像如数字常量，字符串常量等，本质是对象，
        所以"abc".upper()，是支持的。
    数学函数
        abs(x)	    返回数字的绝对值，如abs(-10) 返回 10
        ceil(x)	    返回数字的上入整数，如math.ceil(4.1) 返回 5
        cmp(x, y)   如果 x < y 返回 -1, 如果 x == y 返回 0, 如果 x > y 返回 1。 
                    Python 3 已废弃，使用 (x>y)-(x<y) 替换。
        exp(x)	    返回e的x次幂(ex),如math.exp(1) 返回2.718281828459045
        fabs(x)	    返回数字的绝对值，如math.fabs(-10) 返回10.0
        floor(x)	返回数字的下舍整数，如math.floor(4.9)返回 4
        log(x)	    如math.log(math.e)返回1.0,math.log(100,10)返回2.0
        log10(x)	返回以10为基数的x的对数，如math.log10(100)返回 2.0
        max(x1, x2,...)	返回给定参数的最大值，参数可以为序列。
        min(x1, x2,...)	返回给定参数的最小值，参数可以为序列。
        modf(x)	        返回x的整数部分与小数部分，两部分的数值符号与x相同，整数部分以浮点型表示。
        pow(x, y)	    x**y 运算后的值。
        round(x [,n])	返回浮点数 x 的四舍五入值，如给出 n 值，则代表舍入到小数点后的位数。
                        其实准确的说是保留值将保留到离上一位更近的一端。
                        注意这里有个"坑"：对于奇数，是四舍五入，对于偶数，是五舍六入。
                        但其实这是个新的计算标准：“4舍6入5看齐,奇进偶不进”，从而使结果倾向于偶数，
                        而国家标准也已经规定使用该方法取代原来的"四舍五入".
        sqrt(x)	        返回数字x的平方根。
    随机数函数
        choice(seq)	    从序列的元素中随机挑选一个元素，
                        比如random.choice(range(10))，从0到9中随机挑选一个整数。
        randrange ([start,] stop [,step])	从指定范围内，
                        按指定基数递增的集合中获取一个随机数，基数默认值为 1
        random()	    随机生成下一个实数，它在[0,1)范围内。
        seed([x])	    改变随机数生成器的种子seed。如果你不了解其原理，
                        你不必特别去设定seed，Python会帮你选择seed。
        shuffle(lst)	将序列的所有元素随机排序
        uniform(x, y)	随机生成下一个实数，它在[x,y]范围内。
    三角函数
        acos(x)	    返回x的反余弦弧度值。
        asin(x)	    返回x的反正弦弧度值。
        atan(x)	    返回x的反正切弧度值。
        atan2(y, x)	返回给定的 X 及 Y 坐标值的反正切值。
        cos(x)	    返回x的弧度的余弦值。
        hypot(x, y)	返回欧几里德范数 sqrt(x*x + y*y)。
        sin(x)	    返回的x弧度的正弦值。
        tan(x)	    返回x弧度的正切值。
        degrees(x)	将弧度转换为角度,如degrees(math.pi/2) ， 返回90.0
        radians(x)	将角度转换为弧度
    字符串函数
        capitalize()    将字符串的第一个字符转换为大写
        center(width, fillchar)
                        返回一个指定的宽度 width 居中的字符串，fillchar 为填充的字符，默认为空格。
        count(str, beg= 0,end=len(string))
                        返回 str 在 string 里面出现的次数，
                        如果 beg 或者 end 指定则返回指定范围内 str 出现的次数
        bytes.decode(encoding="utf-8", errors="strict")
                        Python3 中没有 decode 方法，但我们可以使用 bytes 对象的 decode() 
                        方法来解码给定的 bytes 对象，这个 bytes 对象可以由 str.encode() 来编码返回。
        encode(encoding='UTF-8',errors='strict')
                        以 encoding 指定的编码格式编码字符串，如果出错默认报一个ValueError 的异常，
                        除非 errors 指定的是'ignore'或者'replace'
        endswith(suffix, beg=0, end=len(string))
                        检查字符串是否以 obj 结束，如果beg 或者 end 指定则检查指定的范围内
                        是否以 obj 结束，如果是，返回 True,否则返回 False.
        expandtabs(tabsize=8)
                        把字符串 string 中的 tab 符号转为空格，tab 符号默认的空格数是 8 。
        find(str, beg=0, end=len(string))
                        检测 str 是否包含在字符串中，如果指定范围 beg 和 end ，
                        则检查是否包含在指定范围内，如果包含返回开始的索引值，否则返回-1
        index(str, beg=0, end=len(string))
                        跟find()方法一样，只不过如果str不在字符串中会报一个异常。
        isalnum()       如果字符串至少有一个字符并且所有字符都是字母或数字则返 回 True，否则返回 False
        isalpha()       如果字符串至少有一个字符并且所有字符都是字母或中文字则返回 True, 否则返回 False
        isdigit()       如果字符串只包含数字则返回 True 否则返回 False..
        islower()       如果字符串中包含至少一个区分大小写的字符，并且所有这些(区分大小写的)字符都是小写，
                        则返回 True，否则返回 False
        isnumeric()     如果字符串中只包含数字字符，则返回 True，否则返回 False
        isspace()       如果字符串中只包含空白，则返回 True，否则返回 False.
        istitle()       如果字符串是标题化的(见 title())则返回 True，否则返回 False
        isupper()       如果字符串中包含至少一个区分大小写的字符，
                        并且所有这些(区分大小写的)字符都是大写，则返回 True，否则返回 False
        join(seq)       以指定字符串作为分隔符，将 seq 中所有的元素(的字符串表示)合并为一个新的字符串
        len(string)     返回字符串长度
        ljust(width[, fillchar])
                        返回一个原字符串左对齐,并使用 fillchar 填充至长度 width 的新字符串，fillchar 默认为空格。
        lower()         转换字符串中所有大写字符为小写.
        lstrip()        截掉字符串左边的空格或指定字符。
        maketrans()     创建字符映射的转换表，对于接受两个参数的最简单的调用方式，
                        第一个参数是字符串，表示需要转换的字符，第二个参数也是字符串表示转换的目标。
        max(str)        返回字符串 str 中最大的字母。
        min(str)        返回字符串 str 中最小的字母。
        replace(old, new [, max])
                        把 将字符串中的 old 替换成 new,如果 max 指定，则替换不超过 max 次。
        rfind(str, beg=0,end=len(string))
                        类似于 find()函数，不过是从右边开始查找.
        rindex( str, beg=0, end=len(string))
                        类似于 index()，不过是从右边开始.
        rjust(width,[, fillchar])
                        返回一个原字符串右对齐,并使用fillchar(默认空格）填充至长度 width 的新字符串
        rstrip()        删除字符串末尾的空格或指定字符。
        split(str="", num=string.count(str))
                        以 str 为分隔符截取字符串，如果 num 有指定值，则仅截取 num+1 个子字符串
        splitlines([keepends])
                        按照行('\r', '\r\n', '\n')分隔，返回一个包含各行作为元素的列表，
                        如果参数 keepends 为 False，不包含换行符，如果为 True，则保留换行符。
        startswith(substr, beg=0,end=len(string))
                        检查字符串是否是以指定子字符串 substr 开头，是则返回 True，否则返回 False。
                        如果beg 和 end 指定值，则在指定范围内检查。
        strip([chars])  在字符串上执行 lstrip()和 rstrip()
        swapcase()      将字符串中大写转换为小写，小写转换为大写
        title()        返回"标题化"的字符串,就是说所有单词都是以大写开始，其余字母均为小写(见 istitle())
        translate(table, deletechars="")
                        根据 str 给出的表(包含 256 个字符)转换 string 的字符, 
                        要过滤掉的字符放到 deletechars 参数中
        upper()         转换字符串中的小写字母为大写
        zfill (width)   返回长度为 width 的字符串，原字符串右对齐，前面填充0
        isdecimal()     检查字符串是否只包含十进制字符，如果是返回 true，否则返回 false。
    列表相关函数
        len(list)   列表元素个数
        max(list)   返回列表元素最大值
        min(list)   返回列表元素最小值
        list(seq)   将元组转换为列表
        del(list[s1:s2:s3])     根据索引位置删除若干列表元素
        del list                删除列表对象
        list.copy()             复制列表
    	list.clear()            清空列表
        list.reverse()          反向列表中元素
        list.append(obj)        在列表末尾添加新的对象
        list.count(obj)         统计某个元素在列表中出现的次数
        list.index(obj)         从列表中找出某个值第一个匹配项的索引位置
        list.remove(obj)        移除列表中某个值的第一个匹配项
        list.extend(seq)        在列表末尾一次性追加另一个序列中的多个值
                                （用新列表扩展原来的列表）
        list.pop([index=-1])    移除列表中的一个元素（默认最后一个元素），
                                并且返回该元素的值
    	list.insert(index, obj) 将对象插入列表
        list.sort( key=None, reverse=False) 对原列表进行排序
        list.append(x)	        把一个元素添加到列表的结尾，相当于 a[len(a):] = [x]。
        list.extend(L)	        通过添加指定列表的所有元素来扩充列表，相当于 a[len(a):] = L。
        list.insert(i, x)	    在指定位置插入一个元素。
                                第一个参数是准备插入到其前面的那个元素的索引，
                                例如 a.insert(0, x) 会插入到整个列表之前，
                                而 a.insert(len(a), x) 相当于 a.append(x) 。
        list.remove(x)	        删除列表中值为 x 的第一个元素。
                                如果没有这样的元素，就会返回一个错误。
        list.pop([i])	        从列表的指定位置移除元素，并将其返回。
                                如果没有指定索引，a.pop()返回最后一个元素。元素随即从列表中被移除。
                                '''方法中 i 两边的方括号表示这个参数是可选的，
                                而不是要求你输入一对方括号，
                                你会经常在 Python 库参考手册中遇到这样的标记。'''
        list.clear()	        移除列表中的所有项，等于del a[:]。
        list.index(x)	        返回列表中第一个值为 x 的元素的索引。
                                如果没有匹配的元素就会返回一个错误。
        list.count(x)	        返回 x 在列表中出现的次数。
        list.sort()	            对列表中的元素进行排序。
        list.reverse()	        倒排列表中的元素。
        list.copy()	            返回列表的浅复制，等于a[:]。
    未分类
        zip([iterable, ...])    注意参数里的[]表示可选的意思，而不是列表的意思，该函数的功能是：
                                将参数传来的可迭代对象按位置依次提取，每次提取到的元素组成一个元组
                                直到某个可迭代对象提取结束，然后以这些元组为元素，组成一个列表返回
                                可见，如果将zip返回的列表，通过*解包，将又得到m个元组，
                                这些元组又是可迭代对象，可再次作为zip的参数
            例：
            >>> a = [1,2,3]
            >>> b = [4,5,6]
            >>> c = [4,5,6,7,8]
            >>> zipped = zip(a,b)     # 打包为元组的列表
            [(1, 4), (2, 5), (3, 6)]
            >>> zip(a,c)              # 元素个数与最短的列表一致
            [(1, 4), (2, 5), (3, 6)]
            >>> zip(*zipped)          # 与 zip 相反，*zipped 可理解为解压，返回二维矩阵式
            [(1, 2, 3), (4, 5, 6)]
*的用法  &<*的用法>
    参：https://blog.csdn.net/zkk9527/article/details/88675129
    1. 乘法运算
    2. 字符串重复
    3. 幂乘
       两个**相当于C语言中的^，用于指数运算
    4. 收集列表中多余的值
       如：a,b,*c=[1,2,3,4]
       这里的*c相当于是个列表类型，a存1，b存2，c存[3,4]
    5. 用在函数定义时
       *相当于声明元组类型，**相当于声明字典类型
       def func(*vars):
           print(type(vars))   #输出结果为： <class 'tuple'>
       def func(**vars):
           print(type(vars))   #输出结果为： <class 'dict'>
    6. 用在函数调用时
       *起到元组解包的作用，就是把一个元组类型变量解包成多个元素变量
       **起字典解包的作用
       **vars 作为函数参数时，接受的实参页面也需要是带 ** 的
流程控制
    条件控制
        if condition_1:
            statement_block_1
        elif condition_2:
            statement_block_2
        else:
            statement_block_3
        py中没有switch case控制语句
        None为"NoneType"类型，在条件表示式中表示假
        条件语句可以用小括号括起来，也可以不用括号
        语句只有一行时，可以与if写在同一行
    循环语句
        1.  while
            while condition:
                statements
        2.  while  else
            while <expr>:
                <statement(s)>
            else:  
                <additional_statement(s)>
            如果 while 后面的条件语句为 false 时，则执行 else 的语句块。
            类似if语句的语法，如果你的while循环体中只有一条语句，
            你可以将该语句与while写在同一行中
        3.  for
            Python for 循环可以遍历任何可迭代对象，
            如一个列表或者一个字符串
            for <variable> in <sequence>:
                <statements>
            else:
                <statements>
            如果你需要遍历数字序列，可以使用内置range()函数，它会生成数列
            for i in range(5): print(i)
            结合range()和len()函数以遍历一个序列
            >>>a = ['Google', 'Baidu', 'Runoob', 'Taobao', 'QQ']
            >>>for i in range(len(a)):
            ...    print(i, a[i])
        4.  for else
            循环语句可以有 else 子句，它在穷尽列表(以for循环)
            或条件变为 false (以while循环)导致循环终止时被执行
        5.  break，continue
            中断循环，进入下一循环
    pass语句  空语句，相当于C语言中的(0);
迭代器
    迭代器是一个可以记住遍历的位置的对象。
    迭代器对象从集合的第一个元素开始访问，直到所有的元素被访问完结束。
    py中只有前向迭代器，迭代器只能往前不会后退。
    迭代器有两个基本的方法：iter() 和 next()。
    字符串，列表或元组对象都可用于创建迭代器
    自定义类要想支持迭代器，需要提供__iter__()和__next__()
    另：py类的构造函数固定名为__init__()
    __iter__() 方法返回一个特殊的迭代器对象， 
    这个迭代器对象实现了__next__()方法并通过 StopIteration 异常标识迭代的完成
    __next__() 方法（Python 2 里是 next()）会返回下一个迭代器对象。
    例：
        class MyNumbers:
          def __iter__(self):  #__iter__方法返回参数本身，同时完成初始化，位置指向0
            self.a = 1
            return self
          def __next__(self):  #__next__方法返回参数的内部成员值，同时指向下一位置
            x = self.a
            self.a += 1
            return x
        iter0=MyNumbers()  #虽然iter0是迭代器对象，但还没有调用__iter__()方法
        iter1=iter(iter0)  #调用了__iter__()方法
    iter()与__iter___()
        py中有两种类型：Iterator 迭代器、Iterable 可迭代对象
            凡是可以for循环的 都属于 iterable 可迭代对象
            凡是可以next（)的 都是iterator 迭代器
            可迭代对象(iterble)并不一定是迭代器(iterator)
            迭代器(iterator)一定是可迭代对象(iterable)
            例如：字符串是可迭代对象，但并不是迭代器
        Iter（）与 __iter__ 用于产生 iterator（迭代器）
            凡是实现__iter__()和__next__()函数的对象，
            皆是迭代器对象。
            自定义类MyClass实现了这两个函数
            >>> from collections import Iterable,Iterator
            >>> mc = MyClass()
            >>> print isinstance(mc,Iterator)
            True   #当没有实现__iter__()或__next__()时，返回False
        Iter()迭代器工厂函数
            凡是有定义有__iter__()函数，或者支持序列访问协议，
            也就是定义有__getitem__()函数的对象 
            皆可以通过iter()工厂函数产生迭代器(iterable)对象
            >>> from collections import Iterable,Iterator
            >>> s = "asdf"
            >>> print isinstance(s,Iterator)
            False
            >>> s=Iter(s)
            >>> print isinstance(s,Iterator)
            True
生成器
    所谓生成器，就是代码中使用到了yield关键字的函数
    普通的函数，返回值类型根据return的类型而定，
    而这样的函数，返回值类型固定为迭代器类型<class 'generator'>
    与return相比，yield起到的效果是“记忆返回”：
        像所有的迭代器一样，第一次调用迭代器对象的__next__()方法时，
        才真正从开始处执行函数体，并在遇到yield时返回其后的值，
        并且它能记住此次返回的位置及上下文，下次再调用__next__()方法时，
        从上次返回的位置处继续往下执行，直到再次遇到yield，
        如此循环，直到函数体彻底执行完毕，并产生StopIteration异常，
        迭代器的调用者通常应该识别该异常。
    深入理解：
        应该结合函数对象的概念进行理解：
        函数名指代的就是该函数对象
        函数名()，是执行的"函数对象"的"括号运算"方法
        对普通的"函数对象"而言，"括号运算"方法，就是执行函数体
        "括号运算"的返回类型依据return的数据而定
        而对于生成器类函数对象，其"括号运算"方法返回的类型为 generator 类型
        （generator类型为Iterator的派生类型）
        而该迭代器类型负责"把控"函数体的执行：
            它可以维护当前函数体的执行位置和上下文
            它的__next__()成员方法负责从上次记忆位置执行函数体
            __next__()每次返回的数据类型，由本次遇到yield时其后的类型而定
    举例：
        >>> def func3():
        ...     print("---1---")        #函数体第1句
        ...     yield 1                 #函数体第2句
        ...     print("---a---")        #函数体第3句
        ...     yield "a"               #函数体第4句
        ...     print("---[1,2]---")    #函数体第5句
        ...     yield [1,2]             #函数体第6句
        ...     print("---finish---")   #函数体第7句
        ...
        >>> f3=func3()      #这里得到的f3固定为迭代器对象
        >>> type(f3)
        <class 'generator'>
        >>> from collections import Iterable,Iterator
        >>> print(isinstance(f3,Iterator))
        True                #表明返回的是迭代器类型，亦即支持__next__()方法
        >>> r1=next(f3)     #第一次调用next(),从函数体开始处执行，执行完函数体第2句后返回
        ---1---             #函数体第1句执行的结果
        >>> type(r1)        #r1存放的是 yield 1 返回的结果，整数型
        <class 'int'>
        >>> r2=f3.__next__()#再调用next()，从上次位置（函数体的第3句）执行，执行完函数体第4句后返回
        ---a---             #函数体第3句执行的结果
        >>> type(r2)        #r2存放的是 yield "a" 返回的结果，字符串型
        <class 'str'>       
        >>> r3=next(f3)     #再调用next()，从上次位置（函数体的第5句）执行，执行完函数体第6句后返回
        ---[1,2]---         #函数体第5句执行的结果
        >>> type(r3)        #r3存放的是 yield [1,2] 返回的结果，列表型
        <class 'list'>
        >>> r4=next(f3)     #再调用next()，从上次位置（函数体的第7句）执行，执行完后发出异常
        ---finish---        #函数体第7句执行的结果
        Traceback (most recent call last):
          File "<stdin>", line 1, in <module>
        StopIteration
函数
    def 函数名([参数名[=默认值],...]):
        函数体
        [return [返回值]]      #不带return表达式的，相当于返回None
    函数体内对参数的修改
        当传入的参数指向的是不可变对象时，
        函数内对参数的重新赋值，则只是使该参数指向了新的对象，
        对函数调用者没有任何影响
        当传入的参数指向的是可变对象时，
        如果函数体内参数指向一个新对象，同样只是使该参数指向了新的对象，
        对函数调用者没有任何影响
        但如果是通过参数名修改对象的成员，
        则修改的是指向的可变对象的值，
        此时对函数的调用者是有影响的，因为它和函数参数指向的是同一位置
        可见，py中的参数和C语言中的指针型参数是一样的：
        void func(char *p)   
        {
            p[2]='x';       //修改变量的子元素，p对指向对象的内容作修改
            p="asdf";       //直接给变量赋值，p指向新的对象
        }
    关键字参数（命名参数）
        调用函数传参时，可以显式指定给哪个参数赋值，
        这种传参方式的好处是，可以不按顺序给参数赋值
        这对于有很多参数，且各参数都有默认值的情况下是有用的
        如: def func(param3="asdf",param2=123)
    不定长参数（可变参数）
        参"*的用法"一节
        不定长参数，是元组类型
        定义函数的可变参数需要在形参前面加一个星号（*）
        其实可变参数也可以放在函数参数的中间或最前面，
        只是在调用函数时，可变参数后面的普通参数要使用命名参数形式传递参数值。
        当可变参数放在中间时，它会把所有的非命名参数吸收掉，
        例如：def f(a,b,*c,d,e)
        调用时，f(1,2,3,4,5) 会报错，
        这是因为 3，4，5 都被可变参数 c 吸收了，要想给 d、e 赋值，
        只能通过命名参数的方式赋值
        要把一个元组或列表拆分后，作为参数传给函数，
        不应该用 lst[:] 这样的形式，而应该用 *lst 这样的形式
        lst[:] 会返回一个 <class 'list'> 类型，而并不是将该变量分解
        举例： 
            def f2(*p): print(p)
            f2(*"asdf")         #在字符串前面也可使用*
            f2(*[1,2,3,4])      #在列表值/元组值前面，也可使用*
            l=[1,2,3,4]; f2(*l) #在列表变量/元组变量前面使用*
        扩展：
            变量前面带一个*时，该变量是元组类型，可接受多个实参
            还可在变量前面带**，此时该变量是字典类型
            也就是说，在传递参数时，字典和列表（元组）的区别是
            字典前面需要加两个星号（**）(定义函数与调用函数都需要加两个星号)
            如果在定义函数时，参数未加两个星号（**），
            那么在调用该函数时，也不能加两个星号（**）
            举例：
                d={"name":"zhangsan","age":13}
                print(d)   # 输出 {'name': 'zhangsan', 'age': 13}
                def f3(**m1):
                    m1["age"]=14
                f3(**d)    # 赋值时，应该和参数一样，对应用 **
                print(d)   # 输出 {'name': 'zhangsan', 'age': 13}
                def f4(m2):
                    m2["age"]=15
                f4(d)
                print(d)   # 输出 {'name': 'zhangsan', 'age': 15}
            对上例的解说：
                函数f3的调用，是将字典分解后的各元素，作为参数，传给 f3
                而参数 m1 会接受传入的各元素， m1 固定是个元组类型
                注意此时的 m1 不是变量 d 的另一个引用，
                所以对 m1 字典成员的修改，不会影响到实参 d
                而对f4的调用，m2就是实参 d 的另一个引用，
                通过m2，对字典元组的修改，会影响到实参 d 的值
    带默认值的参数
        带默认值的参数必须放在最后，
        也就是说，带默认的参数后面的参数，也要求带默认值
    匿名函数（lambda表达式）
        语法： lambda [arg1 [,arg2,...]]:expression
        可见py中的lambda表达式，功能非常有限：
            函数体只能写一行(表达式)
            以表达式的结果作为匿名函数的返回值
            lambda 函数拥有自己的命名空间，
            不能访问自己参数列表之外或全局命名空间里的参数
        举例：
            sum = lambda arg1, arg2: arg1 + arg2
            c = sum(1,2)
    嵌套函数：
        在函数内部可以再定义函数
        但函数内部定义的函数，通常只在外层函数中可见
        定义的内层函数，就像外层函数中的定义的变量一样，
        可以作为外层函数的返回值进行返回
        甚至因为函数的返回值有自动封包的特点，
        所以还可将多个内部函数作为外部函数的返回值
        但这种技术手段因为可读性不强，所以应用度不高
        举例：
            def func1():
                def f1():
                    print("this is f1")
                def f2():
                    print("this is f2")
                def f3():
                    print("this is f3")
                return f1,f2,f3
            func1()[0]()  # 输出 this is f1
            func1()[1]()  # 输出 this is f2
            func1()[2]()  # 输出 this is f3
    函数注释
        在紧跟函数声明的下一行，
        使用 ""，或 """ """
        可以为函数添加函数说明
        这种函数说明，跟通过＃或 ''' '''形式添加的注释不同
        这种函数的注释，不会被编译器预处理掉，
        而是会编译到代码中
        通过 help(函数名)，或 函数名.__doc__
        可以查看该函数注释
    Python不支持函数重载
        一种简单的解释是，函数参数的变量类型是动态的，
        所以不能通过参数类型，区分调用哪个重名的函数
        而且因为Python支持可变参数，
        所以通过参数个数区分函数重载，似乎也是不可行的
列表推导式
    列表推导式提供了从序列创建列表的简单途径
    语法：
        [变量表达式 for 变量 in 序列 <if 变量过滤条件>  \
                   <for 变量 in 序列 <if 变量过滤条件>> \
                   <for 变量 in 序列 <if 变量过滤条件>> \
                   ... ]
        #尖括号中的，表明是可选的，如果有多个for-in-if，
        #则它们是嵌套关系，每次最内层循环，等能取到一个变量值
    例：
        [x*y for x in range(1,5) if x > 2 for y in range(1,4) if y < 3]
        他的执行顺序是:
        for x in range(1,5)
            if x > 2
                for y in range(1,4)
                    if y < 3
                        x*y
    例：
        >>> vec = [2, 4, 6]
        >>> [3*x for x in vec]
        [6, 12, 18]
        >>> [[x, x**2] for x in vec]
        [[2, 4], [4, 16], [6, 36]]
        >>> [3*x for x in vec if x > 3]
        [12, 18]
        >>> vec1 = [2, 4, 6]
        >>> vec2 = [4, 3, -9]
        >>> [x*y for x in vec1 for y in vec2]
        [8, 6, -18, 16, 12, -36, 24, 18, -54]
        >>> [vec1[i]*vec2[i] for i in range(len(vec1))]
        [8, 12, -54]
        #注：355/113=3.1415929203539825
        >>> [str(round(355/113, i)) for i in range(1, 6)]
        ['3.1', '3.14', '3.142', '3.1416', '3.14159']
集合推导式
    集合推导式的语法与列表推导式基本相同，区别就是两边是用大括号括起来的
模块
    <关联节点：import 与 from...import>
    模块是一个包含你所定义的函数和变量的文件，其后缀名是.py
    传给模块的参数，通过py内置模块sys来获取
    例：
        import sys
        print('命令行参数如下:')
        for i in sys.argv:
           print(i)         #当前模块的文件作为传入的第一个参数
    1、import sys 引入 python 标准库中的 sys.py 模块；这是引入某一模块的方法。
    2、sys.argv 是一个包含命令行参数的列表。
    3、sys.path 包含了一个 Python 解释器自动查找所需模块的路径的列表。
    模块中的代码
        模块除了方法定义，还可以包括可执行的代码。
        这些代码一般用来初始化这个模块。
        这些代码只有在第一次被导入时才会被执行
        如果某个模块文件已经被导入，再修改该模块文件时，文件也不能重新导入
    模块对象
        应该以对象的观念去理解模块
        import的模块，算是一个模块对象
        >>> import sys
        >>> type(sys)
        <class 'module'>
        因此模块中的变量、函数等，都是该模块对象的成员
        当成员名字以_开头，则该成员是私有的，否则是公有的
        当模块文件中引入了别的模块时，
        引入的模块，作为当前模块的一个成员（模块类型）而存在
    __name__属性
        __name__可认为是个py内置变量，
        当通过python 文件名.py 的方式执行py文件时，__name__=="__main__"
        如果通过import 模块名 的方式来引入py文件时，__name__==模块名
        所以我们可以通过if __name__ == '__main__': 
        来控制哪些代码在被引入时被执行，哪些代码在通过python打开时执行
    dir([模块名])
        通过这种方法，可以查看导入模块的所有成员，包括以_开头的成员
        如果dir()没有给定参数，则列出当前代码环境中所有的"成员"
    标准模块
        Python 本身带着一些标准的模块库
        有些模块直接被构建在解析器里，这些虽然不是一些语言内置的功能，
        但是他却能很高效的使用，甚至是系统级调用也没问题。
        这些组件会根据不同的操作系统进行不同形式的配置，
        比如 winreg 这个模块就只会提供给 Windows 系统。
        应该注意到这有一个特别的模块 sys ，它内置在每一个 Python 解析器中
        变量 sys.ps1 和 sys.ps2 定义了主提示符和副提示符所对应的字符串
        >>> import sys
        >>> sys.ps1
        '>>> '
        >>> sys.ps2
        '... '
包
    包 跟Java中的包有类似的含义，但稍有区别：
    目录只有包含一个叫做 __init__.py 的文件才会被认作是一个包
    __init__.py中可以不放任何内容，也可以放一些包引入时的初始化代码
    __init__.py文件只在第一次导入包中的模块时被执行，
    引入包中模块的方法：import 包名[.二级包名.三级包名....].模块名
    经观测，此第一次导入包后，在包文件夹下会多出个__pycache__的文件夹
    __pycache__的文件夹中的文件名与包中的文件名是对应的，
    命名格式为 包中模块名.cpython-39.pyc
    包是可以嵌套的，但注意每层嵌套的包，都应该各有一个__init__.py文件
    访问包中的模块中的成员，格式为：包名[.二级包名....].模块名.成员名
    还可以用 from 包名[.二级包名.三级包名....] import 包名 这样的语法
    这样，访问模块中的成员时，可以不带包名，这样使用方便了，但也不见得
    都是好处，因为包的出现，本质是为了解决模块重名的问题，
    所以在实际引入时，应根据实际情况决定使用import，还是from...import
    注意：windows下的文件夹名是不区分大小写的，但py是区分大小写的，
    这意味着，一个包名叫Abc，在windows目录下，它和ABC、aBC等等这样的命名
    完全没有区别，但在py中，必须严格按包名的大小写进行指定，否则会找不到
文件读写
    打开关闭文件
        Python open() 方法用于打开一个文件，并返回文件对象
        如果该文件无法被打开，会抛出 OSError。
        使用 open() 方法一定要保证关闭文件对象，即调用 close() 方法。
        语法： open(file, mode='r', buffering=-1, encoding=None, 
                    errors=None, newline=None, closefd=True, opener=None)
            encoding: 一般使用utf8
            errors: 报错级别
            newline: 区分换行符
            mode:
                t	文本模式 (默认)。
                x	写模式，新建一个文件，如果该文件已存在则会报错。
                b	二进制模式。
                +	打开一个文件进行更新(可读可写)。
                U	通用换行模式（Python 3 不支持）。
                r	以只读方式打开文件。
                    文件的指针将会放在文件的开头。这是默认模式。
                rb	以二进制格式打开一个文件用于只读。
                    文件指针将会放在文件的开头。这是默认模式。
                    一般用于非文本文件如图片等。
                r+	打开一个文件用于读写。文件指针将会放在文件的开头。
                rb+	以二进制格式打开一个文件用于读写。
                    文件指针将会放在文件的开头。
                    一般用于非文本文件如图片等。
                w	打开一个文件只用于写入。
                    如果该文件已存在则打开文件，并从开头开始编辑，
                    即原有内容会被删除。如果该文件不存在，创建新文件。
                wb	以二进制格式打开一个文件只用于写入。
                    如果该文件已存在则打开文件，并从开头开始编辑，
                    即原有内容会被删除。如果该文件不存在，创建新文件。
                    一般用于非文本文件如图片等。
                w+	打开一个文件用于读写。
                    如果该文件已存在则打开文件，并从开头开始编辑，
                    即原有内容会被删除。如果该文件不存在，创建新文件。
                wb+	以二进制格式打开一个文件用于读写。
                    如果该文件已存在则打开文件，并从开头开始编辑，即原有内容会被删除。
                    如果该文件不存在，创建新文件。一般用于非文本文件如图片等。
                a	打开一个文件用于追加。
                    如果该文件已存在，文件指针将会放在文件的结尾。
                    也就是说，新的内容将会被写入到已有内容之后。
                    如果该文件不存在，创建新文件进行写入。
                ab	以二进制格式打开一个文件用于追加。
                    如果该文件已存在，文件指针将会放在文件的结尾。
                    也就是说，新的内容将会被写入到已有内容之后。
                    如果该文件不存在，创建新文件进行写入。
                a+	打开一个文件用于读写。如果该文件已存在，文件指针将会放在文件的结尾。
                    文件打开时会是追加模式。如果该文件不存在，创建新文件用于读写。
                ab+	以二进制格式打开一个文件用于追加。
                    如果该文件已存在，文件指针将会放在文件的结尾。
                    如果该文件不存在，创建新文件用于读写。
    常用的 file 对象的成员方法
        file.close()
            关闭文件。关闭后文件不能再进行读写操作。
        file.flush()
            新文件内部缓冲，直接把内部缓冲区的数据立刻写入文件, 
            而不是被动的等待输出缓冲区写入。
        file.fileno()
            返回一个整型的文件描述符(file descriptor FD 整型), 
            可以用在如os模块的read方法等一些底层操作上。
        file.isatty()
            如果文件连接到一个终端设备返回 True，否则返回 False。
        file.next()
            返回文件下一行。
            Python 3 中的 File 对象不支持 next() 方法。
        file.read([size])
            从文件读取指定的字节数，如果未给定或为负则读取所有。
        file.readline([size])
            读取整行，包括 "\n" 字符。
        file.readlines([sizeint])
            读取所有行并返回列表，若给定sizeint>0，
            返回总和大约为sizeint字节的行, 
            实际读取值可能比 sizeint 较大, 因为需要填充缓冲区。
        file.seek(offset[, whence])
            移动文件读取指针到指定位置
        file.tell()
            返回文件当前位置。
        file.truncate([size])
            从文件的首行首字符开始截断，截断文件为 size 个字符，
            无 size 表示从当前位置截断；截断之后后面的所有字符被删除，
            其中 windows 系统下的换行代表2个字符大小。
        file.write(str)
            将字符串写入文件，返回的是写入的字符长度。
        file.writelines(sequence)
            向文件写入一个序列字符串列表，如果需要换行则要自己加入每行的换行符。
os模块
    os模块提供了非常丰富的方法用来处理文件和目录。
    os.access(path, mode)
        检验权限模式
    os.chdir(path)
        改变当前工作目录
    os.chflags(path, flags)
        设置路径的标记为数字标记。
    os.chmod(path, mode)
        更改权限
    os.chown(path, uid, gid)
        更改文件所有者
    os.chroot(path)
        改变当前进程的根目录
    os.close(fd)
        关闭文件描述符 fd
    os.closerange(fd_low, fd_high)
        关闭所有文件描述符，从 fd_low (包含) 到 fd_high (不包含), 错误会忽略
    os.dup(fd)
        复制文件描述符 fd
    os.dup2(fd, fd2)
        将一个文件描述符 fd 复制到另一个 fd2
    os.fchdir(fd)
        通过文件描述符改变当前工作目录
    os.fchmod(fd, mode)
        改变一个文件的访问权限，该文件由参数fd指定，
        参数mode是Unix下的文件访问权限。
    os.fchown(fd, uid, gid)
        修改一个文件的所有权，这个函数修改一个文件的用户ID和用户组ID，
        该文件由文件描述符fd指定。
    os.fdatasync(fd)
        强制将文件写入磁盘，该文件由文件描述符fd指定，
        但是不强制更新文件的状态信息。
    os.fdopen(fd[, mode[, bufsize]])
        通过文件描述符 fd 创建一个文件对象，并返回这个文件对象
    os.fpathconf(fd, name)
        返回一个打开的文件的系统配置信息。
        name为检索的系统配置的值，它也许是一个定义系统值的字符串，
        这些名字在很多标准中指定（POSIX.1, Unix 95, Unix 98, 和其它）。
    os.fstat(fd)
        返回文件描述符fd的状态，像stat()。
    os.fstatvfs(fd)
        返回包含文件描述符fd的文件的文件系统的信息，
        Python 3.3 相等于 statvfs()。
    os.fsync(fd)
        强制将文件描述符为fd的文件写入硬盘。
    os.ftruncate(fd, length)
        裁剪文件描述符fd对应的文件, 所以它最大不能超过文件大小。
    os.getcwd()
        返回当前工作目录
    os.getcwdb()
        返回一个当前工作目录的Unicode对象
    os.isatty(fd)
        如果文件描述符fd是打开的，同时与tty(-like)设备相连，则返回true, 否则False。
    os.lchflags(path, flags)
        设置路径的标记为数字标记，类似 chflags()，但是没有软链接
    os.lchmod(path, mode)
        修改连接文件权限
    os.lchown(path, uid, gid)
        更改文件所有者，类似 chown，但是不追踪链接。
    os.link(src, dst)
        创建硬链接，名为参数 dst，指向参数 src
    os.listdir(path)
        返回path指定的文件夹包含的文件或文件夹的名字的列表。
    os.lseek(fd, pos, how)
        设置文件描述符 fd当前位置为pos, 
        how方式修改: 
        SEEK_SET 或者 0 设置从文件开始的计算的pos; 
        SEEK_CUR或者 1 则从当前位置计算; 
        os.SEEK_END或者2则从文件尾部开始. 在unix，Windows中有效
    os.lstat(path)
        像stat(),但是没有软链接
    os.major(device)
        从原始的设备号中提取设备major号码 (使用stat中的st_dev或者st_rdev field)。
    os.makedev(major, minor)
        以major和minor设备号组成一个原始设备号
    os.makedirs(path[, mode])
        递归文件夹创建函数。
        像mkdir(), 但创建的所有intermediate-level文件夹需要包含子文件夹。
    os.minor(device)
        从原始的设备号中提取设备minor号码 (使用stat中的st_dev或者st_rdev field )。
    os.mkdir(path[, mode])
        以数字mode的mode创建一个名为path的文件夹.默认的 mode 是 0777 (八进制)。
    os.mkfifo(path[, mode])
        创建命名管道，mode 为数字，默认为 0666 (八进制)
    os.mknod(filename[, mode=0600, device])
        创建一个名为filename文件系统节点（文件，设备特别文件或者命名pipe）。
    os.open(file, flags[, mode])
        打开一个文件，并且设置需要的打开选项，mode参数是可选的
    os.openpty()
        打开一个新的伪终端对。返回 pty 和 tty的文件描述符。
    os.pathconf(path, name)
        返回相关文件的系统配置信息。
    os.pipe()
        创建一个管道. 返回一对文件描述符(r, w) 分别为读和写
    os.popen(command[, mode[, bufsize]])
        从一个 command 打开一个管道
    os.read(fd, n)
        从文件描述符 fd 中读取最多 n 个字节，返回包含读取字节的字符串，
        文件描述符 fd对应文件已达到结尾, 返回一个空字符串。
    os.readlink(path)
        返回软链接所指向的文件
    os.remove(path)
        删除路径为path的文件。如果path 是一个文件夹，将抛出OSError; 
        查看下面的rmdir()删除一个 directory。
    os.removedirs(path)
        递归删除目录。
    os.rename(src, dst)
        重命名文件或目录，从 src 到 dst
    os.renames(old, new)
        递归地对目录进行更名，也可以对文件进行更名。
    os.rmdir(path)
        删除path指定的空目录，如果目录非空，则抛出一个OSError异常。
    os.stat(path)
        获取path指定的路径的信息，功能等同于C API中的stat()系统调用。
    os.stat_float_times([newvalue])
        决定stat_result是否以float对象显示时间戳
    os.statvfs(path)
        获取指定路径的文件系统统计信息
    os.symlink(src, dst)
        创建一个软链接
    os.tcgetpgrp(fd)
        返回与终端fd（一个由os.open()返回的打开的文件描述符）关联的进程组
    os.tcsetpgrp(fd, pg)
        设置与终端fd（一个由os.open()返回的打开的文件描述符）关联的进程组为pg。
    os.tempnam([dir[, prefix]])
        返回唯一的路径名用于创建临时文件。
        Python3 中已删除。
    os.tmpfile()
        返回一个打开的模式为(w+b)的文件对象 .
        这文件对象没有文件夹入口，没有文件描述符，将会自动删除。
        Python3 中已删除。
    os.tmpnam()
        为创建一个临时文件返回一个唯一的路径
        Python3 中已删除。
    os.ttyname(fd)
        返回一个字符串，它表示与文件描述符fd 关联的终端设备。
        如果fd 没有与终端设备关联，则引发一个异常。
    os.unlink(path)
        删除文件路径
    os.utime(path, times)
        返回指定的path文件的访问和修改的时间。
    os.walk(top[, topdown=True[, onerror=None[, followlinks=False]]])
        输出在文件夹中的文件名通过在树中游走，向上或者向下。
    os.write(fd, str)
        写入字符串到文件描述符 fd中. 返回实际写入的字符串长度
    os.path 模块
        获取文件的属性信息。
    os.pardir()
        获取当前目录的父目录，以字符串形式显示目录名。
ctypes 调用C++动态库
    https://docs.python.org/3/library/ctypes.html?highlight=ctypes#module-ctypes
    ctypes是py的一个外部功能库
    他提供了与C适配的数据类型，并支持调用动态库或静态库中的方法
    ctypes包中包含cdll模块，在windows下，还包含windll和oledll模块
    在windows下，cdll辅助调用符合cdecl调用约定的函数，windll则