内核对象种类：
  文件对象、文件映射对象、管道对象、I/O完成端口对象、
  进程对象、线程对象、事件对象、互斥量对象、信号量对象、
  可等待的计时器对象、作业对象、访问令牌对象、右键槽对象、线程池工厂对象等等。

内核对象的特性：
可使用Winobj工具查看系统中的内核对象，这些对象是通过不同的函数创建的。
每个内核对象的本质是一个数据结构内存块，它由操作系统内核分配，并只能由操作系统内核访问，
应用程序无法定位这些内存结构并直接修改其内容，只能借助windows提供的函数操纵内核对象。  

对象的生命期：
内核对象的所有者是操作系统而非进程（尽管对象是进程创建的），因此，进程关闭，内核对象不一定销毁。
操作系统通过引用计数来管理内核对象的生存期，只有计数为0时，内核对象才会被销毁。

对象的安全性：
创建内核对象的API一般都会有个安全参数，该参数是个PSECURITY_ATTRIBUTE指针，一般都是传NULL（具有默认的安全性），
然而你也可以设置该参数限定哪些用户和组可以访问该对象，哪些用户和组不能访问该对象。
对象许多程序创建内核对象时并不关心起安全性，但如果想访问一个现有的对象，却必须明确指定打算对该内核对象进行什么操作，如只读/只写/读写等。
记住，获取一个对象权限时，并不一定获取的权限越大越好，合适的才是最好的，例如尝试读一个注册表项是，有人仍喜欢用KEY_ALL_ACCESS，
这在管理员权限下没问题，但如果在普通用户下运行就会导致问题。这个原则对于获取既有内核对象的句柄同样适用。

系统中对象的种类：
除了内核对象，还有用户对象及GDI（图像设备接口）对象，
看一个对象是否是内核对象，最简单的是办法是看创建这个对象的函数，
因为几乎所有创建内核对象的函数，都会带一个允许我们指定对象安全属性的参数。

进程的“内核对象句柄表”
一个进程初始化时，系统会为它分配这样一个句柄表，该表仅供内核对象使用（不适用于用户对象或GDI对象）。
句柄表的结构及管理方式，不用Windows版本的内部实现肯定是有区别的，这里的讲述仅供参考：
  句柄表除了记录内核对象的内存地址外，还会相应的记录其访问权限及其它一些标志（如句柄是否可继承等）；
  该句柄表结构数组的数组索引即为句柄，系统拿这个句柄去句柄表中搜索，便能得到内核对象的内存地址；
  进程首次初始化时，句柄表为空；
  进程创建内核对象时，系统将会把创建的内核对象的句柄塞到该句柄表中；
  创建内核对象API成功返回对象句柄，失败时，有的返回0，有的返回-1；
  
关闭内核对象：
CloseHandle，关闭内核对象前，系统会先拿着这个句柄去进程的“内核对象句柄表”中去查找，看看他有没有关闭的权限，
如果有，就对该内核对象的计数-1，同时清理句柄表中的相应项，如果==0了，就销毁该内核对象。
如果忘了关闭内核对象句柄，当进程终止时，操作系统会扫描该进程的句柄表，并关闭这些内核对象。
――――进程终止时，系统会确保我们的进程不会留下任何东西（包括内存块、GDI对象、内核对象等）。

进程中因为忘了关闭内核对象句柄，导致内核对象数一直增长，该怎样排查：
  使用Process Explorer工具，具体参《Windows核心编程第5版》第41页。
  
跨进程共享内核对象：
内核对象是被保存在内核地址空间的，系统上所有的进程都共享这个空间，
但内核对象的句柄是进程相关的，这是出于安全性的考虑，因为如果句柄是系统级的，
那一个进程就很容易获取到另一个进程正在使用的内核对象，从而对该进程造成破坏。  
那如何跨进程分享使用内核对象呢？有三种方法：
1. 进程具有父子关系的前提下，使用对象句柄继承
  父进程创建一个内核对象时，必须指明该对象是可继承的（使用PSECURITY_ATTRIBUTES参数）；
  父进程创建子进程时（CreateProcess），通过参数指明是否希望创建的子进程继承自己的内核对象句柄。
    如果选择是，则会检索当前进程的句柄表，把其中可继承的且有效的句柄拷贝到子进程的句柄表中。
    在子进程的句柄表中，赋值的项位置与它在父进程的句柄表中的位置完全一致。
    这意味着，在父子进程中，对同一个内核对象，具有相同的句柄值，父进程通常把相应句柄值以命令行参数形式传给子进程。
    ・除了赋值句柄表中的记录项，还会自动增加相应内核对象的引用计数，所以父进程和子进程都需调用ColoseHandle！
  记住：对象句柄的继承，只在子进程创建的时候完成，如果之后父进程又创建了内核对象，则子进程是无法共享该对象的。    
2. 使用命名的内核对象 
  命名对象的特点：
  各种内核对象使用同一个命名空间，而且微软也没提供确保内核对象名字唯一的机制，所以在创建一个有名内核对象时，
  如果系统中已经有这个名字的内核对象了，则：
    如果已有的那个内核对象与当前创建的内核对象是不同类型的： 
      创建对象失败，返回无效的句柄
    如果已有的那个内核对象与当前创建的内核对象是同类型的：
      如果当前进程有权使用原有的那个同名内核对象，则创建成功（原同名内核对象引用计数+1），句柄表中增加该内核对象句柄，可以使用GetLastError判断是真正创建了一个新的内核对象，还是仅仅打开了一个现有的内核对象。
      否则，创建失败，返回无效的句柄
  除了选择创建有名内核对象Create*，使用打开内核对象Open*有时或许是更好的选择。
  我们经常使用命名对象来创建只允许单例运行的程序。
3. 复制对象句柄
  DuplicateHandle函数可以从源进程（第一个参数指定）的句柄表中查找一个句柄项（第二个参数指定），
  然后在目的进程（第三个参数指定）的句柄表中创建这个记录项的副本，第四个参数用以获取复制得到的句柄。
  DuplicateHandle函数不能放在源进程中，而是应该放到目的进程中，或者一个第三方进程中。
  DuplicateHandle函数同时通过第5~7个参数指定复制出来的句柄的可访问性、可继承性及其他标志。
